diff --git a/meta/recipes-devtools/go/go-1.17.13.inc b/meta/recipes-devtools/go/go-1.17.13.inc
deleted file mode 100644
index 330f571d22..0000000000
--- a/meta/recipes-devtools/go/go-1.17.13.inc
+++ /dev/null
@@ -1,59 +0,0 @@
-require go-common.inc
-
-FILESEXTRAPATHS:prepend := "${FILE_DIRNAME}/go-1.21:${FILE_DIRNAME}/go-1.20:${FILE_DIRNAME}/go-1.19:${FILE_DIRNAME}/go-1.18:"
-
-LIC_FILES_CHKSUM = "file://LICENSE;md5=5d4950ecb7b26d2c5e4e7b4e0dd74707"
-
-SRC_URI += "\
-    file://0001-allow-CC-and-CXX-to-have-multiple-words.patch \
-    file://0002-cmd-go-make-content-based-hash-generation-less-pedan.patch \
-    file://0003-allow-GOTOOLDIR-to-be-overridden-in-the-environment.patch \
-    file://0004-ld-add-soname-to-shareable-objects.patch \
-    file://0005-make.bash-override-CC-when-building-dist-and-go_boot.patch \
-    file://0006-cmd-dist-separate-host-and-target-builds.patch \
-    file://0007-cmd-go-make-GOROOT-precious-by-default.patch \
-    file://0008-use-GOBUILDMODE-to-set-buildmode.patch \
-    file://0009-Revert-cmd-go-make-sure-CC-and-CXX-are-absolute.patch \
-    file://0001-exec.go-do-not-write-linker-flags-into-buildids.patch \
-    file://0001-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch \
-    file://0010-net-Fix-issue-with-DNS-not-being-updated.patch  \
-    file://CVE-2022-27664.patch \
-    file://0001-net-http-httputil-avoid-query-parameter-smuggling.patch \
-    file://CVE-2022-41715.patch \
-    file://CVE-2022-41717.patch \
-    file://CVE-2022-2879.patch \
-    file://CVE-2022-41720.patch \
-    file://CVE-2022-41723.patch \
-    file://cve-2022-41724.patch \
-    file://add_godebug.patch \
-    file://cve-2022-41725.patch \
-    file://CVE-2022-41722.patch \
-    file://CVE-2023-24537.patch \
-    file://CVE-2023-24534.patch \
-    file://CVE-2023-24538_1.patch \
-    file://CVE-2023-24538_2.patch \
-    file://CVE-2023-24540.patch \
-    file://CVE-2023-24539.patch \
-    file://CVE-2023-29404.patch \
-    file://CVE-2023-29405.patch \
-    file://CVE-2023-29402.patch \
-    file://CVE-2023-29400.patch \
-    file://CVE-2023-29406.patch \
-    file://CVE-2023-24536_1.patch \
-    file://CVE-2023-24536_2.patch \
-    file://CVE-2023-24536_3.patch \
-    file://CVE-2023-24531_1.patch \
-    file://CVE-2023-24531_2.patch \
-    file://CVE-2023-29409.patch \
-    file://CVE-2023-39319.patch \
-    file://CVE-2023-39318.patch \
-"
-SRC_URI[main.sha256sum] = "a1a48b23afb206f95e7bbaa9b898d965f90826f6f1d1fc0c1d784ada0cd300fd"
-
-# Upstream don't believe it is a signifiant real world issue and will only
-# fix in 1.17 onwards where we can drop this.
-# https://github.com/golang/go/issues/30999#issuecomment-910470358
-CVE_CHECK_IGNORE += "CVE-2021-29923"
-
-# This are specific to Microsoft Windows
-CVE_CHECK_IGNORE += "CVE-2022-41716 CVE-2023-45283 CVE-2023-45284"
diff --git a/meta/recipes-devtools/go/go-1.18/0001-allow-CC-and-CXX-to-have-multiple-words.patch b/meta/recipes-devtools/go/go-1.18/0001-allow-CC-and-CXX-to-have-multiple-words.patch
deleted file mode 100644
index 5f4823be22..0000000000
--- a/meta/recipes-devtools/go/go-1.18/0001-allow-CC-and-CXX-to-have-multiple-words.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 9e3dc44cdfa58d96504d0a789dc82617dd5bef55 Mon Sep 17 00:00:00 2001
-From: Alex Kube <alexander.j.kube@gmail.com>
-Date: Wed, 23 Oct 2019 21:01:13 +0430
-Subject: [PATCH 1/9] cmd/go: Allow CC and CXX to have multiple words
-
-Upstream-Status: Inappropriate [OE specific]
-
-Adapted to Go 1.13 from patches originally submitted to
-the meta/recipes-devtools/go tree by
-Matt Madison <matt@madison.systems>.
-
-Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
-
----
- src/cmd/go/internal/envcmd/env.go | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/src/cmd/go/internal/envcmd/env.go
-+++ b/src/cmd/go/internal/envcmd/env.go
-@@ -103,11 +103,11 @@ func MkEnv() []cfg.EnvVar {
- 
- 	cc := cfg.DefaultCC(cfg.Goos, cfg.Goarch)
- 	if env := strings.Fields(cfg.Getenv("CC")); len(env) > 0 {
--		cc = env[0]
-+		cc = strings.Join(env, " ")
- 	}
- 	cxx := cfg.DefaultCXX(cfg.Goos, cfg.Goarch)
- 	if env := strings.Fields(cfg.Getenv("CXX")); len(env) > 0 {
--		cxx = env[0]
-+		cxx = strings.Join(env, " ")
- 	}
- 	env = append(env, cfg.EnvVar{Name: "AR", Value: envOr("AR", "ar")})
- 	env = append(env, cfg.EnvVar{Name: "CC", Value: cc})
diff --git a/meta/recipes-devtools/go/go-1.18/0001-net-http-httputil-avoid-query-parameter-smuggling.patch b/meta/recipes-devtools/go/go-1.18/0001-net-http-httputil-avoid-query-parameter-smuggling.patch
deleted file mode 100644
index 80fba1446e..0000000000
--- a/meta/recipes-devtools/go/go-1.18/0001-net-http-httputil-avoid-query-parameter-smuggling.patch
+++ /dev/null
@@ -1,178 +0,0 @@
-From c8bdf59453c95528a444a85e1b206c1c09eb20f6 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Thu, 22 Sep 2022 13:32:00 -0700
-Subject: [PATCH] net/http/httputil: avoid query parameter smuggling
-
-Query parameter smuggling occurs when a proxy's interpretation
-of query parameters differs from that of a downstream server.
-Change ReverseProxy to avoid forwarding ignored query parameters.
-
-Remove unparsable query parameters from the outbound request
-
-   * if req.Form != nil after calling ReverseProxy.Director; and
-   * before calling ReverseProxy.Rewrite.
-
-This change preserves the existing behavior of forwarding the
-raw query untouched if a Director hook does not parse the query
-by calling Request.ParseForm (possibly indirectly).
-
-Fixes #55842
-For #54663
-For CVE-2022-2880
-
-Change-Id: If1621f6b0e73a49d79059dae9e6b256e0ff18ca9
-Reviewed-on: https://go-review.googlesource.com/c/go/+/432976
-Reviewed-by: Roland Shoemaker <roland@golang.org>
-Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Damien Neil <dneil@google.com>
-(cherry picked from commit 7c84234142149bd24a4096c6cab691d3593f3431)
-Reviewed-on: https://go-review.googlesource.com/c/go/+/433695
-Reviewed-by: Dmitri Shuralyov <dmitshur@golang.org>
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-
-CVE: CVE-2022-2880
-Upstream-Status: Backport [9d2c73a9fd69e45876509bb3bdb2af99bf77da1e]
-
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/net/http/httputil/reverseproxy.go      | 36 +++++++++++
- src/net/http/httputil/reverseproxy_test.go | 74 ++++++++++++++++++++++
- 2 files changed, 110 insertions(+)
-
-diff --git a/src/net/http/httputil/reverseproxy.go b/src/net/http/httputil/reverseproxy.go
-index 8b63368..c76eec6 100644
---- a/src/net/http/httputil/reverseproxy.go
-+++ b/src/net/http/httputil/reverseproxy.go
-@@ -249,6 +249,9 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
- 	}
- 
- 	p.Director(outreq)
-+	if outreq.Form != nil {
-+		outreq.URL.RawQuery = cleanQueryParams(outreq.URL.RawQuery)
-+	}
- 	outreq.Close = false
- 
- 	reqUpType := upgradeType(outreq.Header)
-@@ -628,3 +631,36 @@ func (c switchProtocolCopier) copyToBackend(errc chan<- error) {
- 	_, err := io.Copy(c.backend, c.user)
- 	errc <- err
- }
-+
-+func cleanQueryParams(s string) string {
-+	reencode := func(s string) string {
-+		v, _ := url.ParseQuery(s)
-+		return v.Encode()
-+	}
-+	for i := 0; i < len(s); {
-+		switch s[i] {
-+		case ';':
-+			return reencode(s)
-+		case '%':
-+			if i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {
-+				return reencode(s)
-+			}
-+			i += 3
-+		default:
-+			i++
-+		}
-+	}
-+	return s
-+}
-+
-+func ishex(c byte) bool {
-+	switch {
-+	case '0' <= c && c <= '9':
-+		return true
-+	case 'a' <= c && c <= 'f':
-+		return true
-+	case 'A' <= c && c <= 'F':
-+		return true
-+	}
-+	return false
-+}
-diff --git a/src/net/http/httputil/reverseproxy_test.go b/src/net/http/httputil/reverseproxy_test.go
-index 4b6ad77..8c0a4f1 100644
---- a/src/net/http/httputil/reverseproxy_test.go
-+++ b/src/net/http/httputil/reverseproxy_test.go
-@@ -1517,3 +1517,77 @@ func TestJoinURLPath(t *testing.T) {
- 		}
- 	}
- }
-+
-+const (
-+	testWantsCleanQuery = true
-+	testWantsRawQuery   = false
-+)
-+
-+func TestReverseProxyQueryParameterSmugglingDirectorDoesNotParseForm(t *testing.T) {
-+	testReverseProxyQueryParameterSmuggling(t, testWantsRawQuery, func(u *url.URL) *ReverseProxy {
-+		proxyHandler := NewSingleHostReverseProxy(u)
-+		oldDirector := proxyHandler.Director
-+		proxyHandler.Director = func(r *http.Request) {
-+			oldDirector(r)
-+		}
-+		return proxyHandler
-+	})
-+}
-+
-+func TestReverseProxyQueryParameterSmugglingDirectorParsesForm(t *testing.T) {
-+	testReverseProxyQueryParameterSmuggling(t, testWantsCleanQuery, func(u *url.URL) *ReverseProxy {
-+		proxyHandler := NewSingleHostReverseProxy(u)
-+		oldDirector := proxyHandler.Director
-+		proxyHandler.Director = func(r *http.Request) {
-+			// Parsing the form causes ReverseProxy to remove unparsable
-+			// query parameters before forwarding.
-+			r.FormValue("a")
-+			oldDirector(r)
-+		}
-+		return proxyHandler
-+	})
-+}
-+
-+func testReverseProxyQueryParameterSmuggling(t *testing.T, wantCleanQuery bool, newProxy func(*url.URL) *ReverseProxy) {
-+	const content = "response_content"
-+	backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-+		w.Write([]byte(r.URL.RawQuery))
-+	}))
-+	defer backend.Close()
-+	backendURL, err := url.Parse(backend.URL)
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	proxyHandler := newProxy(backendURL)
-+	frontend := httptest.NewServer(proxyHandler)
-+	defer frontend.Close()
-+
-+	// Don't spam output with logs of queries containing semicolons.
-+	backend.Config.ErrorLog = log.New(io.Discard, "", 0)
-+	frontend.Config.ErrorLog = log.New(io.Discard, "", 0)
-+
-+	for _, test := range []struct {
-+		rawQuery   string
-+		cleanQuery string
-+	}{{
-+		rawQuery:   "a=1&a=2;b=3",
-+		cleanQuery: "a=1",
-+	}, {
-+		rawQuery:   "a=1&a=%zz&b=3",
-+		cleanQuery: "a=1&b=3",
-+	}} {
-+		res, err := frontend.Client().Get(frontend.URL + "?" + test.rawQuery)
-+		if err != nil {
-+			t.Fatalf("Get: %v", err)
-+		}
-+		defer res.Body.Close()
-+		body, _ := io.ReadAll(res.Body)
-+		wantQuery := test.rawQuery
-+		if wantCleanQuery {
-+			wantQuery = test.cleanQuery
-+		}
-+		if got, want := string(body), wantQuery; got != want {
-+			t.Errorf("proxy forwarded raw query %q as %q, want %q", test.rawQuery, got, want)
-+		}
-+	}
-+}
--- 
-2.32.0
-
diff --git a/meta/recipes-devtools/go/go-1.18/0002-cmd-go-make-content-based-hash-generation-less-pedan.patch b/meta/recipes-devtools/go/go-1.18/0002-cmd-go-make-content-based-hash-generation-less-pedan.patch
deleted file mode 100644
index 42cd568ef9..0000000000
--- a/meta/recipes-devtools/go/go-1.18/0002-cmd-go-make-content-based-hash-generation-less-pedan.patch
+++ /dev/null
@@ -1,237 +0,0 @@
-From c403b45995c5daa6747ac4d95b39bc9a6feb2cda Mon Sep 17 00:00:00 2001
-From: Alex Kube <alexander.j.kube@gmail.com>
-Date: Wed, 23 Oct 2019 21:14:22 +0430
-Subject: [PATCH] cmd/go: make content-based hash generation less pedantic
-
-Upstream-Status: Inappropriate [OE specific]
-
-Go 1.10's build tool now uses content-based hashes to
-determine when something should be built or re-built.
-This same mechanism is used to maintain a built-artifact
-cache for speeding up builds.
-
-However, the hashes it generates include information that
-doesn't work well with OE, nor with using a shared runtime
-library.
-
-First, it embeds path names to source files, unless
-building within GOROOT.  This prevents the building
-of a package in GOPATH for later staging into GOROOT.
-
-This patch adds support for the environment variable
-GOPATH_OMIT_IN_ACTIONID.  If present, path name
-embedding is disabled.
-
-Second, if cgo is enabled, the build ID for cgo-related
-packages will include the current value of the environment
-variables for invoking the compiler (CC, CXX, FC) and
-any CGO_xxFLAGS variables.  Only if the settings used
-during a compilation exactly match, character for character,
-the values used for compiling runtime/cgo or any other
-cgo-enabled package being imported, will the tool
-decide that the imported package is up-to-date.
-
-This is done to help ensure correctness, but is overly
-simplistic and effectively prevents the reuse of built
-artifacts that use cgo (or shared runtime, which includes
-runtime/cgo).
-
-This patch filters out all compiler flags except those
-beginning with '-m'.  The default behavior can be restored
-by setting the CGO_PEDANTIC environment variable.
-
-Adapted to Go 1.13 from patches originally submitted to
-the meta/recipes-devtools/go tree by
-Matt Madison <matt@madison.systems>.
-
-Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
----
- src/cmd/go/internal/envcmd/env.go |  2 +-
- src/cmd/go/internal/work/exec.go  | 66 ++++++++++++++++++++++---------
- 2 files changed, 49 insertions(+), 19 deletions(-)
-
-diff --git a/src/cmd/go/internal/envcmd/env.go b/src/cmd/go/internal/envcmd/env.go
-index 20d0587..ff6f0d8 100644
---- a/src/cmd/go/internal/envcmd/env.go
-+++ b/src/cmd/go/internal/envcmd/env.go
-@@ -160,7 +160,7 @@ func ExtraEnvVars() []cfg.EnvVar {
- func ExtraEnvVarsCostly() []cfg.EnvVar {
- 	var b work.Builder
- 	b.Init()
--	cppflags, cflags, cxxflags, fflags, ldflags, err := b.CFlags(&load.Package{})
-+	cppflags, cflags, cxxflags, fflags, ldflags, err := b.CFlags(&load.Package{}, false)
- 	if err != nil {
- 		// Should not happen - b.CFlags was given an empty package.
- 		fmt.Fprintf(os.Stderr, "go: invalid cflags: %v\n", err)
-diff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go
-index 5a225fb..a37872e 100644
---- a/src/cmd/go/internal/work/exec.go
-+++ b/src/cmd/go/internal/work/exec.go
-@@ -38,6 +38,8 @@ import (
- 	"cmd/go/internal/trace"
- )
- 
-+var omitGopath = os.Getenv("GOPATH_OMIT_IN_ACTIONID") != ""
-+
- // actionList returns the list of actions in the dag rooted at root
- // as visited in a depth-first post-order traversal.
- func actionList(root *Action) []*Action {
-@@ -229,7 +231,7 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
- 	// Assume b.WorkDir is being trimmed properly.
- 	// When -trimpath is used with a package built from the module cache,
- 	// use the module path and version instead of the directory.
--	if !p.Goroot && !cfg.BuildTrimpath && !strings.HasPrefix(p.Dir, b.WorkDir) {
-+	if !p.Goroot && !omitGopath && !cfg.BuildTrimpath && !strings.HasPrefix(p.Dir, b.WorkDir) {
- 		fmt.Fprintf(h, "dir %s\n", p.Dir)
- 	} else if cfg.BuildTrimpath && p.Module != nil {
- 		fmt.Fprintf(h, "module %s@%s\n", p.Module.Path, p.Module.Version)
-@@ -248,9 +250,9 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
- 	}
- 	if len(p.CgoFiles)+len(p.SwigFiles)+len(p.SwigCXXFiles) > 0 {
- 		fmt.Fprintf(h, "cgo %q\n", b.toolID("cgo"))
--		cppflags, cflags, cxxflags, fflags, ldflags, _ := b.CFlags(p)
-+		cppflags, cflags, cxxflags, fflags, ldflags, _ := b.CFlags(p, true)
- 
--		ccExe := b.ccExe()
-+		ccExe := b.ccExe(true)
- 		fmt.Fprintf(h, "CC=%q %q %q %q\n", ccExe, cppflags, cflags, ldflags)
- 		// Include the C compiler tool ID so that if the C
- 		// compiler changes we rebuild the package.
-@@ -263,14 +265,14 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
- 			}
- 		}
- 		if len(p.CXXFiles)+len(p.SwigCXXFiles) > 0 {
--			cxxExe := b.cxxExe()
-+			cxxExe := b.cxxExe(true)
- 			fmt.Fprintf(h, "CXX=%q %q\n", cxxExe, cxxflags)
- 			if cxxID, err := b.gccToolID(cxxExe[0], "c++"); err == nil {
- 				fmt.Fprintf(h, "CXX ID=%q\n", cxxID)
- 			}
- 		}
- 		if len(p.FFiles) > 0 {
--			fcExe := b.fcExe()
-+			fcExe := b.fcExe(true)
- 			fmt.Fprintf(h, "FC=%q %q\n", fcExe, fflags)
- 			if fcID, err := b.gccToolID(fcExe[0], "f95"); err == nil {
- 				fmt.Fprintf(h, "FC ID=%q\n", fcID)
-@@ -2438,33 +2440,48 @@ var (
- // gccCmd returns a gcc command line prefix
- // defaultCC is defined in zdefaultcc.go, written by cmd/dist.
- func (b *Builder) GccCmd(incdir, workdir string) []string {
--	return b.compilerCmd(b.ccExe(), incdir, workdir)
-+	return b.compilerCmd(b.ccExe(false), incdir, workdir)
- }
- 
- // gxxCmd returns a g++ command line prefix
- // defaultCXX is defined in zdefaultcc.go, written by cmd/dist.
- func (b *Builder) GxxCmd(incdir, workdir string) []string {
--	return b.compilerCmd(b.cxxExe(), incdir, workdir)
-+	return b.compilerCmd(b.cxxExe(false), incdir, workdir)
- }
- 
- // gfortranCmd returns a gfortran command line prefix.
- func (b *Builder) gfortranCmd(incdir, workdir string) []string {
--	return b.compilerCmd(b.fcExe(), incdir, workdir)
-+	return b.compilerCmd(b.fcExe(false), incdir, workdir)
- }
- 
- // ccExe returns the CC compiler setting without all the extra flags we add implicitly.
--func (b *Builder) ccExe() []string {
--	return b.compilerExe(origCC, cfg.DefaultCC(cfg.Goos, cfg.Goarch))
-+func (b *Builder) ccExe(filtered bool) []string {
-+	return b.compilerExe(origCC, cfg.DefaultCC(cfg.Goos, cfg.Goarch), filtered)
- }
- 
- // cxxExe returns the CXX compiler setting without all the extra flags we add implicitly.
--func (b *Builder) cxxExe() []string {
--	return b.compilerExe(origCXX, cfg.DefaultCXX(cfg.Goos, cfg.Goarch))
-+func (b *Builder) cxxExe(filtered bool) []string {
-+	return b.compilerExe(origCXX, cfg.DefaultCXX(cfg.Goos, cfg.Goarch), filtered)
- }
- 
- // fcExe returns the FC compiler setting without all the extra flags we add implicitly.
--func (b *Builder) fcExe() []string {
--	return b.compilerExe(cfg.Getenv("FC"), "gfortran")
-+func (b *Builder) fcExe(filtered bool) []string {
-+	return b.compilerExe(os.Getenv("FC"), "gfortran", filtered)
-+}
-+
-+var filterFlags = os.Getenv("CGO_PEDANTIC") == ""
-+
-+func filterCompilerFlags(flags []string) []string {
-+	var newflags []string
-+	if !filterFlags {
-+		return flags
-+	}
-+	for _, flag := range flags {
-+		if strings.HasPrefix(flag, "-m") {
-+			newflags = append(newflags, flag)
-+		}
-+	}
-+	return newflags
- }
- 
- // compilerExe returns the compiler to use given an
-@@ -2473,11 +2490,16 @@ func (b *Builder) fcExe() []string {
- // of the compiler but can have additional arguments if they
- // were present in the environment value.
- // For example if CC="gcc -DGOPHER" then the result is ["gcc", "-DGOPHER"].
--func (b *Builder) compilerExe(envValue string, def string) []string {
-+func (b *Builder) compilerExe(envValue string, def string, filtered bool) []string {
- 	compiler := strings.Fields(envValue)
- 	if len(compiler) == 0 {
- 		compiler = strings.Fields(def)
- 	}
-+
-+	if filtered {
-+		return append(compiler[0:1], filterCompilerFlags(compiler[1:])...)
-+	}
-+
- 	return compiler
- }
- 
-@@ -2667,7 +2689,7 @@ func envList(key, def string) []string {
- }
- 
- // CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.
--func (b *Builder) CFlags(p *load.Package) (cppflags, cflags, cxxflags, fflags, ldflags []string, err error) {
-+func (b *Builder) CFlags(p *load.Package, filtered bool) (cppflags, cflags, cxxflags, fflags, ldflags []string, err error) {
- 	defaults := "-g -O2"
- 
- 	if cppflags, err = buildFlags("CPPFLAGS", "", p.CgoCPPFLAGS, checkCompilerFlags); err != nil {
-@@ -2686,6 +2708,14 @@ func (b *Builder) CFlags(p *load.Package) (cppflags, cflags, cxxflags, fflags, l
- 		return
- 	}
- 
-+	if filtered {
-+		cppflags = filterCompilerFlags(cppflags)
-+		cflags = filterCompilerFlags(cflags)
-+		cxxflags = filterCompilerFlags(cxxflags)
-+		fflags = filterCompilerFlags(fflags)
-+		ldflags = filterCompilerFlags(ldflags)
-+	}
-+
- 	return
- }
- 
-@@ -2700,7 +2730,7 @@ var cgoRe = lazyregexp.New(`[/\\:]`)
- 
- func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {
- 	p := a.Package
--	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS, err := b.CFlags(p)
-+	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS, err := b.CFlags(p, false)
- 	if err != nil {
- 		return nil, nil, err
- 	}
-@@ -3151,7 +3181,7 @@ func (b *Builder) swigIntSize(objdir string) (intsize string, err error) {
- 
- // Run SWIG on one SWIG input file.
- func (b *Builder) swigOne(a *Action, p *load.Package, file, objdir string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {
--	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _, err := b.CFlags(p)
-+	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _, err := b.CFlags(p, false)
- 	if err != nil {
- 		return "", "", err
- 	}
--- 
-2.20.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/0008-use-GOBUILDMODE-to-set-buildmode.patch b/meta/recipes-devtools/go/go-1.18/0008-use-GOBUILDMODE-to-set-buildmode.patch
deleted file mode 100644
index 4e5d5021d6..0000000000
--- a/meta/recipes-devtools/go/go-1.18/0008-use-GOBUILDMODE-to-set-buildmode.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-From 971b5626339ce0c4d57f9721c9a81af566c5a044 Mon Sep 17 00:00:00 2001
-From: Alex Kube <alexander.j.kube@gmail.com>
-Date: Wed, 23 Oct 2019 21:19:26 +0430
-Subject: [PATCH 8/9] cmd/go: Use GOBUILDMODE to set buildmode
-
-Upstream-Status: Denied [upstream choose antoher solution: `17a256b
-cmd/go: -buildmode=pie for android/arm']
-
-While building go itself, the go build system does not support
-to set `-buildmode=pie' from environment.
-
-Add GOBUILDMODE to support it which make PIE executables the default
-build mode, as PIE executables are required as of Yocto
-
-Refers: https://groups.google.com/forum/#!topic/golang-dev/gRCe5URKewI
-
-Adapted to Go 1.13 from patches originally submitted to
-the meta/recipes-devtools/go tree by
-Hongxu Jia <hongxu.jia@windriver.com>
-
-Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
----
- src/cmd/go/internal/work/build.go | 8 +++++++-
- 1 file changed, 7 insertions(+), 1 deletion(-)
-
---- a/src/cmd/go/internal/work/build.go
-+++ b/src/cmd/go/internal/work/build.go
-@@ -254,7 +254,13 @@ func AddBuildFlags(cmd *base.Command, ma
- 
- 	cmd.Flag.Var(&load.BuildAsmflags, "asmflags", "")
- 	cmd.Flag.Var(buildCompiler{}, "compiler", "")
--	cmd.Flag.StringVar(&cfg.BuildBuildmode, "buildmode", "default", "")
-+
-+	if bm := os.Getenv("GOBUILDMODE"); bm != "" {
-+		cmd.Flag.StringVar(&cfg.BuildBuildmode, "buildmode", bm, "")
-+	} else {
-+		cmd.Flag.StringVar(&cfg.BuildBuildmode, "buildmode", "default", "")
-+	}
-+
- 	cmd.Flag.Var(&load.BuildGcflags, "gcflags", "")
- 	cmd.Flag.Var(&load.BuildGccgoflags, "gccgoflags", "")
- 	if mask&OmitModFlag == 0 {
diff --git a/meta/recipes-devtools/go/go-1.18/0009-Revert-cmd-go-make-sure-CC-and-CXX-are-absolute.patch b/meta/recipes-devtools/go/go-1.18/0009-Revert-cmd-go-make-sure-CC-and-CXX-are-absolute.patch
deleted file mode 100644
index f857b72234..0000000000
--- a/meta/recipes-devtools/go/go-1.18/0009-Revert-cmd-go-make-sure-CC-and-CXX-are-absolute.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 66a45dae3af140662e17ef85c2e6fe40270a2553 Mon Sep 17 00:00:00 2001
-From: Khem Raj <raj.khem@gmail.com>
-Date: Mon, 22 Feb 2021 17:54:01 -0800
-Subject: [PATCH] Revert "cmd/go: make sure CC and CXX are absolute"
-
-OE uses CC/CXX values which consists of cmpiler and options together,
-secondly, the environment is canned so this check add little value to OE
-based builds
-
-Fixes go-runtime build issues
-
-go install: CXX environment variable is relative; must be absolute path: powerpc64le-yoe-linux-musl-g++ -mlittle-endian -mhard-float -m64 -mabi=elfv2 -mcpu=power9 -fstack-protector-strong -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=/mnt/b/yoe/master/build/tmp/work/ppc64p9le-yoe-linux-musl/go/1.16-r0/recipe-sysroot
-
-This reverts commit aa161e799df7e1eba99d2be10271e76b6f758142.
-
-Upstream-Status: Inappropriate [OE-Specific]
-Signed-off-by: Khem Raj <raj.khem@gmail.com>
----
- src/cmd/go/internal/envcmd/env.go        |  5 -----
- src/cmd/go/internal/work/init.go         |  6 ------
- src/cmd/go/testdata/script/env_write.txt | 24 ------------------------
- 3 files changed, 35 deletions(-)
-
-diff --git a/src/cmd/go/internal/envcmd/env.go b/src/cmd/go/internal/envcmd/env.go
-index ff6f0d8..43b94e7 100644
---- a/src/cmd/go/internal/envcmd/env.go
-+++ b/src/cmd/go/internal/envcmd/env.go
-@@ -457,11 +457,6 @@ func checkEnvWrite(key, val string) error {
- 		if !filepath.IsAbs(val) && val != "" {
- 			return fmt.Errorf("GOPATH entry is relative; must be absolute path: %q", val)
- 		}
--	// Make sure CC and CXX are absolute paths
--	case "CC", "CXX", "GOMODCACHE":
--		if !filepath.IsAbs(val) && val != "" && val != filepath.Base(val) {
--			return fmt.Errorf("%s entry is relative; must be absolute path: %q", key, val)
--		}
- 	}
- 
- 	if !utf8.ValidString(val) {
-diff --git a/src/cmd/go/internal/work/init.go b/src/cmd/go/internal/work/init.go
-index 37a3e2d..316b0cf 100644
---- a/src/cmd/go/internal/work/init.go
-+++ b/src/cmd/go/internal/work/init.go
-@@ -39,12 +39,6 @@ func BuildInit() {
- 		cfg.BuildPkgdir = p
- 	}
- 
--	// Make sure CC and CXX are absolute paths
--	for _, key := range []string{"CC", "CXX"} {
--		if path := cfg.Getenv(key); !filepath.IsAbs(path) && path != "" && path != filepath.Base(path) {
--			base.Fatalf("go %s: %s environment variable is relative; must be absolute path: %s\n", flag.Args()[0], key, path)
--		}
--	}
- }
- 
- func instrumentInit() {
-diff --git a/src/cmd/go/testdata/script/env_write.txt b/src/cmd/go/testdata/script/env_write.txt
-index b5e9739..566c876 100644
---- a/src/cmd/go/testdata/script/env_write.txt
-+++ b/src/cmd/go/testdata/script/env_write.txt
-@@ -129,30 +129,6 @@ go env -w GOTMPDIR=
- go env GOTMPDIR
- stdout ^$
- 
--# go env -w rejects relative CC values
--[!windows] go env -w CC=/usr/bin/clang
--go env -w CC=clang
--[!windows] ! go env -w CC=./clang
--[!windows] ! go env -w CC=bin/clang
--[!windows] stderr 'go env -w: CC entry is relative; must be absolute path'
--
--[windows] go env -w CC=$WORK\bin\clang
--[windows] ! go env -w CC=.\clang
--[windows] ! go env -w CC=bin\clang
--[windows] stderr 'go env -w: CC entry is relative; must be absolute path'
--
--# go env -w rejects relative CXX values
--[!windows] go env -w CC=/usr/bin/cpp
--go env -w CXX=cpp
--[!windows] ! go env -w CXX=./cpp
--[!windows] ! go env -w CXX=bin/cpp
--[!windows] stderr 'go env -w: CXX entry is relative; must be absolute path'
--
--[windows] go env -w CXX=$WORK\bin\cpp
--[windows] ! go env -w CXX=.\cpp
--[windows] ! go env -w CXX=bin\cpp
--[windows] stderr 'go env -w: CXX entry is relative; must be absolute path'
--
- # go env -w/-u checks validity of GOOS/ARCH combinations
- env GOOS=
- env GOARCH=
--- 
-2.20.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-27664.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-27664.patch
deleted file mode 100644
index fba4f054ee..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-27664.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From 5bc9106458fc07851ac324a4157132a91b1f3479 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Mon, 22 Aug 2022 16:21:02 -0700
-Subject: [PATCH] [release-branch.go1.18] net/http: update bundled
- golang.org/x/net/http2
-
-Disable cmd/internal/moddeps test, since this update includes PRIVATE
-track fixes.
-
-Fixes CVE-2022-27664
-Fixes #53977
-For #54658.
-
-Change-Id: I84b0b8f61e49e15ef55ef8d738730107a3cf849b
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1554415
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/428635
-Reviewed-by: Tatiana Bradley <tatiana@golang.org>
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Carlos Amedee <carlos@golang.org>
-
-Upstream-Status: Backport
-CVE: CVE-2022-27664 
-
-Reference to upstream patch: https://github.com/golang/go/commit/5bc9106458fc07851ac324a4157132a91b1f3479
-Signed-off-by: Teoh Jay Shen <jay.shen.teoh@intel.com>
----
- src/cmd/internal/moddeps/moddeps_test.go |  2 ++
- src/net/http/h2_bundle.go                | 21 +++++++++++++--------
- 2 files changed, 15 insertions(+), 8 deletions(-)
-
-diff --git a/src/cmd/internal/moddeps/moddeps_test.go b/src/cmd/internal/moddeps/moddeps_test.go
-index 56c3b2585c..3306e29431 100644
---- a/src/cmd/internal/moddeps/moddeps_test.go
-+++ b/src/cmd/internal/moddeps/moddeps_test.go
-@@ -34,6 +34,8 @@ import (
- // See issues 36852, 41409, and 43687.
- // (Also see golang.org/issue/27348.)
- func TestAllDependencies(t *testing.T) {
-+	t.Skip("TODO(#53977): 1.18.5 contains unreleased changes from vendored modules")
-+
- 	goBin := testenv.GoToolPath(t)
- 
- 	// Ensure that all packages imported within GOROOT
-diff --git a/src/net/http/h2_bundle.go b/src/net/http/h2_bundle.go
-index bb82f24585..1e78f6cdb9 100644
---- a/src/net/http/h2_bundle.go
-+++ b/src/net/http/h2_bundle.go
-@@ -3384,10 +3384,11 @@ func (s http2SettingID) String() string {
- // name (key). See httpguts.ValidHeaderName for the base rules.
- //
- // Further, http2 says:
--//   "Just as in HTTP/1.x, header field names are strings of ASCII
--//   characters that are compared in a case-insensitive
--//   fashion. However, header field names MUST be converted to
--//   lowercase prior to their encoding in HTTP/2. "
-+//
-+//	"Just as in HTTP/1.x, header field names are strings of ASCII
-+//	characters that are compared in a case-insensitive
-+//	fashion. However, header field names MUST be converted to
-+//	lowercase prior to their encoding in HTTP/2. "
- func http2validWireHeaderFieldName(v string) bool {
- 	if len(v) == 0 {
- 		return false
-@@ -3578,8 +3579,8 @@ func (s *http2sorter) SortStrings(ss []string) {
- // validPseudoPath reports whether v is a valid :path pseudo-header
- // value. It must be either:
- //
--//     *) a non-empty string starting with '/'
--//     *) the string '*', for OPTIONS requests.
-+//	*) a non-empty string starting with '/'
-+//	*) the string '*', for OPTIONS requests.
- //
- // For now this is only used a quick check for deciding when to clean
- // up Opaque URLs before sending requests from the Transport.
-@@ -5053,6 +5054,9 @@ func (sc *http2serverConn) startGracefulShutdownInternal() {
- func (sc *http2serverConn) goAway(code http2ErrCode) {
- 	sc.serveG.check()
- 	if sc.inGoAway {
-+		if sc.goAwayCode == http2ErrCodeNo {
-+			sc.goAwayCode = code
-+		}
- 		return
- 	}
- 	sc.inGoAway = true
-@@ -6265,8 +6269,9 @@ func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error) {
- // prior to the headers being written. If the set of trailers is fixed
- // or known before the header is written, the normal Go trailers mechanism
- // is preferred:
--//    https://golang.org/pkg/net/http/#ResponseWriter
--//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
-+//
-+//	https://golang.org/pkg/net/http/#ResponseWriter
-+//	https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
- const http2TrailerPrefix = "Trailer:"
- 
- // promoteUndeclaredTrailers permits http.Handlers to set trailers
--- 
-2.36.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-2879.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-2879.patch
deleted file mode 100644
index 0315e1a3ee..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-2879.patch
+++ /dev/null
@@ -1,177 +0,0 @@
-From d064ed520a7cc6b480f9565e30751e695d394f4e Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Fri, 2 Sep 2022 20:45:18 -0700
-Subject: [PATCH] archive/tar: limit size of headers
-
-Set a 1MiB limit on special file blocks (PAX headers, GNU long names,
-GNU link names), to avoid reading arbitrarily large amounts of data
-into memory.
-
-Thanks to Adam Korczynski (ADA Logics) and OSS-Fuzz for reporting
-this issue.
-
-Fixes CVE-2022-2879
-Updates #54853
-Fixes #55925
-
-Change-Id: I85136d6ff1e0af101a112190e027987ab4335680
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1565555
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-(cherry picked from commit 6ee768cef6b82adf7a90dcf367a1699ef694f3b2)
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1590622
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/438500
-Reviewed-by: Dmitri Shuralyov <dmitshur@golang.org>
-Reviewed-by: Carlos Amedee <carlos@golang.org>
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-Run-TryBot: Carlos Amedee <carlos@golang.org>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-
-CVE: CVE-2022-2879
-Upstream-Status: Backport [0a723816cd205576945fa57fbdde7e6532d59d08]
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/archive/tar/format.go      |  4 ++++
- src/archive/tar/reader.go      | 14 ++++++++++++--
- src/archive/tar/reader_test.go |  8 +++++++-
- src/archive/tar/writer.go      |  3 +++
- src/archive/tar/writer_test.go | 27 +++++++++++++++++++++++++++
- 5 files changed, 53 insertions(+), 3 deletions(-)
-
-diff --git a/src/archive/tar/format.go b/src/archive/tar/format.go
-index cfe24a5..6642364 100644
---- a/src/archive/tar/format.go
-+++ b/src/archive/tar/format.go
-@@ -143,6 +143,10 @@ const (
- 	blockSize  = 512 // Size of each block in a tar stream
- 	nameSize   = 100 // Max length of the name field in USTAR format
- 	prefixSize = 155 // Max length of the prefix field in USTAR format
-+
-+	// Max length of a special file (PAX header, GNU long name or link).
-+	// This matches the limit used by libarchive.
-+	maxSpecialFileSize = 1 << 20
- )
- 
- // blockPadding computes the number of bytes needed to pad offset up to the
-diff --git a/src/archive/tar/reader.go b/src/archive/tar/reader.go
-index 1b1d5b4..f645af8 100644
---- a/src/archive/tar/reader.go
-+++ b/src/archive/tar/reader.go
-@@ -103,7 +103,7 @@ func (tr *Reader) next() (*Header, error) {
- 			continue // This is a meta header affecting the next header
- 		case TypeGNULongName, TypeGNULongLink:
- 			format.mayOnlyBe(FormatGNU)
--			realname, err := io.ReadAll(tr)
-+			realname, err := readSpecialFile(tr)
- 			if err != nil {
- 				return nil, err
- 			}
-@@ -293,7 +293,7 @@ func mergePAX(hdr *Header, paxHdrs map[string]string) (err error) {
- // parsePAX parses PAX headers.
- // If an extended header (type 'x') is invalid, ErrHeader is returned
- func parsePAX(r io.Reader) (map[string]string, error) {
--	buf, err := io.ReadAll(r)
-+	buf, err := readSpecialFile(r)
- 	if err != nil {
- 		return nil, err
- 	}
-@@ -826,6 +826,16 @@ func tryReadFull(r io.Reader, b []byte) (n int, err error) {
- 	return n, err
- }
- 
-+// readSpecialFile is like io.ReadAll except it returns
-+// ErrFieldTooLong if more than maxSpecialFileSize is read.
-+func readSpecialFile(r io.Reader) ([]byte, error) {
-+	buf, err := io.ReadAll(io.LimitReader(r, maxSpecialFileSize+1))
-+	if len(buf) > maxSpecialFileSize {
-+		return nil, ErrFieldTooLong
-+	}
-+	return buf, err
-+}
-+
- // discard skips n bytes in r, reporting an error if unable to do so.
- func discard(r io.Reader, n int64) error {
- 	// If possible, Seek to the last byte before the end of the data section.
-diff --git a/src/archive/tar/reader_test.go b/src/archive/tar/reader_test.go
-index 789ddc1..926dc3d 100644
---- a/src/archive/tar/reader_test.go
-+++ b/src/archive/tar/reader_test.go
-@@ -6,6 +6,7 @@ package tar
- 
- import (
- 	"bytes"
-+	"compress/bzip2"
- 	"crypto/md5"
- 	"errors"
- 	"fmt"
-@@ -625,9 +626,14 @@ func TestReader(t *testing.T) {
- 			}
- 			defer f.Close()
- 
-+			var fr io.Reader = f
-+			if strings.HasSuffix(v.file, ".bz2") {
-+				fr = bzip2.NewReader(fr)
-+			}
-+
- 			// Capture all headers and checksums.
- 			var (
--				tr      = NewReader(f)
-+				tr      = NewReader(fr)
- 				hdrs    []*Header
- 				chksums []string
- 				rdbuf   = make([]byte, 8)
-diff --git a/src/archive/tar/writer.go b/src/archive/tar/writer.go
-index e80498d..893eac0 100644
---- a/src/archive/tar/writer.go
-+++ b/src/archive/tar/writer.go
-@@ -199,6 +199,9 @@ func (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error {
- 			flag = TypeXHeader
- 		}
- 		data := buf.String()
-+		if len(data) > maxSpecialFileSize {
-+			return ErrFieldTooLong
-+		}
- 		if err := tw.writeRawFile(name, data, flag, FormatPAX); err != nil || isGlobal {
- 			return err // Global headers return here
- 		}
-diff --git a/src/archive/tar/writer_test.go b/src/archive/tar/writer_test.go
-index a00f02d..4e709e5 100644
---- a/src/archive/tar/writer_test.go
-+++ b/src/archive/tar/writer_test.go
-@@ -1006,6 +1006,33 @@ func TestIssue12594(t *testing.T) {
- 	}
- }
- 
-+func TestWriteLongHeader(t *testing.T) {
-+	for _, test := range []struct {
-+		name string
-+		h    *Header
-+	}{{
-+		name: "name too long",
-+		h:    &Header{Name: strings.Repeat("a", maxSpecialFileSize)},
-+	}, {
-+		name: "linkname too long",
-+		h:    &Header{Linkname: strings.Repeat("a", maxSpecialFileSize)},
-+	}, {
-+		name: "uname too long",
-+		h:    &Header{Uname: strings.Repeat("a", maxSpecialFileSize)},
-+	}, {
-+		name: "gname too long",
-+		h:    &Header{Gname: strings.Repeat("a", maxSpecialFileSize)},
-+	}, {
-+		name: "PAX header too long",
-+		h:    &Header{PAXRecords: map[string]string{"GOLANG.x": strings.Repeat("a", maxSpecialFileSize)}},
-+	}} {
-+		w := NewWriter(io.Discard)
-+		if err := w.WriteHeader(test.h); err != ErrFieldTooLong {
-+			t.Errorf("%v: w.WriteHeader() = %v, want ErrFieldTooLong", test.name, err)
-+		}
-+	}
-+}
-+
- // testNonEmptyWriter wraps an io.Writer and ensures that
- // Write is never called with an empty buffer.
- type testNonEmptyWriter struct{ io.Writer }
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-41715.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-41715.patch
deleted file mode 100644
index 994f37aaf3..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-41715.patch
+++ /dev/null
@@ -1,270 +0,0 @@
-From e9017c2416ad0ef642f5e0c2eab2dbf3cba4d997 Mon Sep 17 00:00:00 2001
-From: Russ Cox <rsc@golang.org>
-Date: Wed, 28 Sep 2022 11:18:51 -0400
-Subject: [PATCH] [release-branch.go1.18] regexp: limit size of parsed regexps
-
-Set a 128 MB limit on the amount of space used by []syntax.Inst
-in the compiled form corresponding to a given regexp.
-
-Also set a 128 MB limit on the rune storage in the *syntax.Regexp
-tree itself.
-
-Thanks to Adam Korczynski (ADA Logics) and OSS-Fuzz for reporting this issue.
-
-Fixes CVE-2022-41715.
-Updates #55949.
-Fixes #55950.
-
-Change-Id: Ia656baed81564436368cf950e1c5409752f28e1b
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1592136
-TryBot-Result: Security TryBots <security-trybots@go-security-trybots.iam.gserviceaccount.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/438501
-Run-TryBot: Carlos Amedee <carlos@golang.org>
-Reviewed-by: Carlos Amedee <carlos@golang.org>
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Dmitri Shuralyov <dmitshur@golang.org>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/e9017c2416ad0ef642f5e0c2eab2dbf3cba4d997]
-CVE: CVE-2022-41715
-Signed-off-by: Hitendra Prajapati <hprajapati@mvista.com>
----
- src/regexp/syntax/parse.go      | 145 ++++++++++++++++++++++++++++++--
- src/regexp/syntax/parse_test.go |  13 +--
- 2 files changed, 148 insertions(+), 10 deletions(-)
-
-diff --git a/src/regexp/syntax/parse.go b/src/regexp/syntax/parse.go
-index d7cf2af..3792960 100644
---- a/src/regexp/syntax/parse.go
-+++ b/src/regexp/syntax/parse.go
-@@ -90,15 +90,49 @@ const (
- // until we've allocated at least maxHeight Regexp structures.
- const maxHeight = 1000
- 
-+// maxSize is the maximum size of a compiled regexp in Insts.
-+// It too is somewhat arbitrarily chosen, but the idea is to be large enough
-+// to allow significant regexps while at the same time small enough that
-+// the compiled form will not take up too much memory.
-+// 128 MB is enough for a 3.3 million Inst structures, which roughly
-+// corresponds to a 3.3 MB regexp.
-+const (
-+	maxSize  = 128 << 20 / instSize
-+	instSize = 5 * 8 // byte, 2 uint32, slice is 5 64-bit words
-+)
-+
-+// maxRunes is the maximum number of runes allowed in a regexp tree
-+// counting the runes in all the nodes.
-+// Ignoring character classes p.numRunes is always less than the length of the regexp.
-+// Character classes can make it much larger: each \pL adds 1292 runes.
-+// 128 MB is enough for 32M runes, which is over 26k \pL instances.
-+// Note that repetitions do not make copies of the rune slices,
-+// so \pL{1000} is only one rune slice, not 1000.
-+// We could keep a cache of character classes we've seen,
-+// so that all the \pL we see use the same rune list,
-+// but that doesn't remove the problem entirely:
-+// consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
-+// And because the Rune slice is exposed directly in the Regexp,
-+// there is not an opportunity to change the representation to allow
-+// partial sharing between different character classes.
-+// So the limit is the best we can do.
-+const (
-+	maxRunes = 128 << 20 / runeSize
-+	runeSize = 4 // rune is int32
-+)
-+
- type parser struct {
- 	flags       Flags     // parse mode flags
- 	stack       []*Regexp // stack of parsed expressions
- 	free        *Regexp
- 	numCap      int // number of capturing groups seen
- 	wholeRegexp string
--	tmpClass    []rune          // temporary char class work space
--	numRegexp   int             // number of regexps allocated
--	height      map[*Regexp]int // regexp height for height limit check
-+	tmpClass    []rune            // temporary char class work space
-+	numRegexp   int               // number of regexps allocated
-+	numRunes    int               // number of runes in char classes
-+	repeats     int64             // product of all repetitions seen
-+	height      map[*Regexp]int   // regexp height, for height limit check
-+	size        map[*Regexp]int64 // regexp compiled size, for size limit check
- }
- 
- func (p *parser) newRegexp(op Op) *Regexp {
-@@ -122,6 +156,104 @@ func (p *parser) reuse(re *Regexp) {
- 	p.free = re
- }
- 
-+func (p *parser) checkLimits(re *Regexp) {
-+	if p.numRunes > maxRunes {
-+		panic(ErrInternalError)
-+	}
-+	p.checkSize(re)
-+	p.checkHeight(re)
-+}
-+
-+func (p *parser) checkSize(re *Regexp) {
-+	if p.size == nil {
-+		// We haven't started tracking size yet.
-+		// Do a relatively cheap check to see if we need to start.
-+		// Maintain the product of all the repeats we've seen
-+		// and don't track if the total number of regexp nodes
-+		// we've seen times the repeat product is in budget.
-+		if p.repeats == 0 {
-+			p.repeats = 1
-+		}
-+		if re.Op == OpRepeat {
-+			n := re.Max
-+			if n == -1 {
-+				n = re.Min
-+			}
-+			if n <= 0 {
-+				n = 1
-+			}
-+			if int64(n) > maxSize/p.repeats {
-+				p.repeats = maxSize
-+			} else {
-+				p.repeats *= int64(n)
-+			}
-+		}
-+		if int64(p.numRegexp) < maxSize/p.repeats {
-+			return
-+		}
-+
-+		// We need to start tracking size.
-+		// Make the map and belatedly populate it
-+		// with info about everything we've constructed so far.
-+		p.size = make(map[*Regexp]int64)
-+		for _, re := range p.stack {
-+			p.checkSize(re)
-+		}
-+	}
-+
-+	if p.calcSize(re, true) > maxSize {
-+		panic(ErrInternalError)
-+	}
-+}
-+
-+func (p *parser) calcSize(re *Regexp, force bool) int64 {
-+	if !force {
-+		if size, ok := p.size[re]; ok {
-+			return size
-+		}
-+	}
-+
-+	var size int64
-+	switch re.Op {
-+	case OpLiteral:
-+		size = int64(len(re.Rune))
-+	case OpCapture, OpStar:
-+		// star can be 1+ or 2+; assume 2 pessimistically
-+		size = 2 + p.calcSize(re.Sub[0], false)
-+	case OpPlus, OpQuest:
-+		size = 1 + p.calcSize(re.Sub[0], false)
-+	case OpConcat:
-+		for _, sub := range re.Sub {
-+			size += p.calcSize(sub, false)
-+		}
-+	case OpAlternate:
-+		for _, sub := range re.Sub {
-+			size += p.calcSize(sub, false)
-+		}
-+		if len(re.Sub) > 1 {
-+			size += int64(len(re.Sub)) - 1
-+		}
-+	case OpRepeat:
-+		sub := p.calcSize(re.Sub[0], false)
-+		if re.Max == -1 {
-+			if re.Min == 0 {
-+				size = 2 + sub // x*
-+			} else {
-+				size = 1 + int64(re.Min)*sub // xxx+
-+			}
-+			break
-+		}
-+		// x{2,5} = xx(x(x(x)?)?)?
-+		size = int64(re.Max)*sub + int64(re.Max-re.Min)
-+	}
-+
-+	if size < 1 {
-+		size = 1
-+	}
-+	p.size[re] = size
-+	return size
-+}
-+
- func (p *parser) checkHeight(re *Regexp) {
- 	if p.numRegexp < maxHeight {
- 		return
-@@ -158,6 +290,7 @@ func (p *parser) calcHeight(re *Regexp, force bool) int {
- 
- // push pushes the regexp re onto the parse stack and returns the regexp.
- func (p *parser) push(re *Regexp) *Regexp {
-+	p.numRunes += len(re.Rune)
- 	if re.Op == OpCharClass && len(re.Rune) == 2 && re.Rune[0] == re.Rune[1] {
- 		// Single rune.
- 		if p.maybeConcat(re.Rune[0], p.flags&^FoldCase) {
-@@ -189,7 +322,7 @@ func (p *parser) push(re *Regexp) *Regexp {
- 	}
- 
- 	p.stack = append(p.stack, re)
--	p.checkHeight(re)
-+	p.checkLimits(re)
- 	return re
- }
- 
-@@ -299,7 +432,7 @@ func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (
- 	re.Sub = re.Sub0[:1]
- 	re.Sub[0] = sub
- 	p.stack[n-1] = re
--	p.checkHeight(re)
-+	p.checkLimits(re)
- 
- 	if op == OpRepeat && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000) {
- 		return "", &Error{ErrInvalidRepeatSize, before[:len(before)-len(after)]}
-@@ -503,6 +636,7 @@ func (p *parser) factor(sub []*Regexp) []*Regexp {
- 
- 			for j := start; j < i; j++ {
- 				sub[j] = p.removeLeadingString(sub[j], len(str))
-+				p.checkLimits(sub[j])
- 			}
- 			suffix := p.collapse(sub[start:i], OpAlternate) // recurse
- 
-@@ -560,6 +694,7 @@ func (p *parser) factor(sub []*Regexp) []*Regexp {
- 			for j := start; j < i; j++ {
- 				reuse := j != start // prefix came from sub[start]
- 				sub[j] = p.removeLeadingRegexp(sub[j], reuse)
-+				p.checkLimits(sub[j])
- 			}
- 			suffix := p.collapse(sub[start:i], OpAlternate) // recurse
- 
-diff --git a/src/regexp/syntax/parse_test.go b/src/regexp/syntax/parse_test.go
-index 1ef6d8a..67e3c56 100644
---- a/src/regexp/syntax/parse_test.go
-+++ b/src/regexp/syntax/parse_test.go
-@@ -484,12 +484,15 @@ var invalidRegexps = []string{
- 	`(?P<>a)`,
- 	`[a-Z]`,
- 	`(?i)[a-Z]`,
--	`a{100000}`,
--	`a{100000,}`,
--	"((((((((((x{2}){2}){2}){2}){2}){2}){2}){2}){2}){2})",
--	strings.Repeat("(", 1000) + strings.Repeat(")", 1000),
--	strings.Repeat("(?:", 1000) + strings.Repeat(")*", 1000),
- 	`\Q\E*`,
-+	`a{100000}`,  // too much repetition
-+	`a{100000,}`, // too much repetition
-+	"((((((((((x{2}){2}){2}){2}){2}){2}){2}){2}){2}){2})",    // too much repetition
-+	strings.Repeat("(", 1000) + strings.Repeat(")", 1000),    // too deep
-+	strings.Repeat("(?:", 1000) + strings.Repeat(")*", 1000), // too deep
-+	"(" + strings.Repeat("(xx?)", 1000) + "){1000}",          // too long
-+	strings.Repeat("(xx?){1000}", 1000),                      // too long
-+	strings.Repeat(`\pL`, 27000),                             // too many runes
- }
- 
- var onlyPerl = []string{
--- 
-2.25.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-41717.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-41717.patch
deleted file mode 100644
index e2ab92ed00..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-41717.patch
+++ /dev/null
@@ -1,89 +0,0 @@
-From 618120c165669c00a1606505defea6ca755cdc27 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Wed, 30 Nov 2022 16:46:33 -0500
-Subject: [PATCH] [release-branch.go1.19] net/http: update bundled
- golang.org/x/net/http2
-
-Disable cmd/internal/moddeps test, since this update includes PRIVATE
-track fixes.
-
-For #56350.
-For #57009.
-Fixes CVE-2022-41717.
-
-Change-Id: I5c6ce546add81f361dcf0d5123fa4eaaf8f0a03b
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1663835
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/455363
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Jenny Rakoczy <jenny@golang.org>
-Reviewed-by: Michael Pratt <mpratt@google.com>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/618120c165669c00a1606505defea6ca755cdc27]
-CVE: CVE-2022-41717
-Signed-off-by: Hitendra Prajapati <hprajapati@mvista.com>
----
- src/cmd/internal/moddeps/moddeps_test.go |  1 +
- src/net/http/h2_bundle.go                | 18 +++++++++++-------
- 2 files changed, 12 insertions(+), 7 deletions(-)
-
-diff --git a/src/cmd/internal/moddeps/moddeps_test.go b/src/cmd/internal/moddeps/moddeps_test.go
-index 3306e29..d48d43f 100644
---- a/src/cmd/internal/moddeps/moddeps_test.go
-+++ b/src/cmd/internal/moddeps/moddeps_test.go
-@@ -34,6 +34,7 @@ import (
- // See issues 36852, 41409, and 43687.
- // (Also see golang.org/issue/27348.)
- func TestAllDependencies(t *testing.T) {
-+	t.Skip("TODO(#57009): 1.19.4 contains unreleased changes from vendored modules")
- 	t.Skip("TODO(#53977): 1.18.5 contains unreleased changes from vendored modules")
- 
- 	goBin := testenv.GoToolPath(t)
-diff --git a/src/net/http/h2_bundle.go b/src/net/http/h2_bundle.go
-index 6e2ef30..9d6abd8 100644
---- a/src/net/http/h2_bundle.go
-+++ b/src/net/http/h2_bundle.go
-@@ -4189,6 +4189,7 @@ type http2serverConn struct {
- 	headerTableSize             uint32
- 	peerMaxHeaderListSize       uint32            // zero means unknown (default)
- 	canonHeader                 map[string]string // http2-lower-case -> Go-Canonical-Case
-+	canonHeaderKeysSize         int               // canonHeader keys size in bytes
- 	writingFrame                bool              // started writing a frame (on serve goroutine or separate)
- 	writingFrameAsync           bool              // started a frame on its own goroutine but haven't heard back on wroteFrameCh
- 	needsFrameFlush             bool              // last frame write wasn't a flush
-@@ -4368,6 +4369,13 @@ func (sc *http2serverConn) condlogf(err error, format string, args ...interface{
- 	}
- }
- 
-+// maxCachedCanonicalHeadersKeysSize is an arbitrarily-chosen limit on the size
-+// of the entries in the canonHeader cache.
-+// This should be larger than the size of unique, uncommon header keys likely to
-+// be sent by the peer, while not so high as to permit unreasonable memory usage
-+// if the peer sends an unbounded number of unique header keys.
-+const http2maxCachedCanonicalHeadersKeysSize = 2048
-+
- func (sc *http2serverConn) canonicalHeader(v string) string {
- 	sc.serveG.check()
- 	http2buildCommonHeaderMapsOnce()
-@@ -4383,14 +4391,10 @@ func (sc *http2serverConn) canonicalHeader(v string) string {
- 		sc.canonHeader = make(map[string]string)
- 	}
- 	cv = CanonicalHeaderKey(v)
--	// maxCachedCanonicalHeaders is an arbitrarily-chosen limit on the number of
--	// entries in the canonHeader cache. This should be larger than the number
--	// of unique, uncommon header keys likely to be sent by the peer, while not
--	// so high as to permit unreaasonable memory usage if the peer sends an unbounded
--	// number of unique header keys.
--	const maxCachedCanonicalHeaders = 32
--	if len(sc.canonHeader) < maxCachedCanonicalHeaders {
-+	size := 100 + len(v)*2 // 100 bytes of map overhead + key + value
-+	if sc.canonHeaderKeysSize+size <= http2maxCachedCanonicalHeadersKeysSize {
- 		sc.canonHeader[v] = cv
-+		sc.canonHeaderKeysSize += size
- 	}
- 	return cv
- }
--- 
-2.25.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-41720.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-41720.patch
deleted file mode 100644
index 6c2e8804b3..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-41720.patch
+++ /dev/null
@@ -1,514 +0,0 @@
-From f8896a97a0630b0f2f8c488310147f7f20b3ec7d Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Thu, 10 Nov 2022 12:16:27 -0800
-Subject: [PATCH] os, net/http: avoid escapes from os.DirFS and http.Dir on
- Windows
-
-Do not permit access to Windows reserved device names (NUL, COM1, etc.)
-via os.DirFS and http.Dir filesystems.
-
-Avoid escapes from os.DirFS(`\`) on Windows. DirFS would join the
-the root to the relative path with a path separator, making
-os.DirFS(`\`).Open(`/foo/bar`) open the path `\\foo\bar`, which is
-a UNC name. Not only does this not open the intended file, but permits
-reference to any file on the system rather than only files on the
-current drive.
-
-Make os.DirFS("") invalid, with all file access failing. Previously,
-a root of "" was interpreted as "/", which is surprising and probably
-unintentional.
-
-Fixes CVE-2022-41720.
-Fixes #56694.
-
-Change-Id: I275b5fa391e6ad7404309ea98ccc97405942e0f0
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1663832
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/455360
-Reviewed-by: Michael Pratt <mpratt@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Jenny Rakoczy <jenny@golang.org>
-
-CVE: CVE-2022-41720
-Upstream-Status: Backport [7013a4f5f816af62033ad63dd06b77c30d7a62a7]
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/go/build/deps_test.go                 |  1 +
- src/internal/safefilepath/path.go         | 21 +++++
- src/internal/safefilepath/path_other.go   | 23 ++++++
- src/internal/safefilepath/path_test.go    | 88 +++++++++++++++++++++
- src/internal/safefilepath/path_windows.go | 95 +++++++++++++++++++++++
- src/net/http/fs.go                        |  8 +-
- src/net/http/fs_test.go                   | 28 +++++++
- src/os/file.go                            | 36 +++++++--
- src/os/os_test.go                         | 38 +++++++++
- 9 files changed, 328 insertions(+), 10 deletions(-)
- create mode 100644 src/internal/safefilepath/path.go
- create mode 100644 src/internal/safefilepath/path_other.go
- create mode 100644 src/internal/safefilepath/path_test.go
- create mode 100644 src/internal/safefilepath/path_windows.go
-
-diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
-index 45e2f25..dc3bb8c 100644
---- a/src/go/build/deps_test.go
-+++ b/src/go/build/deps_test.go
-@@ -165,6 +165,7 @@ var depsRules = `
- 	io/fs
- 	< internal/testlog
- 	< internal/poll
-+	< internal/safefilepath
- 	< os
- 	< os/signal;
- 
-diff --git a/src/internal/safefilepath/path.go b/src/internal/safefilepath/path.go
-new file mode 100644
-index 0000000..0f0a270
---- /dev/null
-+++ b/src/internal/safefilepath/path.go
-@@ -0,0 +1,21 @@
-+// Copyright 2022 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+// Package safefilepath manipulates operating-system file paths.
-+package safefilepath
-+
-+import (
-+	"errors"
-+)
-+
-+var errInvalidPath = errors.New("invalid path")
-+
-+// FromFS converts a slash-separated path into an operating-system path.
-+//
-+// FromFS returns an error if the path cannot be represented by the operating
-+// system. For example, paths containing '\' and ':' characters are rejected
-+// on Windows.
-+func FromFS(path string) (string, error) {
-+	return fromFS(path)
-+}
-diff --git a/src/internal/safefilepath/path_other.go b/src/internal/safefilepath/path_other.go
-new file mode 100644
-index 0000000..f93da18
---- /dev/null
-+++ b/src/internal/safefilepath/path_other.go
-@@ -0,0 +1,23 @@
-+// Copyright 2022 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+//go:build !windows
-+
-+package safefilepath
-+
-+import "runtime"
-+
-+func fromFS(path string) (string, error) {
-+	if runtime.GOOS == "plan9" {
-+		if len(path) > 0 && path[0] == '#' {
-+			return path, errInvalidPath
-+		}
-+	}
-+	for i := range path {
-+		if path[i] == 0 {
-+			return "", errInvalidPath
-+		}
-+	}
-+	return path, nil
-+}
-diff --git a/src/internal/safefilepath/path_test.go b/src/internal/safefilepath/path_test.go
-new file mode 100644
-index 0000000..dc662c1
---- /dev/null
-+++ b/src/internal/safefilepath/path_test.go
-@@ -0,0 +1,88 @@
-+// Copyright 2022 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+package safefilepath_test
-+
-+import (
-+	"internal/safefilepath"
-+	"os"
-+	"path/filepath"
-+	"runtime"
-+	"testing"
-+)
-+
-+type PathTest struct {
-+	path, result string
-+}
-+
-+const invalid = ""
-+
-+var fspathtests = []PathTest{
-+	{".", "."},
-+	{"/a/b/c", "/a/b/c"},
-+	{"a\x00b", invalid},
-+}
-+
-+var winreservedpathtests = []PathTest{
-+	{`a\b`, `a\b`},
-+	{`a:b`, `a:b`},
-+	{`a/b:c`, `a/b:c`},
-+	{`NUL`, `NUL`},
-+	{`./com1`, `./com1`},
-+	{`a/nul/b`, `a/nul/b`},
-+}
-+
-+// Whether a reserved name with an extension is reserved or not varies by
-+// Windows version.
-+var winreservedextpathtests = []PathTest{
-+	{"nul.txt", "nul.txt"},
-+	{"a/nul.txt/b", "a/nul.txt/b"},
-+}
-+
-+var plan9reservedpathtests = []PathTest{
-+	{`#c`, `#c`},
-+}
-+
-+func TestFromFS(t *testing.T) {
-+	switch runtime.GOOS {
-+	case "windows":
-+		if canWriteFile(t, "NUL") {
-+			t.Errorf("can unexpectedly write a file named NUL on Windows")
-+		}
-+		if canWriteFile(t, "nul.txt") {
-+			fspathtests = append(fspathtests, winreservedextpathtests...)
-+		} else {
-+			winreservedpathtests = append(winreservedpathtests, winreservedextpathtests...)
-+		}
-+		for i := range winreservedpathtests {
-+			winreservedpathtests[i].result = invalid
-+		}
-+		for i := range fspathtests {
-+			fspathtests[i].result = filepath.FromSlash(fspathtests[i].result)
-+		}
-+	case "plan9":
-+		for i := range plan9reservedpathtests {
-+			plan9reservedpathtests[i].result = invalid
-+		}
-+	}
-+	tests := fspathtests
-+	tests = append(tests, winreservedpathtests...)
-+	tests = append(tests, plan9reservedpathtests...)
-+	for _, test := range tests {
-+		got, err := safefilepath.FromFS(test.path)
-+		if (got == "") != (err != nil) {
-+			t.Errorf(`FromFS(%q) = %q, %v; want "" only if err != nil`, test.path, got, err)
-+		}
-+		if got != test.result {
-+			t.Errorf("FromFS(%q) = %q, %v; want %q", test.path, got, err, test.result)
-+		}
-+	}
-+}
-+
-+func canWriteFile(t *testing.T, name string) bool {
-+	path := filepath.Join(t.TempDir(), name)
-+	os.WriteFile(path, []byte("ok"), 0666)
-+	b, _ := os.ReadFile(path)
-+	return string(b) == "ok"
-+}
-diff --git a/src/internal/safefilepath/path_windows.go b/src/internal/safefilepath/path_windows.go
-new file mode 100644
-index 0000000..909c150
---- /dev/null
-+++ b/src/internal/safefilepath/path_windows.go
-@@ -0,0 +1,95 @@
-+// Copyright 2022 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+package safefilepath
-+
-+import (
-+	"syscall"
-+	"unicode/utf8"
-+)
-+
-+func fromFS(path string) (string, error) {
-+	if !utf8.ValidString(path) {
-+		return "", errInvalidPath
-+	}
-+	for len(path) > 1 && path[0] == '/' && path[1] == '/' {
-+		path = path[1:]
-+	}
-+	containsSlash := false
-+	for p := path; p != ""; {
-+		// Find the next path element.
-+		i := 0
-+		dot := -1
-+		for i < len(p) && p[i] != '/' {
-+			switch p[i] {
-+			case 0, '\\', ':':
-+				return "", errInvalidPath
-+			case '.':
-+				if dot < 0 {
-+					dot = i
-+				}
-+			}
-+			i++
-+		}
-+		part := p[:i]
-+		if i < len(p) {
-+			containsSlash = true
-+			p = p[i+1:]
-+		} else {
-+			p = ""
-+		}
-+		// Trim the extension and look for a reserved name.
-+		base := part
-+		if dot >= 0 {
-+			base = part[:dot]
-+		}
-+		if isReservedName(base) {
-+			if dot < 0 {
-+				return "", errInvalidPath
-+			}
-+			// The path element is a reserved name with an extension.
-+			// Some Windows versions consider this a reserved name,
-+			// while others do not. Use FullPath to see if the name is
-+			// reserved.
-+			if p, _ := syscall.FullPath(part); len(p) >= 4 && p[:4] == `\\.\` {
-+				return "", errInvalidPath
-+			}
-+		}
-+	}
-+	if containsSlash {
-+		// We can't depend on strings, so substitute \ for / manually.
-+		buf := []byte(path)
-+		for i, b := range buf {
-+			if b == '/' {
-+				buf[i] = '\\'
-+			}
-+		}
-+		path = string(buf)
-+	}
-+	return path, nil
-+}
-+
-+// isReservedName reports if name is a Windows reserved device name.
-+// It does not detect names with an extension, which are also reserved on some Windows versions.
-+//
-+// For details, search for PRN in
-+// https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file.
-+func isReservedName(name string) bool {
-+	if 3 <= len(name) && len(name) <= 4 {
-+		switch string([]byte{toUpper(name[0]), toUpper(name[1]), toUpper(name[2])}) {
-+		case "CON", "PRN", "AUX", "NUL":
-+			return len(name) == 3
-+		case "COM", "LPT":
-+			return len(name) == 4 && '1' <= name[3] && name[3] <= '9'
-+		}
-+	}
-+	return false
-+}
-+
-+func toUpper(c byte) byte {
-+	if 'a' <= c && c <= 'z' {
-+		return c - ('a' - 'A')
-+	}
-+	return c
-+}
-diff --git a/src/net/http/fs.go b/src/net/http/fs.go
-index 57e731e..43ee4b5 100644
---- a/src/net/http/fs.go
-+++ b/src/net/http/fs.go
-@@ -9,6 +9,7 @@ package http
- import (
- 	"errors"
- 	"fmt"
-+	"internal/safefilepath"
- 	"io"
- 	"io/fs"
- 	"mime"
-@@ -69,14 +70,15 @@ func mapDirOpenError(originalErr error, name string) error {
- // Open implements FileSystem using os.Open, opening files for reading rooted
- // and relative to the directory d.
- func (d Dir) Open(name string) (File, error) {
--	if filepath.Separator != '/' && strings.ContainsRune(name, filepath.Separator) {
--		return nil, errors.New("http: invalid character in file path")
-+	path, err := safefilepath.FromFS(path.Clean("/" + name))
-+	if err != nil {
-+		return nil, errors.New("http: invalid or unsafe file path")
- 	}
- 	dir := string(d)
- 	if dir == "" {
- 		dir = "."
- 	}
--	fullName := filepath.Join(dir, filepath.FromSlash(path.Clean("/"+name)))
-+	fullName := filepath.Join(dir, path)
- 	f, err := os.Open(fullName)
- 	if err != nil {
- 		return nil, mapDirOpenError(err, fullName)
-diff --git a/src/net/http/fs_test.go b/src/net/http/fs_test.go
-index b42ade1..941448a 100644
---- a/src/net/http/fs_test.go
-+++ b/src/net/http/fs_test.go
-@@ -648,6 +648,34 @@ func TestFileServerZeroByte(t *testing.T) {
- 	}
- }
- 
-+func TestFileServerNamesEscape(t *testing.T) {
-+	t.Run("h1", func(t *testing.T) {
-+		testFileServerNamesEscape(t, h1Mode)
-+	})
-+	t.Run("h2", func(t *testing.T) {
-+		testFileServerNamesEscape(t, h2Mode)
-+	})
-+}
-+func testFileServerNamesEscape(t *testing.T, h2 bool) {
-+	defer afterTest(t)
-+	ts := newClientServerTest(t, h2, FileServer(Dir("testdata"))).ts
-+	defer ts.Close()
-+	for _, path := range []string{
-+		"/../testdata/file",
-+		"/NUL", // don't read from device files on Windows
-+	} {
-+		res, err := ts.Client().Get(ts.URL + path)
-+		if err != nil {
-+			t.Fatal(err)
-+		}
-+		res.Body.Close()
-+		if res.StatusCode < 400 || res.StatusCode > 599 {
-+			t.Errorf("Get(%q): got status %v, want 4xx or 5xx", path, res.StatusCode)
-+		}
-+
-+	}
-+}
-+
- type fakeFileInfo struct {
- 	dir      bool
- 	basename string
-diff --git a/src/os/file.go b/src/os/file.go
-index e717f17..cb87158 100644
---- a/src/os/file.go
-+++ b/src/os/file.go
-@@ -37,12 +37,12 @@
- // Note: The maximum number of concurrent operations on a File may be limited by
- // the OS or the system. The number should be high, but exceeding it may degrade
- // performance or cause other issues.
--//
- package os
- 
- import (
- 	"errors"
- 	"internal/poll"
-+	"internal/safefilepath"
- 	"internal/testlog"
- 	"internal/unsafeheader"
- 	"io"
-@@ -623,6 +623,8 @@ func isWindowsNulName(name string) bool {
- // the /prefix tree, then using DirFS does not stop the access any more than using
- // os.Open does. DirFS is therefore not a general substitute for a chroot-style security
- // mechanism when the directory tree contains arbitrary content.
-+//
-+// The directory dir must not be "".
- func DirFS(dir string) fs.FS {
- 	return dirFS(dir)
- }
-@@ -641,10 +643,11 @@ func containsAny(s, chars string) bool {
- type dirFS string
- 
- func (dir dirFS) Open(name string) (fs.File, error) {
--	if !fs.ValidPath(name) || runtime.GOOS == "windows" && containsAny(name, `\:`) {
--		return nil, &PathError{Op: "open", Path: name, Err: ErrInvalid}
-+	fullname, err := dir.join(name)
-+	if err != nil {
-+		return nil, &PathError{Op: "stat", Path: name, Err: err}
- 	}
--	f, err := Open(string(dir) + "/" + name)
-+	f, err := Open(fullname)
- 	if err != nil {
- 		return nil, err // nil fs.File
- 	}
-@@ -652,16 +655,35 @@ func (dir dirFS) Open(name string) (fs.File, error) {
- }
- 
- func (dir dirFS) Stat(name string) (fs.FileInfo, error) {
--	if !fs.ValidPath(name) || runtime.GOOS == "windows" && containsAny(name, `\:`) {
--		return nil, &PathError{Op: "stat", Path: name, Err: ErrInvalid}
-+	fullname, err := dir.join(name)
-+	if err != nil {
-+		return nil, &PathError{Op: "stat", Path: name, Err: err}
- 	}
--	f, err := Stat(string(dir) + "/" + name)
-+	f, err := Stat(fullname)
- 	if err != nil {
- 		return nil, err
- 	}
- 	return f, nil
- }
- 
-+// join returns the path for name in dir.
-+func (dir dirFS) join(name string) (string, error) {
-+	if dir == "" {
-+		return "", errors.New("os: DirFS with empty root")
-+	}
-+	if !fs.ValidPath(name) {
-+		return "", ErrInvalid
-+	}
-+	name, err := safefilepath.FromFS(name)
-+	if err != nil {
-+		return "", ErrInvalid
-+	}
-+	if IsPathSeparator(dir[len(dir)-1]) {
-+		return string(dir) + name, nil
-+	}
-+	return string(dir) + string(PathSeparator) + name, nil
-+}
-+
- // ReadFile reads the named file and returns the contents.
- // A successful call returns err == nil, not err == EOF.
- // Because ReadFile reads the whole file, it does not treat an EOF from Read
-diff --git a/src/os/os_test.go b/src/os/os_test.go
-index 506f1fb..be269bb 100644
---- a/src/os/os_test.go
-+++ b/src/os/os_test.go
-@@ -2702,6 +2702,44 @@ func TestDirFS(t *testing.T) {
- 	if err == nil {
- 		t.Fatalf(`Open testdata\dirfs succeeded`)
- 	}
-+
-+	// Test that Open does not open Windows device files.
-+	_, err = d.Open(`NUL`)
-+	if err == nil {
-+		t.Errorf(`Open NUL succeeded`)
-+	}
-+}
-+
-+func TestDirFSRootDir(t *testing.T) {
-+	cwd, err := os.Getwd()
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	cwd = cwd[len(filepath.VolumeName(cwd)):] // trim volume prefix (C:) on Windows
-+	cwd = filepath.ToSlash(cwd)               // convert \ to /
-+	cwd = strings.TrimPrefix(cwd, "/")        // trim leading /
-+
-+	// Test that Open can open a path starting at /.
-+	d := DirFS("/")
-+	f, err := d.Open(cwd + "/testdata/dirfs/a")
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	f.Close()
-+}
-+
-+func TestDirFSEmptyDir(t *testing.T) {
-+	d := DirFS("")
-+	cwd, _ := os.Getwd()
-+	for _, path := range []string{
-+		"testdata/dirfs/a",                          // not DirFS(".")
-+		filepath.ToSlash(cwd) + "/testdata/dirfs/a", // not DirFS("/")
-+	} {
-+		_, err := d.Open(path)
-+		if err == nil {
-+			t.Fatalf(`DirFS("").Open(%q) succeeded`, path)
-+		}
-+	}
- }
- 
- func TestDirFSPathsValid(t *testing.T) {
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-41722.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-41722.patch
deleted file mode 100644
index 426a4f925f..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-41722.patch
+++ /dev/null
@@ -1,103 +0,0 @@
-From a826b19625caebed6dd0f3fbd9d0111f6c83737c Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Mon, 12 Dec 2022 16:43:37 -0800
-Subject: [PATCH] path/filepath: do not Clean("a/../c:/b") into c:\b on Windows
-
-Do not permit Clean to convert a relative path into one starting
-with a drive reference. This change causes Clean to insert a .
-path element at the start of a path when the original path does not
-start with a volume name, and the first path element would contain
-a colon.
-
-This may introduce a spurious but harmless . path element under
-some circumstances. For example, Clean("a/../b:/../c") becomes `.\c`.
-
-This reverts CL 401595, since the change here supersedes the one
-in that CL.
-
-Thanks to RyotaK (https://twitter.com/ryotkak) for reporting this issue.
-
-Updates #57274
-Fixes #57276
-Fixes CVE-2022-41722
-
-Change-Id: I837446285a03aa74c79d7642720e01f354c2ca17
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1675249
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-TryBot-Result: Security TryBots <security-trybots@go-security-trybots.iam.gserviceaccount.com>
-(cherry picked from commit 8ca37f4813ef2f64600c92b83f17c9f3ca6c03a5)
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1728944
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/468119
-Reviewed-by: Than McIntosh <thanm@google.com>
-Run-TryBot: Michael Pratt <mpratt@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Auto-Submit: Michael Pratt <mpratt@google.com>
-
-CVE: CVE-2022-41722
-Upstream-Status: Backport from https://github.com/golang/go/commit/bdf07c2e168baf736e4c057279ca12a4d674f18
-Signed-off-by: Shubham Kulkarni <skulkarni@mvista.com>
----
- src/path/filepath/path.go | 27 ++++++++++++++-------------
- 1 file changed, 14 insertions(+), 13 deletions(-)
-
-diff --git a/src/path/filepath/path.go b/src/path/filepath/path.go
-index 8300a32..94621a0 100644
---- a/src/path/filepath/path.go
-+++ b/src/path/filepath/path.go
-@@ -15,6 +15,7 @@ import (
-	"errors"
-	"io/fs"
-	"os"
-+	"runtime"
-	"sort"
-	"strings"
- )
-@@ -117,21 +118,9 @@ func Clean(path string) string {
-		case os.IsPathSeparator(path[r]):
-			// empty path element
-			r++
--		case path[r] == '.' && r+1 == n:
-+		case path[r] == '.' && (r+1 == n || os.IsPathSeparator(path[r+1])):
-			// . element
-			r++
--		case path[r] == '.' && os.IsPathSeparator(path[r+1]):
--			// ./ element
--			r++
--
--			for r < len(path) && os.IsPathSeparator(path[r]) {
--				r++
--			}
--			if out.w == 0 && volumeNameLen(path[r:]) > 0 {
--				// When joining prefix "." and an absolute path on Windows,
--				// the prefix should not be removed.
--				out.append('.')
--			}
-		case path[r] == '.' && path[r+1] == '.' && (r+2 == n || os.IsPathSeparator(path[r+2])):
-			// .. element: remove to last separator
-			r += 2
-@@ -157,6 +146,18 @@ func Clean(path string) string {
-			if rooted && out.w != 1 || !rooted && out.w != 0 {
-				out.append(Separator)
-			}
-+			// If a ':' appears in the path element at the start of a Windows path,
-+			// insert a .\ at the beginning to avoid converting relative paths
-+			// like a/../c: into c:.
-+			if runtime.GOOS == "windows" && out.w == 0 && out.volLen == 0 && r != 0 {
-+				for i := r; i < n && !os.IsPathSeparator(path[i]); i++ {
-+					if path[i] == ':' {
-+						out.append('.')
-+						out.append(Separator)
-+						break
-+					}
-+				}
-+			}
-			// copy element
-			for ; r < n && !os.IsPathSeparator(path[r]); r++ {
-				out.append(path[r])
---
-2.7.4
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2022-41723.patch b/meta/recipes-devtools/go/go-1.18/CVE-2022-41723.patch
deleted file mode 100644
index a93fa31dcd..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2022-41723.patch
+++ /dev/null
@@ -1,156 +0,0 @@
-From 451766789f646617157c725e20c955d4a9a70d4e Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Mon, 6 Feb 2023 10:03:44 -0800
-Subject: [PATCH] net/http: update bundled golang.org/x/net/http2
-
-Disable cmd/internal/moddeps test, since this update includes PRIVATE
-track fixes.
-
-Fixes CVE-2022-41723
-Fixes #58355
-Updates #57855
-
-Change-Id: Ie870562a6f6e44e4e8f57db6a0dde1a41a2b090c
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1728939
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/468118
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Michael Pratt <mpratt@google.com>
-Auto-Submit: Michael Pratt <mpratt@google.com>
-Reviewed-by: Than McIntosh <thanm@google.com>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/5c3e11bd0b5c0a86e5beffcd4339b86a902b21c3]
-CVE: CVE-2022-41723
-Signed-off-by: Shubham Kulkarni <skulkarni@mvista.com>
----
- src/vendor/golang.org/x/net/http2/hpack/hpack.go | 79 +++++++++++++++---------
- 1 file changed, 49 insertions(+), 30 deletions(-)
-
-diff --git a/src/vendor/golang.org/x/net/http2/hpack/hpack.go b/src/vendor/golang.org/x/net/http2/hpack/hpack.go
-index 85f18a2..02e80e3 100644
---- a/src/vendor/golang.org/x/net/http2/hpack/hpack.go
-+++ b/src/vendor/golang.org/x/net/http2/hpack/hpack.go
-@@ -359,6 +359,7 @@ func (d *Decoder) parseFieldLiteral(n uint8, it indexType) error {
-
-	var hf HeaderField
-	wantStr := d.emitEnabled || it.indexed()
-+	var undecodedName undecodedString
-	if nameIdx > 0 {
-		ihf, ok := d.at(nameIdx)
-		if !ok {
-@@ -366,15 +367,27 @@ func (d *Decoder) parseFieldLiteral(n uint8, it indexType) error {
-		}
-		hf.Name = ihf.Name
-	} else {
--		hf.Name, buf, err = d.readString(buf, wantStr)
-+		undecodedName, buf, err = d.readString(buf)
-		if err != nil {
-			return err
-		}
-	}
--	hf.Value, buf, err = d.readString(buf, wantStr)
-+	undecodedValue, buf, err := d.readString(buf)
-	if err != nil {
-		return err
-	}
-+	if wantStr {
-+		if nameIdx <= 0 {
-+			hf.Name, err = d.decodeString(undecodedName)
-+			if err != nil {
-+				return err
-+			}
-+		}
-+		hf.Value, err = d.decodeString(undecodedValue)
-+		if err != nil {
-+			return err
-+		}
-+	}
-	d.buf = buf
-	if it.indexed() {
-		d.dynTab.add(hf)
-@@ -459,46 +472,52 @@ func readVarInt(n byte, p []byte) (i uint64, remain []byte, err error) {
-	return 0, origP, errNeedMore
- }
-
--// readString decodes an hpack string from p.
-+// readString reads an hpack string from p.
- //
--// wantStr is whether s will be used. If false, decompression and
--// []byte->string garbage are skipped if s will be ignored
--// anyway. This does mean that huffman decoding errors for non-indexed
--// strings past the MAX_HEADER_LIST_SIZE are ignored, but the server
--// is returning an error anyway, and because they're not indexed, the error
--// won't affect the decoding state.
--func (d *Decoder) readString(p []byte, wantStr bool) (s string, remain []byte, err error) {
-+// It returns a reference to the encoded string data to permit deferring decode costs
-+// until after the caller verifies all data is present.
-+func (d *Decoder) readString(p []byte) (u undecodedString, remain []byte, err error) {
-	if len(p) == 0 {
--		return "", p, errNeedMore
-+		return u, p, errNeedMore
-	}
-	isHuff := p[0]&128 != 0
-	strLen, p, err := readVarInt(7, p)
-	if err != nil {
--		return "", p, err
-+		return u, p, err
-	}
-	if d.maxStrLen != 0 && strLen > uint64(d.maxStrLen) {
--		return "", nil, ErrStringLength
-+		// Returning an error here means Huffman decoding errors
-+		// for non-indexed strings past the maximum string length
-+		// are ignored, but the server is returning an error anyway
-+		// and because the string is not indexed the error will not
-+		// affect the decoding state.
-+		return u, nil, ErrStringLength
-	}
-	if uint64(len(p)) < strLen {
--		return "", p, errNeedMore
--	}
--	if !isHuff {
--		if wantStr {
--			s = string(p[:strLen])
--		}
--		return s, p[strLen:], nil
-+		return u, p, errNeedMore
-	}
-+	u.isHuff = isHuff
-+	u.b = p[:strLen]
-+	return u, p[strLen:], nil
-+}
-
--	if wantStr {
--		buf := bufPool.Get().(*bytes.Buffer)
--		buf.Reset() // don't trust others
--		defer bufPool.Put(buf)
--		if err := huffmanDecode(buf, d.maxStrLen, p[:strLen]); err != nil {
--			buf.Reset()
--			return "", nil, err
--		}
-+type undecodedString struct {
-+	isHuff bool
-+	b      []byte
-+}
-+
-+func (d *Decoder) decodeString(u undecodedString) (string, error) {
-+	if !u.isHuff {
-+		return string(u.b), nil
-+	}
-+	buf := bufPool.Get().(*bytes.Buffer)
-+	buf.Reset() // don't trust others
-+	var s string
-+	err := huffmanDecode(buf, d.maxStrLen, u.b)
-+	if err == nil {
-		s = buf.String()
--		buf.Reset() // be nice to GC
-	}
--	return s, p[strLen:], nil
-+	buf.Reset() // be nice to GC
-+	bufPool.Put(buf)
-+	return s, err
- }
---
-2.7.4
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-24534.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-24534.patch
deleted file mode 100644
index c65c7852d5..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-24534.patch
+++ /dev/null
@@ -1,200 +0,0 @@
-From d6759e7a059f4208f07aa781402841d7ddaaef96 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Fri, 10 Mar 2023 14:21:05 -0800
-Subject: [PATCH] [release-branch.go1.19] net/textproto: avoid overpredicting
- the number of MIME header keys
- 
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802452
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-(cherry picked from commit f739f080a72fd5b06d35c8e244165159645e2ed6)
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802393
-Reviewed-by: Damien Neil <dneil@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Change-Id: I675451438d619a9130360c56daf529559004903f
-Reviewed-on: https://go-review.googlesource.com/c/go/+/481982
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-Auto-Submit: Michael Knyszek <mknyszek@google.com>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/d6759e7a059f4208f07aa781402841d7ddaaef96]
-CVE: CVE-2023-24534
-Signed-off-by: Vivek Kumbhar <vkumbhar@mvista.com>
-
----
- src/bytes/bytes.go               | 14 ++++++++
- src/net/textproto/reader.go      | 30 ++++++++++------
- src/net/textproto/reader_test.go | 59 ++++++++++++++++++++++++++++++++
- 3 files changed, 92 insertions(+), 11 deletions(-)
-
-diff --git a/src/bytes/bytes.go b/src/bytes/bytes.go
-index ce52649..95ff31c 100644
---- a/src/bytes/bytes.go
-+++ b/src/bytes/bytes.go
-@@ -1174,3 +1174,17 @@ func Index(s, sep []byte) int {
- 	}
- 	return -1
- }
-+
-+// Cut slices s around the first instance of sep,
-+// returning the text before and after sep.
-+// The found result reports whether sep appears in s.
-+// If sep does not appear in s, cut returns s, nil, false.
-+//
-+// Cut returns slices of the original slice s, not copies.
-+func Cut(s, sep []byte) (before, after []byte, found bool) {
-+	if i := Index(s, sep); i >= 0 {
-+		return s[:i], s[i+len(sep):], true
-+	}
-+	return s, nil, false
-+}
-+
-diff --git a/src/net/textproto/reader.go b/src/net/textproto/reader.go
-index 6a680f4..fcbede8 100644
---- a/src/net/textproto/reader.go
-+++ b/src/net/textproto/reader.go
-@@ -493,8 +493,11 @@ func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 	// large one ahead of time which we'll cut up into smaller
- 	// slices. If this isn't big enough later, we allocate small ones.
- 	var strs []string
--	hint := r.upcomingHeaderNewlines()
-+	hint := r.upcomingHeaderKeys()
- 	if hint > 0 {
-+		if hint > 1000 {
-+			hint = 1000 // set a cap to avoid overallocation
-+		}
- 		strs = make([]string, hint)
- 	}
- 
-@@ -589,9 +592,11 @@ func mustHaveFieldNameColon(line []byte) error {
- 	return nil
- }
- 
--// upcomingHeaderNewlines returns an approximation of the number of newlines
-+var nl = []byte("\n")
-+
-+// upcomingHeaderKeys returns an approximation of the number of keys
- // that will be in this header. If it gets confused, it returns 0.
--func (r *Reader) upcomingHeaderNewlines() (n int) {
-+func (r *Reader) upcomingHeaderKeys() (n int) {
- 	// Try to determine the 'hint' size.
- 	r.R.Peek(1) // force a buffer load if empty
- 	s := r.R.Buffered()
-@@ -599,17 +604,20 @@ func (r *Reader) upcomingHeaderNewlines() (n int) {
- 		return
- 	}
- 	peek, _ := r.R.Peek(s)
--	for len(peek) > 0 {
--		i := bytes.IndexByte(peek, '\n')
--		if i < 3 {
--			// Not present (-1) or found within the next few bytes,
--			// implying we're at the end ("\r\n\r\n" or "\n\n")
--			return
-+	for len(peek) > 0 && n < 1000 {
-+		var line []byte
-+		line, peek, _ = bytes.Cut(peek, nl)
-+		if len(line) == 0 || (len(line) == 1 && line[0] == '\r') {
-+			// Blank line separating headers from the body.
-+			break
-+		}
-+		if line[0] == ' ' || line[0] == '\t' {
-+			// Folded continuation of the previous line.
-+			continue
- 		}
- 		n++
--		peek = peek[i+1:]
- 	}
--	return
-+	return n
- }
- 
- // CanonicalMIMEHeaderKey returns the canonical format of the
-diff --git a/src/net/textproto/reader_test.go b/src/net/textproto/reader_test.go
-index 3124d43..3ae0de1 100644
---- a/src/net/textproto/reader_test.go
-+++ b/src/net/textproto/reader_test.go
-@@ -9,6 +9,7 @@ import (
- 	"bytes"
- 	"io"
- 	"reflect"
-+	"runtime"
- 	"strings"
- 	"testing"
- )
-@@ -127,6 +128,42 @@ func TestReadMIMEHeaderSingle(t *testing.T) {
- 	}
- }
- 
-+// TestReaderUpcomingHeaderKeys is testing an internal function, but it's very
-+// difficult to test well via the external API.
-+func TestReaderUpcomingHeaderKeys(t *testing.T) {
-+	for _, test := range []struct {
-+		input string
-+		want  int
-+	}{{
-+		input: "",
-+		want:  0,
-+	}, {
-+		input: "A: v",
-+		want:  1,
-+	}, {
-+		input: "A: v\r\nB: v\r\n",
-+		want:  2,
-+	}, {
-+		input: "A: v\nB: v\n",
-+		want:  2,
-+	}, {
-+		input: "A: v\r\n  continued\r\n  still continued\r\nB: v\r\n\r\n",
-+		want:  2,
-+	}, {
-+		input: "A: v\r\n\r\nB: v\r\nC: v\r\n",
-+		want:  1,
-+	}, {
-+		input: "A: v" + strings.Repeat("\n", 1000),
-+		want:  1,
-+	}} {
-+		r := reader(test.input)
-+		got := r.upcomingHeaderKeys()
-+		if test.want != got {
-+			t.Fatalf("upcomingHeaderKeys(%q): %v; want %v", test.input, got, test.want)
-+		}
-+	}
-+}
-+
- func TestReadMIMEHeaderNoKey(t *testing.T) {
- 	r := reader(": bar\ntest-1: 1\n\n")
- 	m, err := r.ReadMIMEHeader()
-@@ -223,6 +260,28 @@ func TestReadMIMEHeaderTrimContinued(t *testing.T) {
- 	}
- }
- 
-+// Test that reading a header doesn't overallocate. Issue 58975.
-+func TestReadMIMEHeaderAllocations(t *testing.T) {
-+	var totalAlloc uint64
-+	const count = 200
-+	for i := 0; i < count; i++ {
-+		r := reader("A: b\r\n\r\n" + strings.Repeat("\n", 4096))
-+		var m1, m2 runtime.MemStats
-+		runtime.ReadMemStats(&m1)
-+		_, err := r.ReadMIMEHeader()
-+		if err != nil {
-+			t.Fatalf("ReadMIMEHeader: %v", err)
-+		}
-+		runtime.ReadMemStats(&m2)
-+		totalAlloc += m2.TotalAlloc - m1.TotalAlloc
-+	}
-+	// 32k is large and we actually allocate substantially less,
-+	// but prior to the fix for #58975 we allocated ~400k in this case.
-+	if got, want := totalAlloc/count, uint64(32768); got > want {
-+		t.Fatalf("ReadMIMEHeader allocated %v bytes, want < %v", got, want)
-+	}
-+}
-+
- type readResponseTest struct {
- 	in       string
- 	inCode   int
--- 
-2.25.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-24537.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-24537.patch
deleted file mode 100644
index 4521f159ea..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-24537.patch
+++ /dev/null
@@ -1,75 +0,0 @@
-From bf8c7c575c8a552d9d79deb29e80854dc88528d0 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Mon, 20 Mar 2023 10:43:19 -0700
-Subject: [PATCH] [release-branch.go1.20] mime/multipart: limit parsed mime
- message sizes
-
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802456
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802611
-Reviewed-by: Damien Neil <dneil@google.com>
-Change-Id: Ifdfa192d54f722d781a4d8c5f35b5fb72d122168
-Reviewed-on: https://go-review.googlesource.com/c/go/+/481986
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-Auto-Submit: Michael Knyszek <mknyszek@google.com>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/126a1d02da82f93ede7ce0bd8d3c51ef627f2104]
-CVE: CVE-2023-24537
-Signed-off-by: Vivek Kumbhar <vkumbhar@mvista.com>
----
- src/go/parser/parser_test.go | 16 ++++++++++++++++
- src/go/scanner/scanner.go    |  5 ++++-
- 2 files changed, 20 insertions(+), 1 deletion(-)
-
-diff --git a/src/go/parser/parser_test.go b/src/go/parser/parser_test.go
-index 1a46c87..993df63 100644
---- a/src/go/parser/parser_test.go
-+++ b/src/go/parser/parser_test.go
-@@ -746,3 +746,19 @@ func TestScopeDepthLimit(t *testing.T) {
-		}
-	}
- }
-+
-+// TestIssue59180 tests that line number overflow doesn't cause an infinite loop.
-+func TestIssue59180(t *testing.T) {
-+	testcases := []string{
-+		"package p\n//line :9223372036854775806\n\n//",
-+		"package p\n//line :1:9223372036854775806\n\n//",
-+		"package p\n//line file:9223372036854775806\n\n//",
-+	}
-+
-+	for _, src := range testcases {
-+		_, err := ParseFile(token.NewFileSet(), "", src, ParseComments)
-+		if err == nil {
-+			t.Errorf("ParseFile(%s) succeeded unexpectedly", src)
-+		}
-+	}
-+}
-diff --git a/src/go/scanner/scanner.go b/src/go/scanner/scanner.go
-index f08e28c..ff847b5 100644
---- a/src/go/scanner/scanner.go
-+++ b/src/go/scanner/scanner.go
-@@ -251,13 +251,16 @@ func (s *Scanner) updateLineInfo(next, offs int, text []byte) {
-		return
-	}
-
-+	// Put a cap on the maximum size of line and column numbers.
-+	// 30 bits allows for some additional space before wrapping an int32.
-+	const maxLineCol = 1<<30 - 1
-	var line, col int
-	i2, n2, ok2 := trailingDigits(text[:i-1])
-	if ok2 {
-		//line filename:line:col
-		i, i2 = i2, i
-		line, col = n2, n
--		if col == 0 {
-+		if col == 0 || col > maxLineCol {
-			s.error(offs+i2, "invalid column number: "+string(text[i2:]))
-			return
-		}
---
-2.25.1
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-24538_1.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-24538_1.patch
deleted file mode 100644
index bb0a416f46..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-24538_1.patch
+++ /dev/null
@@ -1,597 +0,0 @@
-From b1e4e8ec7e946ff2d3bb37ac99c5468ceb49c362 Mon Sep 17 00:00:00 2001
-From: Russ Cox <rsc@golang.org>
-Date: Thu, 20 May 2021 12:46:33 -0400
-Subject: [PATCH 1/2] html/template, text/template: implement break and
- continue for range loops
-
-Break and continue for range loops was accepted as a proposal in June 2017.
-It was implemented in CL 66410 (Oct 2017)
-but then rolled back in CL 92155 (Feb 2018)
-because html/template changes had not been implemented.
-
-This CL reimplements break and continue in text/template
-and then adds support for them in html/template as well.
-
-Fixes #20531.
-
-Change-Id: I05330482a976f1c078b4b49c2287bd9031bb7616
-Reviewed-on: https://go-review.googlesource.com/c/go/+/321491
-Trust: Russ Cox <rsc@golang.org>
-Run-TryBot: Russ Cox <rsc@golang.org>
-TryBot-Result: Go Bot <gobot@golang.org>
-Reviewed-by: Rob Pike <r@golang.org>
-
-Upstream-Status: Backport from https://github.com/golang/go/commit/d0dd26a88c019d54f22463daae81e785f5867565
-CVE: CVE-2023-24538
-Signed-off-by: Shubham Kulkarni <skulkarni@mvista.com>
----
- src/html/template/context.go          |  4 ++
- src/html/template/escape.go           | 71 ++++++++++++++++++++++++++++++++++-
- src/html/template/escape_test.go      | 24 ++++++++++++
- src/html/template/exec_test.go        |  2 +
- src/text/template/doc.go              |  8 ++++
- src/text/template/exec.go             | 24 +++++++++++-
- src/text/template/exec_test.go        |  2 +
- src/text/template/parse/lex.go        | 13 ++++++-
- src/text/template/parse/lex_test.go   |  2 +
- src/text/template/parse/node.go       | 36 ++++++++++++++++++
- src/text/template/parse/parse.go      | 42 ++++++++++++++++++++-
- src/text/template/parse/parse_test.go |  8 ++++
- 12 files changed, 232 insertions(+), 4 deletions(-)
-
-diff --git a/src/html/template/context.go b/src/html/template/context.go
-index f7d4849..aaa7d08 100644
---- a/src/html/template/context.go
-+++ b/src/html/template/context.go
-@@ -6,6 +6,7 @@ package template
-
- import (
-	"fmt"
-+	"text/template/parse"
- )
-
- // context describes the state an HTML parser must be in when it reaches the
-@@ -22,6 +23,7 @@ type context struct {
-	jsCtx   jsCtx
-	attr    attr
-	element element
-+	n       parse.Node // for range break/continue
-	err     *Error
- }
-
-@@ -141,6 +143,8 @@ const (
-	// stateError is an infectious error state outside any valid
-	// HTML/CSS/JS construct.
-	stateError
-+	// stateDead marks unreachable code after a {{break}} or {{continue}}.
-+	stateDead
- )
-
- // isComment is true for any state that contains content meant for template
-diff --git a/src/html/template/escape.go b/src/html/template/escape.go
-index 8739735..6dea79c 100644
---- a/src/html/template/escape.go
-+++ b/src/html/template/escape.go
-@@ -97,6 +97,15 @@ type escaper struct {
-	actionNodeEdits   map[*parse.ActionNode][]string
-	templateNodeEdits map[*parse.TemplateNode]string
-	textNodeEdits     map[*parse.TextNode][]byte
-+	// rangeContext holds context about the current range loop.
-+	rangeContext *rangeContext
-+}
-+
-+// rangeContext holds information about the current range loop.
-+type rangeContext struct {
-+	outer     *rangeContext // outer loop
-+	breaks    []context     // context at each break action
-+	continues []context     // context at each continue action
- }
-
- // makeEscaper creates a blank escaper for the given set.
-@@ -109,6 +118,7 @@ func makeEscaper(n *nameSpace) escaper {
-		map[*parse.ActionNode][]string{},
-		map[*parse.TemplateNode]string{},
-		map[*parse.TextNode][]byte{},
-+		nil,
-	}
- }
-
-@@ -124,8 +134,16 @@ func (e *escaper) escape(c context, n parse.Node) context {
-	switch n := n.(type) {
-	case *parse.ActionNode:
-		return e.escapeAction(c, n)
-+	case *parse.BreakNode:
-+		c.n = n
-+		e.rangeContext.breaks = append(e.rangeContext.breaks, c)
-+		return context{state: stateDead}
-	case *parse.CommentNode:
-		return c
-+	case *parse.ContinueNode:
-+		c.n = n
-+		e.rangeContext.continues = append(e.rangeContext.breaks, c)
-+		return context{state: stateDead}
-	case *parse.IfNode:
-		return e.escapeBranch(c, &n.BranchNode, "if")
-	case *parse.ListNode:
-@@ -427,6 +445,12 @@ func join(a, b context, node parse.Node, nodeName string) context {
-	if b.state == stateError {
-		return b
-	}
-+	if a.state == stateDead {
-+		return b
-+	}
-+	if b.state == stateDead {
-+		return a
-+	}
-	if a.eq(b) {
-		return a
-	}
-@@ -466,14 +490,27 @@ func join(a, b context, node parse.Node, nodeName string) context {
-
- // escapeBranch escapes a branch template node: "if", "range" and "with".
- func (e *escaper) escapeBranch(c context, n *parse.BranchNode, nodeName string) context {
-+	if nodeName == "range" {
-+		e.rangeContext = &rangeContext{outer: e.rangeContext}
-+	}
-	c0 := e.escapeList(c, n.List)
--	if nodeName == "range" && c0.state != stateError {
-+	if nodeName == "range" {
-+		if c0.state != stateError {
-+			c0 = joinRange(c0, e.rangeContext)
-+		}
-+		e.rangeContext = e.rangeContext.outer
-+		if c0.state == stateError {
-+			return c0
-+		}
-+
-		// The "true" branch of a "range" node can execute multiple times.
-		// We check that executing n.List once results in the same context
-		// as executing n.List twice.
-+		e.rangeContext = &rangeContext{outer: e.rangeContext}
-		c1, _ := e.escapeListConditionally(c0, n.List, nil)
-		c0 = join(c0, c1, n, nodeName)
-		if c0.state == stateError {
-+			e.rangeContext = e.rangeContext.outer
-			// Make clear that this is a problem on loop re-entry
-			// since developers tend to overlook that branch when
-			// debugging templates.
-@@ -481,11 +518,39 @@ func (e *escaper) escapeBranch(c context, n *parse.BranchNode, nodeName string)
-			c0.err.Description = "on range loop re-entry: " + c0.err.Description
-			return c0
-		}
-+		c0 = joinRange(c0, e.rangeContext)
-+		e.rangeContext = e.rangeContext.outer
-+		if c0.state == stateError {
-+			return c0
-+		}
-	}
-	c1 := e.escapeList(c, n.ElseList)
-	return join(c0, c1, n, nodeName)
- }
-
-+func joinRange(c0 context, rc *rangeContext) context {
-+	// Merge contexts at break and continue statements into overall body context.
-+	// In theory we could treat breaks differently from continues, but for now it is
-+	// enough to treat them both as going back to the start of the loop (which may then stop).
-+	for _, c := range rc.breaks {
-+		c0 = join(c0, c, c.n, "range")
-+		if c0.state == stateError {
-+			c0.err.Line = c.n.(*parse.BreakNode).Line
-+			c0.err.Description = "at range loop break: " + c0.err.Description
-+			return c0
-+		}
-+	}
-+	for _, c := range rc.continues {
-+		c0 = join(c0, c, c.n, "range")
-+		if c0.state == stateError {
-+			c0.err.Line = c.n.(*parse.ContinueNode).Line
-+			c0.err.Description = "at range loop continue: " + c0.err.Description
-+			return c0
-+		}
-+	}
-+	return c0
-+}
-+
- // escapeList escapes a list template node.
- func (e *escaper) escapeList(c context, n *parse.ListNode) context {
-	if n == nil {
-@@ -493,6 +558,9 @@ func (e *escaper) escapeList(c context, n *parse.ListNode) context {
-	}
-	for _, m := range n.Nodes {
-		c = e.escape(c, m)
-+		if c.state == stateDead {
-+			break
-+		}
-	}
-	return c
- }
-@@ -503,6 +571,7 @@ func (e *escaper) escapeList(c context, n *parse.ListNode) context {
- // which is the same as whether e was updated.
- func (e *escaper) escapeListConditionally(c context, n *parse.ListNode, filter func(*escaper, context) bool) (context, bool) {
-	e1 := makeEscaper(e.ns)
-+	e1.rangeContext = e.rangeContext
-	// Make type inferences available to f.
-	for k, v := range e.output {
-		e1.output[k] = v
-diff --git a/src/html/template/escape_test.go b/src/html/template/escape_test.go
-index fbc84a7..3b0aa8c 100644
---- a/src/html/template/escape_test.go
-+++ b/src/html/template/escape_test.go
-@@ -920,6 +920,22 @@ func TestErrors(t *testing.T) {
-			"<a href='/foo?{{range .Items}}&{{.K}}={{.V}}{{end}}'>",
-			"",
-		},
-+		{
-+			"{{range .Items}}<a{{if .X}}{{end}}>{{end}}",
-+			"",
-+		},
-+		{
-+			"{{range .Items}}<a{{if .X}}{{end}}>{{continue}}{{end}}",
-+			"",
-+		},
-+		{
-+			"{{range .Items}}<a{{if .X}}{{end}}>{{break}}{{end}}",
-+			"",
-+		},
-+		{
-+			"{{range .Items}}<a{{if .X}}{{end}}>{{if .X}}{{break}}{{end}}{{end}}",
-+			"",
-+		},
-		// Error cases.
-		{
-			"{{if .Cond}}<a{{end}}",
-@@ -956,6 +972,14 @@ func TestErrors(t *testing.T) {
-			"z:2:8: on range loop re-entry: {{range}} branches",
-		},
-		{
-+			"{{range .Items}}<a{{if .X}}{{break}}{{end}}>{{end}}",
-+			"z:1:29: at range loop break: {{range}} branches end in different contexts",
-+		},
-+		{
-+			"{{range .Items}}<a{{if .X}}{{continue}}{{end}}>{{end}}",
-+			"z:1:29: at range loop continue: {{range}} branches end in different contexts",
-+		},
-+		{
-			"<a b=1 c={{.H}}",
-			"z: ends in a non-text context: {stateAttr delimSpaceOrTagEnd",
-		},
-diff --git a/src/html/template/exec_test.go b/src/html/template/exec_test.go
-index 8885873..523340b 100644
---- a/src/html/template/exec_test.go
-+++ b/src/html/template/exec_test.go
-@@ -567,6 +567,8 @@ var execTests = []execTest{
-	{"range empty no else", "{{range .SIEmpty}}-{{.}}-{{end}}", "", tVal, true},
-	{"range []int else", "{{range .SI}}-{{.}}-{{else}}EMPTY{{end}}", "-3--4--5-", tVal, true},
-	{"range empty else", "{{range .SIEmpty}}-{{.}}-{{else}}EMPTY{{end}}", "EMPTY", tVal, true},
-+	{"range []int break else", "{{range .SI}}-{{.}}-{{break}}NOTREACHED{{else}}EMPTY{{end}}", "-3-", tVal, true},
-+	{"range []int continue else", "{{range .SI}}-{{.}}-{{continue}}NOTREACHED{{else}}EMPTY{{end}}", "-3--4--5-", tVal, true},
-	{"range []bool", "{{range .SB}}-{{.}}-{{end}}", "-true--false-", tVal, true},
-	{"range []int method", "{{range .SI | .MAdd .I}}-{{.}}-{{end}}", "-20--21--22-", tVal, true},
-	{"range map", "{{range .MSI}}-{{.}}-{{end}}", "-1--3--2-", tVal, true},
-diff --git a/src/text/template/doc.go b/src/text/template/doc.go
-index 7b30294..0228b15 100644
---- a/src/text/template/doc.go
-+++ b/src/text/template/doc.go
-@@ -112,6 +112,14 @@ data, defined in detail in the corresponding sections that follow.
-		T0 is executed; otherwise, dot is set to the successive elements
-		of the array, slice, or map and T1 is executed.
-
-+	{{break}}
-+		The innermost {{range pipeline}} loop is ended early, stopping the
-+		current iteration and bypassing all remaining iterations.
-+
-+	{{continue}}
-+		The current iteration of the innermost {{range pipeline}} loop is
-+		stopped, and the loop starts the next iteration.
-+
-	{{template "name"}}
-		The template with the specified name is executed with nil data.
-
-diff --git a/src/text/template/exec.go b/src/text/template/exec.go
-index 5ad3b4e..92fa9d9 100644
---- a/src/text/template/exec.go
-+++ b/src/text/template/exec.go
-@@ -5,6 +5,7 @@
- package template
-
- import (
-+	"errors"
-	"fmt"
-	"internal/fmtsort"
-	"io"
-@@ -243,6 +244,12 @@ func (t *Template) DefinedTemplates() string {
-	return b.String()
- }
-
-+// Sentinel errors for use with panic to signal early exits from range loops.
-+var (
-+	walkBreak    = errors.New("break")
-+	walkContinue = errors.New("continue")
-+)
-+
- // Walk functions step through the major pieces of the template structure,
- // generating output as they go.
- func (s *state) walk(dot reflect.Value, node parse.Node) {
-@@ -255,7 +262,11 @@ func (s *state) walk(dot reflect.Value, node parse.Node) {
-		if len(node.Pipe.Decl) == 0 {
-			s.printValue(node, val)
-		}
-+	case *parse.BreakNode:
-+		panic(walkBreak)
-	case *parse.CommentNode:
-+	case *parse.ContinueNode:
-+		panic(walkContinue)
-	case *parse.IfNode:
-		s.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)
-	case *parse.ListNode:
-@@ -334,6 +345,11 @@ func isTrue(val reflect.Value) (truth, ok bool) {
-
- func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {
-	s.at(r)
-+	defer func() {
-+		if r := recover(); r != nil && r != walkBreak {
-+			panic(r)
-+		}
-+	}()
-	defer s.pop(s.mark())
-	val, _ := indirect(s.evalPipeline(dot, r.Pipe))
-	// mark top of stack before any variables in the body are pushed.
-@@ -347,8 +363,14 @@ func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {
-		if len(r.Pipe.Decl) > 1 {
-			s.setTopVar(2, index)
-		}
-+		defer s.pop(mark)
-+		defer func() {
-+			// Consume panic(walkContinue)
-+			if r := recover(); r != nil && r != walkContinue {
-+				panic(r)
-+			}
-+		}()
-		s.walk(elem, r.List)
--		s.pop(mark)
-	}
-	switch val.Kind() {
-	case reflect.Array, reflect.Slice:
-diff --git a/src/text/template/exec_test.go b/src/text/template/exec_test.go
-index ef52164..586af55 100644
---- a/src/text/template/exec_test.go
-+++ b/src/text/template/exec_test.go
-@@ -564,6 +564,8 @@ var execTests = []execTest{
-	{"range empty no else", "{{range .SIEmpty}}-{{.}}-{{end}}", "", tVal, true},
-	{"range []int else", "{{range .SI}}-{{.}}-{{else}}EMPTY{{end}}", "-3--4--5-", tVal, true},
-	{"range empty else", "{{range .SIEmpty}}-{{.}}-{{else}}EMPTY{{end}}", "EMPTY", tVal, true},
-+	{"range []int break else", "{{range .SI}}-{{.}}-{{break}}NOTREACHED{{else}}EMPTY{{end}}", "-3-", tVal, true},
-+	{"range []int continue else", "{{range .SI}}-{{.}}-{{continue}}NOTREACHED{{else}}EMPTY{{end}}", "-3--4--5-", tVal, true},
-	{"range []bool", "{{range .SB}}-{{.}}-{{end}}", "-true--false-", tVal, true},
-	{"range []int method", "{{range .SI | .MAdd .I}}-{{.}}-{{end}}", "-20--21--22-", tVal, true},
-	{"range map", "{{range .MSI}}-{{.}}-{{end}}", "-1--3--2-", tVal, true},
-diff --git a/src/text/template/parse/lex.go b/src/text/template/parse/lex.go
-index 6784071..95e3377 100644
---- a/src/text/template/parse/lex.go
-+++ b/src/text/template/parse/lex.go
-@@ -62,6 +62,8 @@ const (
-	// Keywords appear after all the rest.
-	itemKeyword  // used only to delimit the keywords
-	itemBlock    // block keyword
-+	itemBreak    // break keyword
-+	itemContinue // continue keyword
-	itemDot      // the cursor, spelled '.'
-	itemDefine   // define keyword
-	itemElse     // else keyword
-@@ -76,6 +78,8 @@ const (
- var key = map[string]itemType{
-	".":        itemDot,
-	"block":    itemBlock,
-+	"break":    itemBreak,
-+	"continue": itemContinue,
-	"define":   itemDefine,
-	"else":     itemElse,
-	"end":      itemEnd,
-@@ -119,6 +123,8 @@ type lexer struct {
-	parenDepth  int       // nesting depth of ( ) exprs
-	line        int       // 1+number of newlines seen
-	startLine   int       // start line of this item
-+	breakOK     bool      // break keyword allowed
-+	continueOK  bool      // continue keyword allowed
- }
-
- // next returns the next rune in the input.
-@@ -461,7 +467,12 @@ Loop:
-			}
-			switch {
-			case key[word] > itemKeyword:
--				l.emit(key[word])
-+				item := key[word]
-+				if item == itemBreak && !l.breakOK || item == itemContinue && !l.continueOK {
-+					l.emit(itemIdentifier)
-+				} else {
-+					l.emit(item)
-+				}
-			case word[0] == '.':
-				l.emit(itemField)
-			case word == "true", word == "false":
-diff --git a/src/text/template/parse/lex_test.go b/src/text/template/parse/lex_test.go
-index 6510eed..df6aabf 100644
---- a/src/text/template/parse/lex_test.go
-+++ b/src/text/template/parse/lex_test.go
-@@ -35,6 +35,8 @@ var itemName = map[itemType]string{
-	// keywords
-	itemDot:      ".",
-	itemBlock:    "block",
-+	itemBreak:    "break",
-+	itemContinue: "continue",
-	itemDefine:   "define",
-	itemElse:     "else",
-	itemIf:       "if",
-diff --git a/src/text/template/parse/node.go b/src/text/template/parse/node.go
-index 177482f..4726822 100644
---- a/src/text/template/parse/node.go
-+++ b/src/text/template/parse/node.go
-@@ -71,6 +71,8 @@ const (
-	NodeVariable                   // A $ variable.
-	NodeWith                       // A with action.
-	NodeComment                    // A comment.
-+	NodeBreak                      // A break action.
-+	NodeContinue                   // A continue action.
- )
-
- // Nodes.
-@@ -907,6 +909,40 @@ func (i *IfNode) Copy() Node {
-	return i.tr.newIf(i.Pos, i.Line, i.Pipe.CopyPipe(), i.List.CopyList(), i.ElseList.CopyList())
- }
-
-+// BreakNode represents a {{break}} action.
-+type BreakNode struct {
-+	tr *Tree
-+	NodeType
-+	Pos
-+	Line int
-+}
-+
-+func (t *Tree) newBreak(pos Pos, line int) *BreakNode {
-+	return &BreakNode{tr: t, NodeType: NodeBreak, Pos: pos, Line: line}
-+}
-+
-+func (b *BreakNode) Copy() Node                  { return b.tr.newBreak(b.Pos, b.Line) }
-+func (b *BreakNode) String() string              { return "{{break}}" }
-+func (b *BreakNode) tree() *Tree                 { return b.tr }
-+func (b *BreakNode) writeTo(sb *strings.Builder) { sb.WriteString("{{break}}") }
-+
-+// ContinueNode represents a {{continue}} action.
-+type ContinueNode struct {
-+	tr *Tree
-+	NodeType
-+	Pos
-+	Line int
-+}
-+
-+func (t *Tree) newContinue(pos Pos, line int) *ContinueNode {
-+	return &ContinueNode{tr: t, NodeType: NodeContinue, Pos: pos, Line: line}
-+}
-+
-+func (c *ContinueNode) Copy() Node                  { return c.tr.newContinue(c.Pos, c.Line) }
-+func (c *ContinueNode) String() string              { return "{{continue}}" }
-+func (c *ContinueNode) tree() *Tree                 { return c.tr }
-+func (c *ContinueNode) writeTo(sb *strings.Builder) { sb.WriteString("{{continue}}") }
-+
- // RangeNode represents a {{range}} action and its commands.
- type RangeNode struct {
-	BranchNode
-diff --git a/src/text/template/parse/parse.go b/src/text/template/parse/parse.go
-index 1a63961..d92bed5 100644
---- a/src/text/template/parse/parse.go
-+++ b/src/text/template/parse/parse.go
-@@ -31,6 +31,7 @@ type Tree struct {
-	vars       []string // variables defined at the moment.
-	treeSet    map[string]*Tree
-	actionLine int // line of left delim starting action
-+	rangeDepth int
-	mode       Mode
- }
-
-@@ -224,6 +225,8 @@ func (t *Tree) startParse(funcs []map[string]interface{}, lex *lexer, treeSet ma
-	t.vars = []string{"$"}
-	t.funcs = funcs
-	t.treeSet = treeSet
-+	lex.breakOK = !t.hasFunction("break")
-+	lex.continueOK = !t.hasFunction("continue")
- }
-
- // stopParse terminates parsing.
-@@ -386,6 +389,10 @@ func (t *Tree) action() (n Node) {
-	switch token := t.nextNonSpace(); token.typ {
-	case itemBlock:
-		return t.blockControl()
-+	case itemBreak:
-+		return t.breakControl(token.pos, token.line)
-+	case itemContinue:
-+		return t.continueControl(token.pos, token.line)
-	case itemElse:
-		return t.elseControl()
-	case itemEnd:
-@@ -405,6 +412,32 @@ func (t *Tree) action() (n Node) {
-	return t.newAction(token.pos, token.line, t.pipeline("command", itemRightDelim))
- }
-
-+// Break:
-+//	{{break}}
-+// Break keyword is past.
-+func (t *Tree) breakControl(pos Pos, line int) Node {
-+	if token := t.next(); token.typ != itemRightDelim {
-+		t.unexpected(token, "in {{break}}")
-+	}
-+	if t.rangeDepth == 0 {
-+		t.errorf("{{break}} outside {{range}}")
-+	}
-+	return t.newBreak(pos, line)
-+}
-+
-+// Continue:
-+//	{{continue}}
-+// Continue keyword is past.
-+func (t *Tree) continueControl(pos Pos, line int) Node {
-+	if token := t.next(); token.typ != itemRightDelim {
-+		t.unexpected(token, "in {{continue}}")
-+	}
-+	if t.rangeDepth == 0 {
-+		t.errorf("{{continue}} outside {{range}}")
-+	}
-+	return t.newContinue(pos, line)
-+}
-+
- // Pipeline:
- //	declarations? command ('|' command)*
- func (t *Tree) pipeline(context string, end itemType) (pipe *PipeNode) {
-@@ -480,8 +513,14 @@ func (t *Tree) checkPipeline(pipe *PipeNode, context string) {
- func (t *Tree) parseControl(allowElseIf bool, context string) (pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) {
-	defer t.popVars(len(t.vars))
-	pipe = t.pipeline(context, itemRightDelim)
-+	if context == "range" {
-+		t.rangeDepth++
-+	}
-	var next Node
-	list, next = t.itemList()
-+	if context == "range" {
-+		t.rangeDepth--
-+	}
-	switch next.Type() {
-	case nodeEnd: //done
-	case nodeElse:
-@@ -523,7 +562,8 @@ func (t *Tree) ifControl() Node {
- //	{{range pipeline}} itemList {{else}} itemList {{end}}
- // Range keyword is past.
- func (t *Tree) rangeControl() Node {
--	return t.newRange(t.parseControl(false, "range"))
-+	r := t.newRange(t.parseControl(false, "range"))
-+	return r
- }
-
- // With:
-diff --git a/src/text/template/parse/parse_test.go b/src/text/template/parse/parse_test.go
-index 9b1be27..c3679a0 100644
---- a/src/text/template/parse/parse_test.go
-+++ b/src/text/template/parse/parse_test.go
-@@ -230,6 +230,10 @@ var parseTests = []parseTest{
-		`{{range $x := .SI}}{{.}}{{end}}`},
-	{"range 2 vars", "{{range $x, $y := .SI}}{{.}}{{end}}", noError,
-		`{{range $x, $y := .SI}}{{.}}{{end}}`},
-+	{"range with break", "{{range .SI}}{{.}}{{break}}{{end}}", noError,
-+		`{{range .SI}}{{.}}{{break}}{{end}}`},
-+	{"range with continue", "{{range .SI}}{{.}}{{continue}}{{end}}", noError,
-+		`{{range .SI}}{{.}}{{continue}}{{end}}`},
-	{"constants", "{{range .SI 1 -3.2i true false 'a' nil}}{{end}}", noError,
-		`{{range .SI 1 -3.2i true false 'a' nil}}{{end}}`},
-	{"template", "{{template `x`}}", noError,
-@@ -279,6 +283,10 @@ var parseTests = []parseTest{
-	{"adjacent args", "{{printf 3`x`}}", hasError, ""},
-	{"adjacent args with .", "{{printf `x`.}}", hasError, ""},
-	{"extra end after if", "{{if .X}}a{{else if .Y}}b{{end}}{{end}}", hasError, ""},
-+	{"break outside range", "{{range .}}{{end}} {{break}}", hasError, ""},
-+	{"continue outside range", "{{range .}}{{end}} {{continue}}", hasError, ""},
-+	{"break in range else", "{{range .}}{{else}}{{break}}{{end}}", hasError, ""},
-+	{"continue in range else", "{{range .}}{{else}}{{continue}}{{end}}", hasError, ""},
-	// Other kinds of assignments and operators aren't available yet.
-	{"bug0a", "{{$x := 0}}{{$x}}", noError, "{{$x := 0}}{{$x}}"},
-	{"bug0b", "{{$x += 1}}{{$x}}", hasError, ""},
---
-2.7.4
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-24538_2.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-24538_2.patch
deleted file mode 100644
index f94f0f55c7..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-24538_2.patch
+++ /dev/null
@@ -1,371 +0,0 @@
-From 07cc3b8711a8efbb5885f56dd90d854049ad2f7d Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Mon, 20 Mar 2023 11:01:13 -0700
-Subject: [PATCH 2/2] html/template: disallow actions in JS template literals
-
-ECMAScript 6 introduced template literals[0][1] which are delimited with
-backticks. These need to be escaped in a similar fashion to the
-delimiters for other string literals. Additionally template literals can
-contain special syntax for string interpolation.
-
-There is no clear way to allow safe insertion of actions within JS
-template literals, as handling (JS) string interpolation inside of these
-literals is rather complex. As such we've chosen to simply disallow
-template actions within these template literals.
-
-A new error code is added for this parsing failure case, errJsTmplLit,
-but it is unexported as it is not backwards compatible with other minor
-release versions to introduce an API change in a minor release. We will
-export this code in the next major release.
-
-The previous behavior (with the cavet that backticks are now escaped
-properly) can be re-enabled with GODEBUG=jstmpllitinterp=1.
-
-This change subsumes CL471455.
-
-Thanks to Sohom Datta, Manipal Institute of Technology, for reporting
-this issue.
-
-Fixes CVE-2023-24538
-For #59234
-Fixes #59271
-
-[0] https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-template-literals
-[1] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
-
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802457
-Reviewed-by: Damien Neil <dneil@google.com>
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802612
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Change-Id: Ic7f10595615f2b2740d9c85ad7ef40dc0e78c04c
-Reviewed-on: https://go-review.googlesource.com/c/go/+/481987
-Auto-Submit: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-
-Upstream-Status: Backport from https://github.com/golang/go/commit/b1e3ecfa06b67014429a197ec5e134ce4303ad9b
-CVE: CVE-2023-24538
-Signed-off-by: Shubham Kulkarni <skulkarni@mvista.com>
----
- src/html/template/context.go      |  2 ++
- src/html/template/error.go        | 13 ++++++++
- src/html/template/escape.go       | 11 +++++++
- src/html/template/escape_test.go  | 66 ++++++++++++++++++++++-----------------
- src/html/template/js.go           |  2 ++
- src/html/template/js_test.go      |  2 +-
- src/html/template/jsctx_string.go |  9 ++++++
- src/html/template/state_string.go | 37 ++++++++++++++++++++--
- src/html/template/transition.go   |  7 ++++-
- 9 files changed, 116 insertions(+), 33 deletions(-)
-
-diff --git a/src/html/template/context.go b/src/html/template/context.go
-index f7d4849..0b65313 100644
---- a/src/html/template/context.go
-+++ b/src/html/template/context.go
-@@ -116,6 +116,8 @@ const (
-	stateJSDqStr
-	// stateJSSqStr occurs inside a JavaScript single quoted string.
-	stateJSSqStr
-+	// stateJSBqStr occurs inside a JavaScript back quoted string.
-+	stateJSBqStr
-	// stateJSRegexp occurs inside a JavaScript regexp literal.
-	stateJSRegexp
-	// stateJSBlockCmt occurs inside a JavaScript /* block comment */.
-diff --git a/src/html/template/error.go b/src/html/template/error.go
-index 0e52706..fd26b64 100644
---- a/src/html/template/error.go
-+++ b/src/html/template/error.go
-@@ -211,6 +211,19 @@ const (
-	//   pipeline occurs in an unquoted attribute value context, "html" is
-	//   disallowed. Avoid using "html" and "urlquery" entirely in new templates.
-	ErrPredefinedEscaper
-+
-+	// errJSTmplLit: "... appears in a JS template literal"
-+	// Example:
-+	//     <script>var tmpl = `{{.Interp}`</script>
-+	// Discussion:
-+	//   Package html/template does not support actions inside of JS template
-+	//   literals.
-+	//
-+	// TODO(rolandshoemaker): we cannot add this as an exported error in a minor
-+	// release, since it is backwards incompatible with the other minor
-+	// releases. As such we need to leave it unexported, and then we'll add it
-+	// in the next major release.
-+	errJSTmplLit
- )
-
- func (e *Error) Error() string {
-diff --git a/src/html/template/escape.go b/src/html/template/escape.go
-index 8739735..ca078f4 100644
---- a/src/html/template/escape.go
-+++ b/src/html/template/escape.go
-@@ -8,6 +8,7 @@ import (
-	"bytes"
-	"fmt"
-	"html"
-+	"internal/godebug"
-	"io"
-	"text/template"
-	"text/template/parse"
-@@ -205,6 +206,16 @@ func (e *escaper) escapeAction(c context, n *parse.ActionNode) context {
-		c.jsCtx = jsCtxDivOp
-	case stateJSDqStr, stateJSSqStr:
-		s = append(s, "_html_template_jsstrescaper")
-+	case stateJSBqStr:
-+		debugAllowActionJSTmpl := godebug.Get("jstmpllitinterp")
-+		if debugAllowActionJSTmpl == "1" {
-+			s = append(s, "_html_template_jsstrescaper")
-+		} else {
-+			return context{
-+				state: stateError,
-+				err:   errorf(errJSTmplLit, n, n.Line, "%s appears in a JS template literal", n),
-+			}
-+		}
-	case stateJSRegexp:
-		s = append(s, "_html_template_jsregexpescaper")
-	case stateCSS:
-diff --git a/src/html/template/escape_test.go b/src/html/template/escape_test.go
-index 3b0aa8c..a695b17 100644
---- a/src/html/template/escape_test.go
-+++ b/src/html/template/escape_test.go
-@@ -681,35 +681,31 @@ func TestEscape(t *testing.T) {
-	}
-
-	for _, test := range tests {
--		tmpl := New(test.name)
--		tmpl = Must(tmpl.Parse(test.input))
--		// Check for bug 6459: Tree field was not set in Parse.
--		if tmpl.Tree != tmpl.text.Tree {
--			t.Errorf("%s: tree not set properly", test.name)
--			continue
--		}
--		b := new(bytes.Buffer)
--		if err := tmpl.Execute(b, data); err != nil {
--			t.Errorf("%s: template execution failed: %s", test.name, err)
--			continue
--		}
--		if w, g := test.output, b.String(); w != g {
--			t.Errorf("%s: escaped output: want\n\t%q\ngot\n\t%q", test.name, w, g)
--			continue
--		}
--		b.Reset()
--		if err := tmpl.Execute(b, pdata); err != nil {
--			t.Errorf("%s: template execution failed for pointer: %s", test.name, err)
--			continue
--		}
--		if w, g := test.output, b.String(); w != g {
--			t.Errorf("%s: escaped output for pointer: want\n\t%q\ngot\n\t%q", test.name, w, g)
--			continue
--		}
--		if tmpl.Tree != tmpl.text.Tree {
--			t.Errorf("%s: tree mismatch", test.name)
--			continue
--		}
-+		t.Run(test.name, func(t *testing.T) {
-+			tmpl := New(test.name)
-+			tmpl = Must(tmpl.Parse(test.input))
-+			// Check for bug 6459: Tree field was not set in Parse.
-+			if tmpl.Tree != tmpl.text.Tree {
-+				t.Fatalf("%s: tree not set properly", test.name)
-+			}
-+			b := new(strings.Builder)
-+			if err := tmpl.Execute(b, data); err != nil {
-+				t.Fatalf("%s: template execution failed: %s", test.name, err)
-+			}
-+			if w, g := test.output, b.String(); w != g {
-+				t.Fatalf("%s: escaped output: want\n\t%q\ngot\n\t%q", test.name, w, g)
-+			}
-+			b.Reset()
-+			if err := tmpl.Execute(b, pdata); err != nil {
-+				t.Fatalf("%s: template execution failed for pointer: %s", test.name, err)
-+			}
-+			if w, g := test.output, b.String(); w != g {
-+				t.Fatalf("%s: escaped output for pointer: want\n\t%q\ngot\n\t%q", test.name, w, g)
-+			}
-+			if tmpl.Tree != tmpl.text.Tree {
-+				t.Fatalf("%s: tree mismatch", test.name)
-+			}
-+		})
-	}
- }
-
-@@ -936,6 +932,10 @@ func TestErrors(t *testing.T) {
-			"{{range .Items}}<a{{if .X}}{{end}}>{{if .X}}{{break}}{{end}}{{end}}",
-			"",
-		},
-+		{
-+			"<script>var a = `${a+b}`</script>`",
-+			"",
-+		},
-		// Error cases.
-		{
-			"{{if .Cond}}<a{{end}}",
-@@ -1082,6 +1082,10 @@ func TestErrors(t *testing.T) {
-			// html is allowed since it is the last command in the pipeline, but urlquery is not.
-			`predefined escaper "urlquery" disallowed in template`,
-		},
-+		{
-+			"<script>var tmpl = `asd {{.}}`;</script>",
-+			`{{.}} appears in a JS template literal`,
-+		},
-	}
-	for _, test := range tests {
-		buf := new(bytes.Buffer)
-@@ -1304,6 +1308,10 @@ func TestEscapeText(t *testing.T) {
-			context{state: stateJSSqStr, delim: delimDoubleQuote, attr: attrScript},
-		},
-		{
-+			"<a onclick=\"`foo",
-+			context{state: stateJSBqStr, delim: delimDoubleQuote, attr: attrScript},
-+		},
-+		{
-			`<A ONCLICK="'`,
-			context{state: stateJSSqStr, delim: delimDoubleQuote, attr: attrScript},
-		},
-diff --git a/src/html/template/js.go b/src/html/template/js.go
-index ea9c183..b888eaf 100644
---- a/src/html/template/js.go
-+++ b/src/html/template/js.go
-@@ -308,6 +308,7 @@ var jsStrReplacementTable = []string{
-	// Encode HTML specials as hex so the output can be embedded
-	// in HTML attributes without further encoding.
-	'"':  `\u0022`,
-+	'`':  `\u0060`,
-	'&':  `\u0026`,
-	'\'': `\u0027`,
-	'+':  `\u002b`,
-@@ -331,6 +332,7 @@ var jsStrNormReplacementTable = []string{
-	'"':  `\u0022`,
-	'&':  `\u0026`,
-	'\'': `\u0027`,
-+	'`':  `\u0060`,
-	'+':  `\u002b`,
-	'/':  `\/`,
-	'<':  `\u003c`,
-diff --git a/src/html/template/js_test.go b/src/html/template/js_test.go
-index d7ee47b..7d963ae 100644
---- a/src/html/template/js_test.go
-+++ b/src/html/template/js_test.go
-@@ -292,7 +292,7 @@ func TestEscapersOnLower7AndSelectHighCodepoints(t *testing.T) {
-				`0123456789:;\u003c=\u003e?` +
-				`@ABCDEFGHIJKLMNO` +
-				`PQRSTUVWXYZ[\\]^_` +
--				"`abcdefghijklmno" +
-+				"\\u0060abcdefghijklmno" +
-				"pqrstuvwxyz{|}~\u007f" +
-				"\u00A0\u0100\\u2028\\u2029\ufeff\U0001D11E",
-		},
-diff --git a/src/html/template/jsctx_string.go b/src/html/template/jsctx_string.go
-index dd1d87e..2394893 100644
---- a/src/html/template/jsctx_string.go
-+++ b/src/html/template/jsctx_string.go
-@@ -4,6 +4,15 @@ package template
-
- import "strconv"
-
-+func _() {
-+	// An "invalid array index" compiler error signifies that the constant values have changed.
-+	// Re-run the stringer command to generate them again.
-+	var x [1]struct{}
-+	_ = x[jsCtxRegexp-0]
-+	_ = x[jsCtxDivOp-1]
-+	_ = x[jsCtxUnknown-2]
-+}
-+
- const _jsCtx_name = "jsCtxRegexpjsCtxDivOpjsCtxUnknown"
-
- var _jsCtx_index = [...]uint8{0, 11, 21, 33}
-diff --git a/src/html/template/state_string.go b/src/html/template/state_string.go
-index 05104be..6fb1a6e 100644
---- a/src/html/template/state_string.go
-+++ b/src/html/template/state_string.go
-@@ -4,9 +4,42 @@ package template
-
- import "strconv"
-
--const _state_name = "stateTextstateTagstateAttrNamestateAfterNamestateBeforeValuestateHTMLCmtstateRCDATAstateAttrstateURLstateSrcsetstateJSstateJSDqStrstateJSSqStrstateJSRegexpstateJSBlockCmtstateJSLineCmtstateCSSstateCSSDqStrstateCSSSqStrstateCSSDqURLstateCSSSqURLstateCSSURLstateCSSBlockCmtstateCSSLineCmtstateError"
-+func _() {
-+	// An "invalid array index" compiler error signifies that the constant values have changed.
-+	// Re-run the stringer command to generate them again.
-+	var x [1]struct{}
-+	_ = x[stateText-0]
-+	_ = x[stateTag-1]
-+	_ = x[stateAttrName-2]
-+	_ = x[stateAfterName-3]
-+	_ = x[stateBeforeValue-4]
-+	_ = x[stateHTMLCmt-5]
-+	_ = x[stateRCDATA-6]
-+	_ = x[stateAttr-7]
-+	_ = x[stateURL-8]
-+	_ = x[stateSrcset-9]
-+	_ = x[stateJS-10]
-+	_ = x[stateJSDqStr-11]
-+	_ = x[stateJSSqStr-12]
-+	_ = x[stateJSBqStr-13]
-+	_ = x[stateJSRegexp-14]
-+	_ = x[stateJSBlockCmt-15]
-+	_ = x[stateJSLineCmt-16]
-+	_ = x[stateCSS-17]
-+	_ = x[stateCSSDqStr-18]
-+	_ = x[stateCSSSqStr-19]
-+	_ = x[stateCSSDqURL-20]
-+	_ = x[stateCSSSqURL-21]
-+	_ = x[stateCSSURL-22]
-+	_ = x[stateCSSBlockCmt-23]
-+	_ = x[stateCSSLineCmt-24]
-+	_ = x[stateError-25]
-+	_ = x[stateDead-26]
-+}
-+
-+const _state_name = "stateTextstateTagstateAttrNamestateAfterNamestateBeforeValuestateHTMLCmtstateRCDATAstateAttrstateURLstateSrcsetstateJSstateJSDqStrstateJSSqStrstateJSBqStrstateJSRegexpstateJSBlockCmtstateJSLineCmtstateCSSstateCSSDqStrstateCSSSqStrstateCSSDqURLstateCSSSqURLstateCSSURLstateCSSBlockCmtstateCSSLineCmtstateErrorstateDead"
-
--var _state_index = [...]uint16{0, 9, 17, 30, 44, 60, 72, 83, 92, 100, 111, 118, 130, 142, 155, 170, 184, 192, 205, 218, 231, 244, 255, 271, 286, 296}
-+var _state_index = [...]uint16{0, 9, 17, 30, 44, 60, 72, 83, 92, 100, 111, 118, 130, 142, 154, 167, 182, 196, 204, 217, 230, 243, 256, 267, 283, 298, 308, 317}
-
- func (i state) String() string {
-	if i >= state(len(_state_index)-1) {
-diff --git a/src/html/template/transition.go b/src/html/template/transition.go
-index 06df679..92eb351 100644
---- a/src/html/template/transition.go
-+++ b/src/html/template/transition.go
-@@ -27,6 +27,7 @@ var transitionFunc = [...]func(context, []byte) (context, int){
-	stateJS:          tJS,
-	stateJSDqStr:     tJSDelimited,
-	stateJSSqStr:     tJSDelimited,
-+	stateJSBqStr:     tJSDelimited,
-	stateJSRegexp:    tJSDelimited,
-	stateJSBlockCmt:  tBlockCmt,
-	stateJSLineCmt:   tLineCmt,
-@@ -262,7 +263,7 @@ func tURL(c context, s []byte) (context, int) {
-
- // tJS is the context transition function for the JS state.
- func tJS(c context, s []byte) (context, int) {
--	i := bytes.IndexAny(s, `"'/`)
-+	i := bytes.IndexAny(s, "\"`'/")
-	if i == -1 {
-		// Entire input is non string, comment, regexp tokens.
-		c.jsCtx = nextJSCtx(s, c.jsCtx)
-@@ -274,6 +275,8 @@ func tJS(c context, s []byte) (context, int) {
-		c.state, c.jsCtx = stateJSDqStr, jsCtxRegexp
-	case '\'':
-		c.state, c.jsCtx = stateJSSqStr, jsCtxRegexp
-+	case '`':
-+		c.state, c.jsCtx = stateJSBqStr, jsCtxRegexp
-	case '/':
-		switch {
-		case i+1 < len(s) && s[i+1] == '/':
-@@ -303,6 +306,8 @@ func tJSDelimited(c context, s []byte) (context, int) {
-	switch c.state {
-	case stateJSSqStr:
-		specials = `\'`
-+	case stateJSBqStr:
-+		specials = "`\\"
-	case stateJSRegexp:
-		specials = `\/[]`
-	}
---
-2.7.4
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-24539.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-24539.patch
deleted file mode 100644
index fa19e18264..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-24539.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From e49282327b05192e46086bf25fd3ac691205fe80 Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Thu, 13 Apr 2023 15:40:44 -0700
-Subject: [PATCH] [release-branch.go1.19] html/template: disallow angle
- brackets in CSS values
-
-Change-Id: Iccc659c9a18415992b0c05c178792228e3a7bae4
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1826636
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1851496
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/491335
-Run-TryBot: Carlos Amedee <carlos@golang.org>
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/e49282327b05192e46086bf25fd3ac691205fe80]
-CVE: CVE-2023-24539
-Signed-off-by: Vivek Kumbhar <vkumbhar@mvista.com>
----
- src/html/template/css.go      | 2 +-
- src/html/template/css_test.go | 2 ++
- 2 files changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/src/html/template/css.go b/src/html/template/css.go
-index 890a0c6b227fe..f650d8b3e843a 100644
---- a/src/html/template/css.go
-+++ b/src/html/template/css.go
-@@ -238,7 +238,7 @@ func cssValueFilter(args ...any) string {
- 	// inside a string that might embed JavaScript source.
- 	for i, c := range b {
- 		switch c {
--		case 0, '"', '\'', '(', ')', '/', ';', '@', '[', '\\', ']', '`', '{', '}':
-+		case 0, '"', '\'', '(', ')', '/', ';', '@', '[', '\\', ']', '`', '{', '}', '<', '>':
- 			return filterFailsafe
- 		case '-':
- 			// Disallow <!-- or -->.
-diff --git a/src/html/template/css_test.go b/src/html/template/css_test.go
-index a735638b0314f..2b76256a766e9 100644
---- a/src/html/template/css_test.go
-+++ b/src/html/template/css_test.go
-@@ -231,6 +231,8 @@ func TestCSSValueFilter(t *testing.T) {
- 		{`-exp\000052 ession(alert(1337))`, "ZgotmplZ"},
- 		{`-expre\0000073sion`, "-expre\x073sion"},
- 		{`@import url evil.css`, "ZgotmplZ"},
-+		{"<", "ZgotmplZ"},
-+		{">", "ZgotmplZ"},
- 	}
- 	for _, test := range tests {
- 		got := cssValueFilter(test.css)
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-29400.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-29400.patch
deleted file mode 100644
index 04bd1f5fec..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-29400.patch
+++ /dev/null
@@ -1,99 +0,0 @@
-From 9db0e74f606b8afb28cc71d4b1c8b4ed24cabbf5 Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Thu, 13 Apr 2023 14:01:50 -0700
-Subject: [PATCH] [release-branch.go1.19] html/template: emit filterFailsafe
- for empty unquoted attr value
-
-An unquoted action used as an attribute value can result in unsafe
-behavior if it is empty, as HTML normalization will result in unexpected
-attributes, and may allow attribute injection. If executing a template
-results in a empty unquoted attribute value, emit filterFailsafe
-instead.
-
-Thanks to Juho Nurminen of Mattermost for reporting this issue.
-
-For #59722
-Fixes #59815
-Fixes CVE-2023-29400
-
-Change-Id: Ia38d1b536ae2b4af5323a6c6d861e3c057c2570a
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1826631
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1851498
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/491357
-Run-TryBot: Carlos Amedee <carlos@golang.org>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/9db0e74f606b8afb28cc71d4b1c8b4ed24cabbf5]
-CVE: CVE-2023-29400
-Signed-off-by: Vivek Kumbhar <vkumbhar@mvista.com>
----
- src/html/template/escape.go      |  5 ++---
- src/html/template/escape_test.go | 15 +++++++++++++++
- src/html/template/html.go        |  3 +++
- 3 files changed, 20 insertions(+), 3 deletions(-)
-
-diff --git a/src/html/template/escape.go b/src/html/template/escape.go
-index ca078f4..bdccc65 100644
---- a/src/html/template/escape.go
-+++ b/src/html/template/escape.go
-@@ -362,9 +362,8 @@ func normalizeEscFn(e string) string {
- // for all x.
- var redundantFuncs = map[string]map[string]bool{
- 	"_html_template_commentescaper": {
--		"_html_template_attrescaper":    true,
--		"_html_template_nospaceescaper": true,
--		"_html_template_htmlescaper":    true,
-+		"_html_template_attrescaper": true,
-+		"_html_template_htmlescaper": true,
- 	},
- 	"_html_template_cssescaper": {
- 		"_html_template_attrescaper": true,
-diff --git a/src/html/template/escape_test.go b/src/html/template/escape_test.go
-index fbc84a7..4f48afe 100644
---- a/src/html/template/escape_test.go
-+++ b/src/html/template/escape_test.go
-@@ -678,6 +678,21 @@ func TestEscape(t *testing.T) {
- 			`<img srcset={{",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"}}>`,
- 			`<img srcset=,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>`,
- 		},
-+		{
-+			"unquoted empty attribute value (plaintext)",
-+			"<p name={{.U}}>",
-+			"<p name=ZgotmplZ>",
-+		},
-+		{
-+			"unquoted empty attribute value (url)",
-+			"<p href={{.U}}>",
-+			"<p href=ZgotmplZ>",
-+		},
-+		{
-+			"quoted empty attribute value",
-+			"<p name=\"{{.U}}\">",
-+			"<p name=\"\">",
-+		},
- 	}
- 
- 	for _, test := range tests {
-diff --git a/src/html/template/html.go b/src/html/template/html.go
-index 356b829..636bc21 100644
---- a/src/html/template/html.go
-+++ b/src/html/template/html.go
-@@ -14,6 +14,9 @@ import (
- // htmlNospaceEscaper escapes for inclusion in unquoted attribute values.
- func htmlNospaceEscaper(args ...interface{}) string {
- 	s, t := stringify(args...)
-+	if s == "" {
-+		return filterFailsafe
-+	}
- 	if t == contentTypeHTML {
- 		return htmlReplacer(stripTags(s), htmlNospaceNormReplacementTable, false)
- 	}
--- 
-2.25.1
-
diff --git a/meta/recipes-devtools/go/go-1.18/CVE-2023-29406.patch b/meta/recipes-devtools/go/go-1.18/CVE-2023-29406.patch
deleted file mode 100644
index a326cda5c4..0000000000
--- a/meta/recipes-devtools/go/go-1.18/CVE-2023-29406.patch
+++ /dev/null
@@ -1,210 +0,0 @@
-From 5fa6923b1ea891400153d04ddf1545e23b40041b Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Wed, 28 Jun 2023 13:20:08 -0700
-Subject: [PATCH] [release-branch.go1.19] net/http: validate Host header before
- sending
-
-Verify that the Host header we send is valid.
-Avoids surprising behavior such as a Host of "go.dev\r\nX-Evil:oops"
-adding an X-Evil header to HTTP/1 requests.
-
-Add a test, skip the test for HTTP/2. HTTP/2 is not vulnerable to
-header injection in the way HTTP/1 is, but x/net/http2 doesn't validate
-the header and will go into a retry loop when the server rejects it.
-CL 506995 adds the necessary validation to x/net/http2.
-
-Updates #60374
-Fixes #61075
-For CVE-2023-29406
-
-Change-Id: I05cb6866a9bead043101954dfded199258c6dd04
-Reviewed-on: https://go-review.googlesource.com/c/go/+/506996
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Damien Neil <dneil@google.com>
-(cherry picked from commit 499458f7ca04087958987a33c2703c3ef03e27e2)
-Reviewed-on: https://go-review.googlesource.com/c/go/+/507358
-Run-TryBot: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-by: Roland Shoemaker <roland@golang.org>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/5fa6923b1ea891400153d04ddf1545e23b40041b]
-CVE: CVE-2023-29406
-Signed-off-by: Vivek Kumbhar <vkumbhar@mvista.com>
----
- src/net/http/http_test.go      | 29 ----------------------
- src/net/http/request.go        | 45 ++++++++--------------------------
- src/net/http/request_test.go   | 11 ++-------
- src/net/http/transport_test.go | 18 ++++++++++++++
- 4 files changed, 30 insertions(+), 73 deletions(-)
-
-diff --git a/src/net/http/http_test.go b/src/net/http/http_test.go
-index 0d92fe5..f03272a 100644
---- a/src/net/http/http_test.go
-+++ b/src/net/http/http_test.go
-@@ -48,35 +48,6 @@ func TestForeachHeaderElement(t *testing.T) {
-	}
- }
-
--func TestCleanHost(t *testing.T) {
--	tests := []struct {
--		in, want string
--	}{
--		{"www.google.com", "www.google.com"},
--		{"www.google.com foo", "www.google.com"},
--		{"www.google.com/foo", "www.google.com"},
--		{" first character is a space", ""},
--		{"[1::6]:8080", "[1::6]:8080"},
--
--		// Punycode:
--		{"гофер.рф/foo", "xn--c1ae0ajs.xn--p1ai"},
--		{"bücher.de", "xn--bcher-kva.de"},
--		{"bücher.de:8080", "xn--bcher-kva.de:8080"},
--		// Verify we convert to lowercase before punycode:
--		{"BÜCHER.de", "xn--bcher-kva.de"},
--		{"BÜCHER.de:8080", "xn--bcher-kva.de:8080"},
--		// Verify we normalize to NFC before punycode:
--		{"gophér.nfc", "xn--gophr-esa.nfc"},            // NFC input; no work needed
--		{"goph\u0065\u0301r.nfd", "xn--gophr-esa.nfd"}, // NFD input
--	}
--	for _, tt := range tests {
--		got := cleanHost(tt.in)
--		if tt.want != got {
--			t.Errorf("cleanHost(%q) = %q, want %q", tt.in, got, tt.want)
--		}
--	}
--}
--
- // Test that cmd/go doesn't link in the HTTP server.
- //
- // This catches accidental dependencies between the HTTP transport and
-diff --git a/src/net/http/request.go b/src/net/http/request.go
-index 09cb0c7..2f4e740 100644
---- a/src/net/http/request.go
-+++ b/src/net/http/request.go
-@@ -17,7 +17,6 @@ import (
-	"io"
-	"mime"
-	"mime/multipart"
--	"net"
-	"net/http/httptrace"
-	"net/http/internal/ascii"
-	"net/textproto"
-@@ -27,6 +26,7 @@ import (
-	"strings"
-	"sync"
-
-+	"golang.org/x/net/http/httpguts"
-	"golang.org/x/net/idna"
- )
-
-@@ -568,12 +568,19 @@ func (r *Request) write(w io.Writer, usingProxy bool, extraHeaders Header, waitF
-	// is not given, use the host from the request URL.
-	//
-	// Clean the host, in case it arrives with unexpected stuff in it.
--	host := cleanHost(r.Host)
-+	host := r.Host
-	if host == "" {
-		if r.URL == nil {
-			return errMissingHost
-		}
--		host = cleanHost(r.URL.Host)
-+		host = r.URL.Host
-+	}
-+	host, err = httpguts.PunycodeHostPort(host)
-+	if err != nil {
-+		return err
-+	}
-+	if !httpguts.ValidHostHeader(host) {
-+		return errors.New("http: invalid Host header")
-	}
-
-	// According to RFC 6874, an HTTP client, proxy, or other
-@@ -730,38 +737,6 @@ func idnaASCII(v string) (string, error) {
-	return idna.Lookup.ToASCII(v)
- }
-
--// cleanHost cleans up the host sent in request's Host header.
--//
--// It both strips anything after '/' or ' ', and puts the value
--// into Punycode form, if necessary.
--//
--// Ideally we'd clean the Host header according to the spec:
--//   https://tools.ietf.org/html/rfc7230#section-5.4 (Host = uri-host [ ":" port ]")
--//   https://tools.ietf.org/html/rfc7230#section-2.7 (uri-host -> rfc3986's host)
--//   https://tools.ietf.org/html/rfc3986#section-3.2.2 (definition of host)
--// But practically, what we are trying to avoid is the situation in
--// issue 11206, where a malformed Host header used in the proxy context
--// would create a bad request. So it is enough to just truncate at the
--// first offending character.
--func cleanHost(in string) string {
--	if i := strings.IndexAny(in, " /"); i != -1 {
--		in = in[:i]
--	}
--	host, port, err := net.SplitHostPort(in)
--	if err != nil { // input was just a host
--		a, err := idnaASCII(in)
--		if err != nil {
--			return in // garbage in, garbage out
--		}
--		return a
--	}
--	a, err := idnaASCII(host)
--	if err != nil {
--		return in // garbage in, garbage out
--	}
--	return net.JoinHostPort(a, port)
--}
--
- // removeZone removes IPv6 zone identifier from host.
- // E.g., "[fe80::1%en0]:8080" to "[fe80::1]:8080"
- func removeZone(host string) string {
-diff --git a/src/net/http/request_test.go b/src/net/http/request_test.go
-index fac12b7..368e87a 100644
---- a/src/net/http/request_test.go
-+++ b/src/net/http/request_test.go
-@@ -776,15 +776,8 @@ func TestRequestBadHost(t *testing.T) {
-	}
-	req.Host = "foo.com with spaces"
-	req.URL.Host = "foo.com with spaces"
--	req.Write(logWrites{t, &got})
--	want := []string{
--		"GET /after HTTP/1.1\r\n",
--		"Host: foo.com\r\n",
--		"User-Agent: " + DefaultUserAgent + "\r\n",
--		"\r\n",
--	}
--	if !reflect.DeepEqual(got, want) {
--		t.Errorf("Writes = %q\n  Want = %q", got, want)
-+	if err := req.Write(logWrites{t, &got}); err == nil {
-+		t.Errorf("Writing request with invalid Host: succeded, want error")
-	}
- }
-
-diff --git a/src/net/http/transport_test.go b/src/net/http/transport_test.go
-index eeaa492..58f12af 100644
---- a/src/net/http/transport_test.go
-+++ b/src/net/http/transport_test.go
-@@ -6512,3 +6512,21 @@ func TestCancelRequestWhenSharingConnection(t *testing.T) {
-	close(r2c)
-	wg.Wait()
- }
-+
-+func TestRequestSanitization(t *testing.T) {
-+	setParallel(t)
-+	defer afterTest(t)
-+
-+	ts := newClientServerTest(t, h1Mode, HandlerFunc(func(rw ResponseWriter, req *Request) {
-+		if h, ok := req.Header["X-Evil"]; ok {
-+			t.Errorf("request has X-Evil header: %q", h)
-+		}
-+	})).ts
-+	defer ts.Close()
-+	req, _ := NewRequest("GET", ts.URL, nil)
-+	req.Host = "go.dev\r\nX-Evil:evil"
-+	resp, _ := ts.Client().Do(req)
-+	if resp != nil {
-+		resp.Body.Close()
-+	}
-+}
---
-2.25.1
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_1.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_1.patch
deleted file mode 100644
index ff9ba18ec5..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_1.patch
+++ /dev/null
@@ -1,137 +0,0 @@
-From f8d691d335c6ac14bcbae6886b5bf8ca8bf1e6a5 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Thu, 16 Mar 2023 14:18:04 -0700
-Subject: [PATCH 1/3] mime/multipart: avoid excessive copy buffer allocations
- in ReadForm
-
-When copying form data to disk with io.Copy,
-allocate only one copy buffer and reuse it rather than
-creating two buffers per file (one from io.multiReader.WriteTo,
-and a second one from os.File.ReadFrom).
-
-Thanks to Jakob Ackermann (@das7pad) for reporting this issue.
-
-For CVE-2023-24536
-For #59153
-For #59269
-
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802453
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802395
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Change-Id: Ie405470c92abffed3356913b37d813e982c96c8b
-Reviewed-on: https://go-review.googlesource.com/c/go/+/481983
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Auto-Submit: Michael Knyszek <mknyszek@google.com>
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-
-CVE: CVE-2023-24536
-Upstream-Status: Backport [ef41a4e2face45e580c5836eaebd51629fc23f15]
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/mime/multipart/formdata.go      | 15 +++++++--
- src/mime/multipart/formdata_test.go | 49 +++++++++++++++++++++++++++++
- 2 files changed, 61 insertions(+), 3 deletions(-)
-
-diff --git a/src/mime/multipart/formdata.go b/src/mime/multipart/formdata.go
-index a7d4ca9..975dcb6 100644
---- a/src/mime/multipart/formdata.go
-+++ b/src/mime/multipart/formdata.go
-@@ -84,6 +84,7 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 			maxMemoryBytes = math.MaxInt64
- 		}
- 	}
-+	var copyBuf []byte
- 	for {
- 		p, err := r.nextPart(false, maxMemoryBytes)
- 		if err == io.EOF {
-@@ -147,14 +148,22 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 				}
- 			}
- 			numDiskFiles++
--			size, err := io.Copy(file, io.MultiReader(&b, p))
-+			if _, err := file.Write(b.Bytes()); err != nil {
-+				return nil, err
-+			}
-+			if copyBuf == nil {
-+				copyBuf = make([]byte, 32*1024) // same buffer size as io.Copy uses
-+			}
-+			// os.File.ReadFrom will allocate its own copy buffer if we let io.Copy use it.
-+			type writerOnly struct{ io.Writer }
-+			remainingSize, err := io.CopyBuffer(writerOnly{file}, p, copyBuf)
- 			if err != nil {
- 				return nil, err
- 			}
- 			fh.tmpfile = file.Name()
--			fh.Size = size
-+			fh.Size = int64(b.Len()) + remainingSize
- 			fh.tmpoff = fileOff
--			fileOff += size
-+			fileOff += fh.Size
- 			if !combineFiles {
- 				if err := file.Close(); err != nil {
- 					return nil, err
-diff --git a/src/mime/multipart/formdata_test.go b/src/mime/multipart/formdata_test.go
-index 5cded71..f5b5608 100644
---- a/src/mime/multipart/formdata_test.go
-+++ b/src/mime/multipart/formdata_test.go
-@@ -368,3 +368,52 @@ func testReadFormManyFiles(t *testing.T, distinct bool) {
- 		t.Fatalf("temp dir contains %v files; want 0", len(names))
- 	}
- }
-+
-+func BenchmarkReadForm(b *testing.B) {
-+	for _, test := range []struct {
-+		name string
-+		form func(fw *Writer, count int)
-+	}{{
-+		name: "fields",
-+		form: func(fw *Writer, count int) {
-+			for i := 0; i < count; i++ {
-+				w, _ := fw.CreateFormField(fmt.Sprintf("field%v", i))
-+				fmt.Fprintf(w, "value %v", i)
-+			}
-+		},
-+	}, {
-+		name: "files",
-+		form: func(fw *Writer, count int) {
-+			for i := 0; i < count; i++ {
-+				w, _ := fw.CreateFormFile(fmt.Sprintf("field%v", i), fmt.Sprintf("file%v", i))
-+				fmt.Fprintf(w, "value %v", i)
-+			}
-+		},
-+	}} {
-+		b.Run(test.name, func(b *testing.B) {
-+			for _, maxMemory := range []int64{
-+				0,
-+				1 << 20,
-+			} {
-+				var buf bytes.Buffer
-+				fw := NewWriter(&buf)
-+				test.form(fw, 10)
-+				if err := fw.Close(); err != nil {
-+					b.Fatal(err)
-+				}
-+				b.Run(fmt.Sprintf("maxMemory=%v", maxMemory), func(b *testing.B) {
-+					b.ReportAllocs()
-+					for i := 0; i < b.N; i++ {
-+						fr := NewReader(bytes.NewReader(buf.Bytes()), fw.Boundary())
-+						form, err := fr.ReadForm(maxMemory)
-+						if err != nil {
-+							b.Fatal(err)
-+						}
-+						form.RemoveAll()
-+					}
-+
-+				})
-+			}
-+		})
-+	}
-+}
--- 
-2.35.5
-
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_2.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_2.patch
deleted file mode 100644
index 704a1fb567..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_2.patch
+++ /dev/null
@@ -1,187 +0,0 @@
-From 4174a87b600c58e8cc00d9d18d0c507c67ca5d41 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Thu, 16 Mar 2023 16:56:12 -0700
-Subject: [PATCH 2/3] net/textproto, mime/multipart: improve accounting of
- non-file data
-
-For requests containing large numbers of small parts,
-memory consumption of a parsed form could be about 250%
-over the estimated size.
-
-When considering the size of parsed forms, account for the size of
-FileHeader structs and increase the estimate of memory consumed by
-map entries.
-
-Thanks to Jakob Ackermann (@das7pad) for reporting this issue.
-
-For CVE-2023-24536
-For #59153
-For #59269
-
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802454
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802396
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Change-Id: I31bc50e9346b4eee6fbe51a18c3c57230cc066db
-Reviewed-on: https://go-review.googlesource.com/c/go/+/481984
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-Auto-Submit: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-
-CVE: CVE-2023-24536
-Upstream-Status: Backport [7a359a651c7ebdb29e0a1c03102fce793e9f58f0]
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/mime/multipart/formdata.go      |  9 +++--
- src/mime/multipart/formdata_test.go | 55 ++++++++++++-----------------
- src/net/textproto/reader.go         |  8 ++++-
- 3 files changed, 37 insertions(+), 35 deletions(-)
-
-diff --git a/src/mime/multipart/formdata.go b/src/mime/multipart/formdata.go
-index 975dcb6..3f6ff69 100644
---- a/src/mime/multipart/formdata.go
-+++ b/src/mime/multipart/formdata.go
-@@ -103,8 +103,9 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 		// Multiple values for the same key (one map entry, longer slice) are cheaper
- 		// than the same number of values for different keys (many map entries), but
- 		// using a consistent per-value cost for overhead is simpler.
-+		const mapEntryOverhead = 200
- 		maxMemoryBytes -= int64(len(name))
--		maxMemoryBytes -= 100 // map overhead
-+		maxMemoryBytes -= mapEntryOverhead
- 		if maxMemoryBytes < 0 {
- 			// We can't actually take this path, since nextPart would already have
- 			// rejected the MIME headers for being too large. Check anyway.
-@@ -128,7 +129,10 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 		}
- 
- 		// file, store in memory or on disk
-+		const fileHeaderSize = 100
- 		maxMemoryBytes -= mimeHeaderSize(p.Header)
-+		maxMemoryBytes -= mapEntryOverhead
-+		maxMemoryBytes -= fileHeaderSize
- 		if maxMemoryBytes < 0 {
- 			return nil, ErrMessageTooLarge
- 		}
-@@ -183,9 +187,10 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- }
- 
- func mimeHeaderSize(h textproto.MIMEHeader) (size int64) {
-+	size = 400
- 	for k, vs := range h {
- 		size += int64(len(k))
--		size += 100 // map entry overhead
-+		size += 200 // map entry overhead
- 		for _, v := range vs {
- 			size += int64(len(v))
- 		}
-diff --git a/src/mime/multipart/formdata_test.go b/src/mime/multipart/formdata_test.go
-index f5b5608..8ed26e0 100644
---- a/src/mime/multipart/formdata_test.go
-+++ b/src/mime/multipart/formdata_test.go
-@@ -192,10 +192,10 @@ func (r *failOnReadAfterErrorReader) Read(p []byte) (n int, err error) {
- // TestReadForm_NonFileMaxMemory asserts that the ReadForm maxMemory limit is applied
- // while processing non-file form data as well as file form data.
- func TestReadForm_NonFileMaxMemory(t *testing.T) {
--	n := 10<<20 + 25
- 	if testing.Short() {
--		n = 10<<10 + 25
-+		t.Skip("skipping in -short mode")
- 	}
-+	n := 10 << 20
- 	largeTextValue := strings.Repeat("1", n)
- 	message := `--MyBoundary
- Content-Disposition: form-data; name="largetext"
-@@ -203,38 +203,29 @@ Content-Disposition: form-data; name="largetext"
- ` + largeTextValue + `
- --MyBoundary--
- `
--
- 	testBody := strings.ReplaceAll(message, "\n", "\r\n")
--	testCases := []struct {
--		name      string
--		maxMemory int64
--		err       error
--	}{
--		{"smaller", 50 + int64(len("largetext")) + 100, nil},
--		{"exact-fit", 25 + int64(len("largetext")) + 100, nil},
--		{"too-large", 0, ErrMessageTooLarge},
--	}
--	for _, tc := range testCases {
--		t.Run(tc.name, func(t *testing.T) {
--			if tc.maxMemory == 0 && testing.Short() {
--				t.Skip("skipping in -short mode")
--			}
--			b := strings.NewReader(testBody)
--			r := NewReader(b, boundary)
--			f, err := r.ReadForm(tc.maxMemory)
--			if err == nil {
--				defer f.RemoveAll()
--			}
--			if tc.err != err {
--				t.Fatalf("ReadForm error - got: %v; expected: %v", err, tc.err)
--			}
--			if err == nil {
--				if g := f.Value["largetext"][0]; g != largeTextValue {
--					t.Errorf("largetext mismatch: got size: %v, expected size: %v", len(g), len(largeTextValue))
--				}
--			}
--		})
-+	// Try parsing the form with increasing maxMemory values.
-+	// Changes in how we account for non-file form data may cause the exact point
-+	// where we change from rejecting the form as too large to accepting it to vary,
-+	// but we should see both successes and failures.
-+	const failWhenMaxMemoryLessThan = 128
-+	for maxMemory := int64(0); maxMemory < failWhenMaxMemoryLessThan*2; maxMemory += 16 {
-+		b := strings.NewReader(testBody)
-+		r := NewReader(b, boundary)
-+		f, err := r.ReadForm(maxMemory)
-+		if err != nil {
-+			continue
-+		}
-+		if g := f.Value["largetext"][0]; g != largeTextValue {
-+			t.Errorf("largetext mismatch: got size: %v, expected size: %v", len(g), len(largeTextValue))
-+		}
-+		f.RemoveAll()
-+		if maxMemory < failWhenMaxMemoryLessThan {
-+			t.Errorf("ReadForm(%v): no error, expect to hit memory limit when maxMemory < %v", maxMemory, failWhenMaxMemoryLessThan)
-+		}
-+		return
- 	}
-+	t.Errorf("ReadForm(x) failed for x < 1024, expect success")
- }
- 
- // TestReadForm_MetadataTooLarge verifies that we account for the size of field names,
-diff --git a/src/net/textproto/reader.go b/src/net/textproto/reader.go
-index fcbede8..9af4c49 100644
---- a/src/net/textproto/reader.go
-+++ b/src/net/textproto/reader.go
-@@ -503,6 +503,12 @@ func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 
- 	m := make(MIMEHeader, hint)
- 
-+	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
-+	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
-+	// MIMEHeaders average about 200 bytes per entry.
-+	lim -= 400
-+	const mapEntryOverhead = 200
-+
- 	// The first line cannot start with a leading space.
- 	if buf, err := r.R.Peek(1); err == nil && (buf[0] == ' ' || buf[0] == '\t') {
- 		line, err := r.readLineSlice()
-@@ -552,7 +558,7 @@ func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 		vv := m[key]
- 		if vv == nil {
- 			lim -= int64(len(key))
--			lim -= 100 // map entry overhead
-+			lim -= mapEntryOverhead
- 		}
- 		lim -= int64(len(value))
- 		if lim < 0 {
--- 
-2.35.5
-
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_3.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_3.patch
deleted file mode 100644
index 6de04e9a61..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-24536_3.patch
+++ /dev/null
@@ -1,349 +0,0 @@
-From ec763bc936f76cec0fe71a791c6bb7d4ac5f3e46 Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Mon, 20 Mar 2023 10:43:19 -0700
-Subject: [PATCH 3/3] mime/multipart: limit parsed mime message sizes
-
-The parsed forms of MIME headers and multipart forms can consume
-substantially more memory than the size of the input data.
-A malicious input containing a very large number of headers or
-form parts can cause excessively large memory allocations.
-
-Set limits on the size of MIME data:
-
-Reader.NextPart and Reader.NextRawPart limit the the number
-of headers in a part to 10000.
-
-Reader.ReadForm limits the total number of headers in all
-FileHeaders to 10000.
-
-Both of these limits may be set with with
-GODEBUG=multipartmaxheaders=<values>.
-
-Reader.ReadForm limits the number of parts in a form to 1000.
-This limit may be set with GODEBUG=multipartmaxparts=<value>.
-
-Thanks for Jakob Ackermann (@das7pad) for reporting this issue.
-
-For CVE-2023-24536
-For #59153
-For #59269
-
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1802455
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1801087
-Reviewed-by: Damien Neil <dneil@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Change-Id: If134890d75f0d95c681d67234daf191ba08e6424
-Reviewed-on: https://go-review.googlesource.com/c/go/+/481985
-Run-TryBot: Michael Knyszek <mknyszek@google.com>
-Auto-Submit: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-
-CVE: CVE-2023-24536
-Upstream-Status: Backport [7917b5f31204528ea72e0629f0b7d52b35b27538]
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/mime/multipart/formdata.go       | 19 ++++++++-
- src/mime/multipart/formdata_test.go  | 61 ++++++++++++++++++++++++++++
- src/mime/multipart/multipart.go      | 31 ++++++++++----
- src/mime/multipart/readmimeheader.go |  2 +-
- src/net/textproto/reader.go          | 19 +++++----
- 5 files changed, 115 insertions(+), 17 deletions(-)
-
-diff --git a/src/mime/multipart/formdata.go b/src/mime/multipart/formdata.go
-index 3f6ff69..4f26aab 100644
---- a/src/mime/multipart/formdata.go
-+++ b/src/mime/multipart/formdata.go
-@@ -12,6 +12,7 @@ import (
- 	"math"
- 	"net/textproto"
- 	"os"
-+	"strconv"
- )
- 
- // ErrMessageTooLarge is returned by ReadForm if the message form
-@@ -41,6 +42,15 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 	numDiskFiles := 0
- 	multipartFiles := godebug.Get("multipartfiles")
- 	combineFiles := multipartFiles != "distinct"
-+	maxParts := 1000
-+	multipartMaxParts := godebug.Get("multipartmaxparts")
-+	if multipartMaxParts != "" {
-+		if v, err := strconv.Atoi(multipartMaxParts); err == nil && v >= 0 {
-+			maxParts = v
-+		}
-+	}
-+	maxHeaders := maxMIMEHeaders()
-+
- 	defer func() {
- 		if file != nil {
- 			if cerr := file.Close(); err == nil {
-@@ -86,13 +96,17 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 	}
- 	var copyBuf []byte
- 	for {
--		p, err := r.nextPart(false, maxMemoryBytes)
-+		p, err := r.nextPart(false, maxMemoryBytes, maxHeaders)
- 		if err == io.EOF {
- 			break
- 		}
- 		if err != nil {
- 			return nil, err
- 		}
-+		if maxParts <= 0 {
-+			return nil, ErrMessageTooLarge
-+		}
-+		maxParts--
- 
- 		name := p.FormName()
- 		if name == "" {
-@@ -136,6 +150,9 @@ func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 		if maxMemoryBytes < 0 {
- 			return nil, ErrMessageTooLarge
- 		}
-+		for _, v := range p.Header {
-+			maxHeaders -= int64(len(v))
-+		}
- 		fh := &FileHeader{
- 			Filename: filename,
- 			Header:   p.Header,
-diff --git a/src/mime/multipart/formdata_test.go b/src/mime/multipart/formdata_test.go
-index 8ed26e0..c78eeb7 100644
---- a/src/mime/multipart/formdata_test.go
-+++ b/src/mime/multipart/formdata_test.go
-@@ -360,6 +360,67 @@ func testReadFormManyFiles(t *testing.T, distinct bool) {
- 	}
- }
- 
-+func TestReadFormLimits(t *testing.T) {
-+	for _, test := range []struct {
-+		values           int
-+		files            int
-+		extraKeysPerFile int
-+		wantErr          error
-+		godebug          string
-+	}{
-+		{values: 1000},
-+		{values: 1001, wantErr: ErrMessageTooLarge},
-+		{values: 500, files: 500},
-+		{values: 501, files: 500, wantErr: ErrMessageTooLarge},
-+		{files: 1000},
-+		{files: 1001, wantErr: ErrMessageTooLarge},
-+		{files: 1, extraKeysPerFile: 9998}, // plus Content-Disposition and Content-Type
-+		{files: 1, extraKeysPerFile: 10000, wantErr: ErrMessageTooLarge},
-+		{godebug: "multipartmaxparts=100", values: 100},
-+		{godebug: "multipartmaxparts=100", values: 101, wantErr: ErrMessageTooLarge},
-+		{godebug: "multipartmaxheaders=100", files: 2, extraKeysPerFile: 48},
-+		{godebug: "multipartmaxheaders=100", files: 2, extraKeysPerFile: 50, wantErr: ErrMessageTooLarge},
-+	} {
-+		name := fmt.Sprintf("values=%v/files=%v/extraKeysPerFile=%v", test.values, test.files, test.extraKeysPerFile)
-+		if test.godebug != "" {
-+			name += fmt.Sprintf("/godebug=%v", test.godebug)
-+		}
-+		t.Run(name, func(t *testing.T) {
-+			if test.godebug != "" {
-+				t.Setenv("GODEBUG", test.godebug)
-+			}
-+			var buf bytes.Buffer
-+			fw := NewWriter(&buf)
-+			for i := 0; i < test.values; i++ {
-+				w, _ := fw.CreateFormField(fmt.Sprintf("field%v", i))
-+				fmt.Fprintf(w, "value %v", i)
-+			}
-+			for i := 0; i < test.files; i++ {
-+				h := make(textproto.MIMEHeader)
-+				h.Set("Content-Disposition",
-+					fmt.Sprintf(`form-data; name="file%v"; filename="file%v"`, i, i))
-+				h.Set("Content-Type", "application/octet-stream")
-+				for j := 0; j < test.extraKeysPerFile; j++ {
-+					h.Set(fmt.Sprintf("k%v", j), "v")
-+				}
-+				w, _ := fw.CreatePart(h)
-+				fmt.Fprintf(w, "value %v", i)
-+			}
-+			if err := fw.Close(); err != nil {
-+				t.Fatal(err)
-+			}
-+			fr := NewReader(bytes.NewReader(buf.Bytes()), fw.Boundary())
-+			form, err := fr.ReadForm(1 << 10)
-+			if err == nil {
-+				defer form.RemoveAll()
-+			}
-+			if err != test.wantErr {
-+				t.Errorf("ReadForm = %v, want %v", err, test.wantErr)
-+			}
-+		})
-+	}
-+}
-+
- func BenchmarkReadForm(b *testing.B) {
- 	for _, test := range []struct {
- 		name string
-diff --git a/src/mime/multipart/multipart.go b/src/mime/multipart/multipart.go
-index 19fe0ea..80acabc 100644
---- a/src/mime/multipart/multipart.go
-+++ b/src/mime/multipart/multipart.go
-@@ -16,11 +16,13 @@ import (
- 	"bufio"
- 	"bytes"
- 	"fmt"
-+	"internal/godebug"
- 	"io"
- 	"mime"
- 	"mime/quotedprintable"
- 	"net/textproto"
- 	"path/filepath"
-+	"strconv"
- 	"strings"
- )
- 
-@@ -128,12 +130,12 @@ func (r *stickyErrorReader) Read(p []byte) (n int, _ error) {
- 	return n, r.err
- }
- 
--func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize int64) (*Part, error) {
-+func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize, maxMIMEHeaders int64) (*Part, error) {
- 	bp := &Part{
- 		Header: make(map[string][]string),
- 		mr:     mr,
- 	}
--	if err := bp.populateHeaders(maxMIMEHeaderSize); err != nil {
-+	if err := bp.populateHeaders(maxMIMEHeaderSize, maxMIMEHeaders); err != nil {
- 		return nil, err
- 	}
- 	bp.r = partReader{bp}
-@@ -149,9 +151,9 @@ func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize int64) (*Part, error) {
- 	return bp, nil
- }
- 
--func (bp *Part) populateHeaders(maxMIMEHeaderSize int64) error {
-+func (bp *Part) populateHeaders(maxMIMEHeaderSize, maxMIMEHeaders int64) error {
- 	r := textproto.NewReader(bp.mr.bufReader)
--	header, err := readMIMEHeader(r, maxMIMEHeaderSize)
-+	header, err := readMIMEHeader(r, maxMIMEHeaderSize, maxMIMEHeaders)
- 	if err == nil {
- 		bp.Header = header
- 	}
-@@ -313,6 +315,19 @@ type Reader struct {
- // including header keys, values, and map overhead.
- const maxMIMEHeaderSize = 10 << 20
- 
-+func maxMIMEHeaders() int64 {
-+	// multipartMaxHeaders is the maximum number of header entries NextPart will return,
-+	// as well as the maximum combined total of header entries Reader.ReadForm will return
-+	// in FileHeaders.
-+	multipartMaxHeaders := godebug.Get("multipartmaxheaders")
-+	if multipartMaxHeaders != "" {
-+		if v, err := strconv.ParseInt(multipartMaxHeaders, 10, 64); err == nil && v >= 0 {
-+			return v
-+		}
-+	}
-+	return 10000
-+}
-+
- // NextPart returns the next part in the multipart or an error.
- // When there are no more parts, the error io.EOF is returned.
- //
-@@ -320,7 +335,7 @@ const maxMIMEHeaderSize = 10 << 20
- // has a value of "quoted-printable", that header is instead
- // hidden and the body is transparently decoded during Read calls.
- func (r *Reader) NextPart() (*Part, error) {
--	return r.nextPart(false, maxMIMEHeaderSize)
-+	return r.nextPart(false, maxMIMEHeaderSize, maxMIMEHeaders())
- }
- 
- // NextRawPart returns the next part in the multipart or an error.
-@@ -329,10 +344,10 @@ func (r *Reader) NextPart() (*Part, error) {
- // Unlike NextPart, it does not have special handling for
- // "Content-Transfer-Encoding: quoted-printable".
- func (r *Reader) NextRawPart() (*Part, error) {
--	return r.nextPart(true, maxMIMEHeaderSize)
-+	return r.nextPart(true, maxMIMEHeaderSize, maxMIMEHeaders())
- }
- 
--func (r *Reader) nextPart(rawPart bool, maxMIMEHeaderSize int64) (*Part, error) {
-+func (r *Reader) nextPart(rawPart bool, maxMIMEHeaderSize, maxMIMEHeaders int64) (*Part, error) {
- 	if r.currentPart != nil {
- 		r.currentPart.Close()
- 	}
-@@ -357,7 +372,7 @@ func (r *Reader) nextPart(rawPart bool, maxMIMEHeaderSize int64) (*Part, error)
- 
- 		if r.isBoundaryDelimiterLine(line) {
- 			r.partsRead++
--			bp, err := newPart(r, rawPart, maxMIMEHeaderSize)
-+			bp, err := newPart(r, rawPart, maxMIMEHeaderSize, maxMIMEHeaders)
- 			if err != nil {
- 				return nil, err
- 			}
-diff --git a/src/mime/multipart/readmimeheader.go b/src/mime/multipart/readmimeheader.go
-index 6836928..25aa6e2 100644
---- a/src/mime/multipart/readmimeheader.go
-+++ b/src/mime/multipart/readmimeheader.go
-@@ -11,4 +11,4 @@ import (
- // readMIMEHeader is defined in package net/textproto.
- //
- //go:linkname readMIMEHeader net/textproto.readMIMEHeader
--func readMIMEHeader(r *textproto.Reader, lim int64) (textproto.MIMEHeader, error)
-+func readMIMEHeader(r *textproto.Reader, maxMemory, maxHeaders int64) (textproto.MIMEHeader, error)
-diff --git a/src/net/textproto/reader.go b/src/net/textproto/reader.go
-index 9af4c49..c6569c8 100644
---- a/src/net/textproto/reader.go
-+++ b/src/net/textproto/reader.go
-@@ -483,12 +483,12 @@ func (r *Reader) ReadDotLines() ([]string, error) {
- //	}
- //
- func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {
--	return readMIMEHeader(r, math.MaxInt64)
-+	return readMIMEHeader(r, math.MaxInt64, math.MaxInt64)
- }
- 
- // readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.
- // It is called by the mime/multipart package.
--func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
-+func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error) {
- 	// Avoid lots of small slice allocations later by allocating one
- 	// large one ahead of time which we'll cut up into smaller
- 	// slices. If this isn't big enough later, we allocate small ones.
-@@ -506,7 +506,7 @@ func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
- 	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
- 	// MIMEHeaders average about 200 bytes per entry.
--	lim -= 400
-+	maxMemory -= 400
- 	const mapEntryOverhead = 200
- 
- 	// The first line cannot start with a leading space.
-@@ -538,6 +538,11 @@ func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 			continue
- 		}
- 
-+		maxHeaders--
-+		if maxHeaders < 0 {
-+			return nil, errors.New("message too large")
-+		}
-+
- 		// backport 5c55ac9bf1e5f779220294c843526536605f42ab
- 		//
- 		// value is computed as
-@@ -557,11 +562,11 @@ func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 
- 		vv := m[key]
- 		if vv == nil {
--			lim -= int64(len(key))
--			lim -= mapEntryOverhead
-+			maxMemory -= int64(len(key))
-+			maxMemory -= mapEntryOverhead
- 		}
--		lim -= int64(len(value))
--		if lim < 0 {
-+		maxMemory -= int64(len(value))
-+		if maxMemory < 0 {
- 			// TODO: This should be a distinguishable error (ErrMessageTooLarge)
- 			// to allow mime/multipart to detect it.
- 			return m, errors.New("message too large")
--- 
-2.35.5
-
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-24540.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-24540.patch
deleted file mode 100644
index 7e6e871e38..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-24540.patch
+++ /dev/null
@@ -1,93 +0,0 @@
-From 2305cdb2aa5ac8e9960bd64e548a119c7dd87530 Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Tue, 11 Apr 2023 16:27:43 +0100
-Subject: [PATCH] html/template: handle all JS whitespace characters
-
-Rather than just a small set. Character class as defined by \s [0].
-
-Thanks to Juho Nurminen of Mattermost for reporting this.
-
-For #59721
-Fixes  #59813
-Fixes CVE-2023-24540
-
-[0] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes
-
-Change-Id: I56d4fa1ef08125b417106ee7dbfb5b0923b901ba
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1821459
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1851497
-Run-TryBot: Damien Neil <dneil@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/491355
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-Reviewed-by: Carlos Amedee <carlos@golang.org>
-TryBot-Bypass: Carlos Amedee <carlos@golang.org>
-Run-TryBot: Carlos Amedee <carlos@golang.org>
-
-CVE: CVE-2023-24540
-Upstream-Status: Backport [https://github.com/golang/go/commit/ce7bd33345416e6d8cac901792060591cafc2797]
-
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/html/template/js.go      |  8 +++++++-
- src/html/template/js_test.go | 11 +++++++----
- 2 files changed, 14 insertions(+), 5 deletions(-)
-
-diff --git a/src/html/template/js.go b/src/html/template/js.go
-index b888eaf..35994f0 100644
---- a/src/html/template/js.go
-+++ b/src/html/template/js.go
-@@ -13,6 +13,11 @@ import (
- 	"unicode/utf8"
- )
- 
-+// jsWhitespace contains all of the JS whitespace characters, as defined
-+// by the \s character class.
-+// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes.
-+const jsWhitespace = "\f\n\r\t\v\u0020\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff"
-+
- // nextJSCtx returns the context that determines whether a slash after the
- // given run of tokens starts a regular expression instead of a division
- // operator: / or /=.
-@@ -26,7 +31,8 @@ import (
- // JavaScript 2.0 lexical grammar and requires one token of lookbehind:
- // https://www.mozilla.org/js/language/js20-2000-07/rationale/syntax.html
- func nextJSCtx(s []byte, preceding jsCtx) jsCtx {
--	s = bytes.TrimRight(s, "\t\n\f\r \u2028\u2029")
-+	// Trim all JS whitespace characters
-+	s = bytes.TrimRight(s, jsWhitespace)
- 	if len(s) == 0 {
- 		return preceding
- 	}
-diff --git a/src/html/template/js_test.go b/src/html/template/js_test.go
-index d7ee47b..8f5d76d 100644
---- a/src/html/template/js_test.go
-+++ b/src/html/template/js_test.go
-@@ -81,14 +81,17 @@ func TestNextJsCtx(t *testing.T) {
- 		{jsCtxDivOp, "0"},
- 		// Dots that are part of a number are div preceders.
- 		{jsCtxDivOp, "0."},
-+		// Some JS interpreters treat NBSP as a normal space, so
-+		// we must too in order to properly escape things.
-+		{jsCtxRegexp, "=\u00A0"},
- 	}
- 
- 	for _, test := range tests {
--		if nextJSCtx([]byte(test.s), jsCtxRegexp) != test.jsCtx {
--			t.Errorf("want %s got %q", test.jsCtx, test.s)
-+		if ctx := nextJSCtx([]byte(test.s), jsCtxRegexp); ctx != test.jsCtx {
-+			t.Errorf("%q: want %s got %s", test.s, test.jsCtx, ctx)
- 		}
--		if nextJSCtx([]byte(test.s), jsCtxDivOp) != test.jsCtx {
--			t.Errorf("want %s got %q", test.jsCtx, test.s)
-+		if ctx := nextJSCtx([]byte(test.s), jsCtxDivOp); ctx != test.jsCtx {
-+			t.Errorf("%q: want %s got %s", test.s, test.jsCtx, ctx)
- 		}
- 	}
- 
--- 
-2.40.0
-
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-29402.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-29402.patch
deleted file mode 100644
index bf1fbbe0d6..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-29402.patch
+++ /dev/null
@@ -1,194 +0,0 @@
-From  4dae3bbe0e6a5700037bb996ae84d6f457c4f58a Mon Sep 17 00:00:00 2001
-From: Bryan C. Mills <bcmills@google.com>
-Date: Fri, 12 May 2023 14:15:16 -0400
-Subject: [PATCH] cmd/go: disallow package directories containing newlines
-
-Directory or file paths containing newlines may cause tools (such as
-cmd/cgo) that emit "//line" or "#line" -directives to write part of
-the path into non-comment lines in generated source code. If those
-lines contain valid Go code, it may be injected into the resulting
-binary.
-
-(Note that Go import paths and file paths within module zip files
-already could not contain newlines.)
-
-Thanks to Juho Nurminen of Mattermost for reporting this issue.
-
-Fixes #60167.
-Fixes CVE-2023-29402.
-
-Change-Id: I64572e9f454bce7b685d00e2e6a1c96cd33d53df
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1882606
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Russ Cox <rsc@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/501226
-Run-TryBot: David Chase <drchase@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Michael Knyszek <mknyszek@google.com>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/4dae3bbe0e6a5700037bb996ae84d6f457c4f58a]
-CVE: CVE-2023-29402
-
-Signed-off-by: Archana Polampalli <archana.polampalli@windriver.com>
----
- src/cmd/go/internal/load/pkg.go               |   4 +
- src/cmd/go/internal/work/exec.go              |   6 ++
- src/cmd/go/script_test.go                     |   1 +
- .../go/testdata/script/build_cwd_newline.txt  | 100 ++++++++++++++++++
- 4 files changed, 111 insertions(+)
- create mode 100644 src/cmd/go/testdata/script/build_cwd_newline.txt
-
-diff --git a/src/cmd/go/internal/load/pkg.go b/src/cmd/go/internal/load/pkg.go
-index a83cc9a..d4da86d 100644
---- a/src/cmd/go/internal/load/pkg.go
-+++ b/src/cmd/go/internal/load/pkg.go
-@@ -1897,6 +1897,10 @@ func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *
-		setError(fmt.Errorf("invalid input directory name %q", name))
-		return
-	}
-+	if strings.ContainsAny(p.Dir, "\r\n") {
-+		setError(fmt.Errorf("invalid package directory %q", p.Dir))
-+		return
-+	}
-
-	// Build list of imported packages and full dependency list.
-	imports := make([]*Package, 0, len(p.Imports))
-diff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go
-index b35caa4..b1bf347 100644
---- a/src/cmd/go/internal/work/exec.go
-+++ b/src/cmd/go/internal/work/exec.go
-@@ -505,6 +505,12 @@ func (b *Builder) build(ctx context.Context, a *Action) (err error) {
-		b.Print(a.Package.ImportPath + "\n")
-	}
-
-+	if p.Error != nil {
-+		// Don't try to build anything for packages with errors. There may be a
-+		// problem with the inputs that makes the package unsafe to build.
-+		return p.Error
-+	}
-+
-	if a.Package.BinaryOnly {
-		p.Stale = true
-		p.StaleReason = "binary-only packages are no longer supported"
-diff --git a/src/cmd/go/script_test.go b/src/cmd/go/script_test.go
-index c0156d0..ce4ff37 100644
---- a/src/cmd/go/script_test.go
-+++ b/src/cmd/go/script_test.go
-@@ -182,6 +182,7 @@ func (ts *testScript) setup() {
-		"devnull=" + os.DevNull,
-		"goversion=" + goVersion(ts),
-		":=" + string(os.PathListSeparator),
-+		"newline=\n",
-	}
-	if !testenv.HasExternalNetwork() {
-		ts.env = append(ts.env, "TESTGONETWORK=panic", "TESTGOVCS=panic")
-diff --git a/src/cmd/go/testdata/script/build_cwd_newline.txt b/src/cmd/go/testdata/script/build_cwd_newline.txt
-new file mode 100644
-index 0000000..61c6966
---- /dev/null
-+++ b/src/cmd/go/testdata/script/build_cwd_newline.txt
-@@ -0,0 +1,100 @@
-+[windows] skip 'filesystem normalizes / to \'
-+[plan9] skip 'filesystem disallows \n in paths'
-+
-+# If the directory path containing a package to be built includes a newline,
-+# the go command should refuse to even try to build the package.
-+
-+env DIR=$WORK${/}${newline}'package main'${newline}'func main() { panic("uh-oh")'${newline}'/*'
-+
-+mkdir $DIR
-+cd $DIR
-+exec pwd
-+cp $WORK/go.mod ./go.mod
-+cp $WORK/main.go ./main.go
-+cp $WORK/main_test.go ./main_test.go
-+
-+! go build -o $devnull .
-+stderr 'package example: invalid package directory .*uh-oh'
-+
-+! go build -o $devnull main.go
-+stderr 'package command-line-arguments: invalid package directory .*uh-oh'
-+
-+! go run .
-+stderr 'package example: invalid package directory .*uh-oh'
-+
-+! go run main.go
-+stderr 'package command-line-arguments: invalid package directory .*uh-oh'
-+
-+! go test .
-+stderr 'package example: invalid package directory .*uh-oh'
-+
-+! go test -v main.go main_test.go
-+stderr 'package command-line-arguments: invalid package directory .*uh-oh'
-+
-+
-+# Since we do preserve $PWD (or set it appropriately) for commands, and we do
-+# not resolve symlinks unnecessarily, referring to the contents of the unsafe
-+# directory via a safe symlink should be ok, and should not inject the data from
-+# the symlink target path.
-+
-+[!symlink] stop 'remainder of test checks symlink behavior'
-+[short] stop 'links and runs binaries'
-+
-+symlink $WORK${/}link -> $DIR
-+
-+go run $WORK${/}link${/}main.go
-+! stdout panic
-+! stderr panic
-+stderr '^ok$'
-+
-+go test -v $WORK${/}link${/}main.go $WORK${/}link${/}main_test.go
-+! stdout panic
-+! stderr panic
-+stdout '^ok$'   # 'go test' combines the test's stdout into stderr
-+
-+cd $WORK/link
-+
-+! go run $DIR${/}main.go
-+stderr 'package command-line-arguments: invalid package directory .*uh-oh'
-+
-+go run .
-+! stdout panic
-+! stderr panic
-+stderr '^ok$'
-+
-+go run main.go
-+! stdout panic
-+! stderr panic
-+stderr '^ok$'
-+
-+go test -v
-+! stdout panic
-+! stderr panic
-+stdout '^ok$'  # 'go test' combines the test's stdout into stderr
-+
-+go test -v .
-+! stdout panic
-+! stderr panic
-+stdout '^ok$'  # 'go test' combines the test's stdout into stderr
-+
-+
-+-- $WORK/go.mod --
-+module example
-+go 1.19
-+-- $WORK/main.go --
-+package main
-+
-+import "C"
-+
-+func main() {
-+	/* nothing here */
-+	println("ok")
-+}
-+-- $WORK/main_test.go --
-+package main
-+
-+import "testing"
-+
-+func TestMain(*testing.M) {
-+	main()
-+}
---
-2.40.0
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-29404.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-29404.patch
deleted file mode 100644
index c6beced884..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-29404.patch
+++ /dev/null
@@ -1,78 +0,0 @@
-From bbeb55f5faf93659e1cfd6ab073ab3c9d126d195 Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Fri, 5 May 2023 13:10:34 -0700
-Subject: [PATCH] cmd/go: enforce flags with non-optional arguments
-
-Enforce that linker flags which expect arguments get them, otherwise it
-may be possible to smuggle unexpected flags through as the linker can
-consume what looks like a flag as an argument to a preceding flag (i.e.
-"-Wl,-O -Wl,-R,-bad-flag" is interpreted as "-O=-R -bad-flag"). Also be
-somewhat more restrictive in the general format of some flags.
-
-Thanks to Juho Nurminen of Mattermost for reporting this issue.
-
-Fixes #60305
-Fixes CVE-2023-29404
-
-Change-Id: I913df78a692cee390deefc3cd7d8f5b031524fc9
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1876275
-Reviewed-by: Ian Lance Taylor <iant@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/501225
-Run-TryBot: David Chase <drchase@google.com>
-Reviewed-by: Michael Knyszek <mknyszek@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/bbeb55f5faf93659e1cfd6ab073ab3c9d126d195]
-CVE: CVE-2023-29404
-
-Signed-off-by: Archana Polampalli <archana.polampalli@windriver.com>
----
- src/cmd/go/internal/work/security.go      | 6 +++---
- src/cmd/go/internal/work/security_test.go | 5 +++++
- 2 files changed, 8 insertions(+), 3 deletions(-)
-
-diff --git a/src/cmd/go/internal/work/security.go b/src/cmd/go/internal/work/security.go
-index e9b9f6c..91e6e4c 100644
---- a/src/cmd/go/internal/work/security.go
-+++ b/src/cmd/go/internal/work/security.go
-@@ -179,10 +179,10 @@ var validLinkerFlags = []*lazyregexp.Regexp{
-	re(`-Wl,-berok`),
-	re(`-Wl,-Bstatic`),
-	re(`-Wl,-Bsymbolic-functions`),
--	re(`-Wl,-O([^@,\-][^,]*)?`),
-+	re(`-Wl,-O[0-9]+`),
-	re(`-Wl,-d[ny]`),
-	re(`-Wl,--disable-new-dtags`),
--	re(`-Wl,-e[=,][a-zA-Z0-9]*`),
-+	re(`-Wl,-e[=,][a-zA-Z0-9]+`),
-	re(`-Wl,--enable-new-dtags`),
-	re(`-Wl,--end-group`),
-	re(`-Wl,--(no-)?export-dynamic`),
-@@ -191,7 +191,7 @@ var validLinkerFlags = []*lazyregexp.Regexp{
-	re(`-Wl,--hash-style=(sysv|gnu|both)`),
-	re(`-Wl,-headerpad_max_install_names`),
-	re(`-Wl,--no-undefined`),
--	re(`-Wl,-R([^@\-][^,@]*$)`),
-+	re(`-Wl,-R,?([^@\-,][^,@]*$)`),
-	re(`-Wl,--just-symbols[=,]([^,@\-][^,@]+)`),
-	re(`-Wl,-rpath(-link)?[=,]([^,@\-][^,]+)`),
-	re(`-Wl,-s`),
-diff --git a/src/cmd/go/internal/work/security_test.go b/src/cmd/go/internal/work/security_test.go
-index 8d4be0a..3616548 100644
---- a/src/cmd/go/internal/work/security_test.go
-+++ b/src/cmd/go/internal/work/security_test.go
-@@ -227,6 +227,11 @@ var badLinkerFlags = [][]string{
-	{"-Wl,-R,@foo"},
-	{"-Wl,--just-symbols,@foo"},
-	{"../x.o"},
-+	{"-Wl,-R,"},
-+	{"-Wl,-O"},
-+	{"-Wl,-e="},
-+	{"-Wl,-e,"},
-+	{"-Wl,-R,-flag"},
- }
-
- func TestCheckLinkerFlags(t *testing.T) {
---
-2.40.0
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-29405.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-29405.patch
deleted file mode 100644
index d806e1e67d..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-29405.patch
+++ /dev/null
@@ -1,109 +0,0 @@
-From 6d8af00a630aa51134e54f0f321658621c6410f0 Mon Sep 17 00:00:00 2001
-From: Ian Lance Taylor <iant@golang.org>
-Date: Thu, 4 May 2023 14:06:39 -0700
-Subject: [PATCH] cmd/go,cmd/cgo: in _cgo_flags use one line per flag
-
-The flags that we recorded in _cgo_flags did not use any quoting,
-so a flag containing embedded spaces was mishandled.
-Change the _cgo_flags format to put each flag on a separate line.
-That is a simple format that does not require any quoting.
-
-As far as I can tell only cmd/go uses _cgo_flags, and it is only
-used for gccgo. If this patch doesn't cause any trouble, then
-in the next release we can change to only using _cgo_flags for gccgo.
-
-Thanks to Juho Nurminen of Mattermost for reporting this issue.
-
-Fixes #60306
-Fixes CVE-2023-29405
-
-Change-Id: I81fb5337db8a22e1f4daca22ceff4b79b96d0b4f
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1875094
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/501224
-Reviewed-by: Ian Lance Taylor <iant@google.com>
-Run-TryBot: David Chase <drchase@google.com>
-Reviewed-by: Michael Knyszek <mknyszek@google.com>
-Reviewed-by: Roland Shoemaker <roland@golang.org>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/6d8af00a630aa51134e54f0f321658621c6410f0]
-CVE: CVE-2023-29405
-
-Signed-off-by: Archana Polampalli <archana.polampalli@windriver.com>
----
- src/cmd/cgo/out.go                            |  4 +++-
- src/cmd/go/internal/work/gccgo.go             | 14 ++++++-------
- .../go/testdata/script/gccgo_link_ldflags.txt | 20 +++++++++++++++++++
- 3 files changed, 29 insertions(+), 9 deletions(-)
- create mode 100644 src/cmd/go/testdata/script/gccgo_link_ldflags.txt
-
-diff --git a/src/cmd/cgo/out.go b/src/cmd/cgo/out.go
-index 94152f4..62e6528 100644
---- a/src/cmd/cgo/out.go
-+++ b/src/cmd/cgo/out.go
-@@ -47,7 +47,9 @@ func (p *Package) writeDefs() {
-
-	fflg := creat(*objDir + "_cgo_flags")
-	for k, v := range p.CgoFlags {
--		fmt.Fprintf(fflg, "_CGO_%s=%s\n", k, strings.Join(v, " "))
-+		for _, arg := range v {
-+			fmt.Fprintf(fflg, "_CGO_%s=%s\n", k, arg)
-+		}
-		if k == "LDFLAGS" && !*gccgo {
-			for _, arg := range v {
-				fmt.Fprintf(fgo2, "//go:cgo_ldflag %q\n", arg)
-diff --git a/src/cmd/go/internal/work/gccgo.go b/src/cmd/go/internal/work/gccgo.go
-index 1499536..bb4be2f 100644
---- a/src/cmd/go/internal/work/gccgo.go
-+++ b/src/cmd/go/internal/work/gccgo.go
-@@ -283,14 +283,12 @@ func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string
-		const ldflagsPrefix = "_CGO_LDFLAGS="
-		for _, line := range strings.Split(string(flags), "\n") {
-			if strings.HasPrefix(line, ldflagsPrefix) {
--				newFlags := strings.Fields(line[len(ldflagsPrefix):])
--				for _, flag := range newFlags {
--					// Every _cgo_flags file has -g and -O2 in _CGO_LDFLAGS
--					// but they don't mean anything to the linker so filter
--					// them out.
--					if flag != "-g" && !strings.HasPrefix(flag, "-O") {
--						cgoldflags = append(cgoldflags, flag)
--					}
-+				flag := line[len(ldflagsPrefix):]
-+				// Every _cgo_flags file has -g and -O2 in _CGO_LDFLAGS
-+				// but they don't mean anything to the linker so filter
-+				// them out.
-+				if flag != "-g" && !strings.HasPrefix(flag, "-O") {
-+					cgoldflags = append(cgoldflags, flag)
-				}
-			}
-		}
-diff --git a/src/cmd/go/testdata/script/gccgo_link_ldflags.txt b/src/cmd/go/testdata/script/gccgo_link_ldflags.txt
-new file mode 100644
-index 0000000..4e91ae5
---- /dev/null
-+++ b/src/cmd/go/testdata/script/gccgo_link_ldflags.txt
-@@ -0,0 +1,20 @@
-+# Test that #cgo LDFLAGS are properly quoted.
-+# The #cgo LDFLAGS below should pass a string with spaces to -L,
-+# as though searching a directory with a space in its name.
-+# It should not pass --nosuchoption to the external linker.
-+
-+[!cgo] skip
-+
-+go build
-+
-+[!exec:gccgo] skip
-+
-+go build -compiler gccgo
-+
-+-- go.mod --
-+module m
-+-- cgo.go --
-+package main
-+// #cgo LDFLAGS: -L "./ -Wl,--nosuchoption"
-+import "C"
-+func main() {}
---
-2.40.0
diff --git a/meta/recipes-devtools/go/go-1.19/CVE-2023-29409.patch b/meta/recipes-devtools/go/go-1.19/CVE-2023-29409.patch
deleted file mode 100644
index 38451f7555..0000000000
--- a/meta/recipes-devtools/go/go-1.19/CVE-2023-29409.patch
+++ /dev/null
@@ -1,175 +0,0 @@
-From 2300f7ef07718f6be4d8aa8486c7de99836e233f Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Wed, 23 Aug 2023 12:03:43 +0000
-Subject: [PATCH] crypto/tls: restrict RSA keys in certificates to <= 8192 bits
-
-Extremely large RSA keys in certificate chains can cause a client/server
-to expend significant CPU time verifying signatures. Limit this by
-restricting the size of RSA keys transmitted during handshakes to <=
-8192 bits.
-
-Based on a survey of publicly trusted RSA keys, there are currently only
-three certificates in circulation with keys larger than this, and all
-three appear to be test certificates that are not actively deployed. It
-is possible there are larger keys in use in private PKIs, but we target
-the web PKI, so causing breakage here in the interests of increasing the
-default safety of users of crypto/tls seems reasonable.
-
-Thanks to Mateusz Poliwczak for reporting this issue.
-
-Updates #61460
-Fixes #61579
-Fixes CVE-2023-29409
-
-Change-Id: Ie35038515a649199a36a12fc2c5df3af855dca6c
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1912161
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-(cherry picked from commit d865c715d92887361e4bd5596e19e513f27781b7)
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1965487
-Reviewed-on: https://go-review.googlesource.com/c/go/+/514915
-Run-TryBot: David Chase <drchase@google.com>
-Reviewed-by: Matthew Dempsky <mdempsky@google.com>
-TryBot-Bypass: David Chase <drchase@google.com>
-
-CVE: CVE-2023-29409
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/2300f7ef07718f6be4d8aa8486c7de99836e233f]
-
-Signed-off-by: Soumya Sambu <soumya.sambu@windriver.com>
----
- src/crypto/tls/handshake_client.go      |  8 +++
- src/crypto/tls/handshake_client_test.go | 78 +++++++++++++++++++++++++
- src/crypto/tls/handshake_server.go      |  4 ++
- 3 files changed, 90 insertions(+)
-
-diff --git a/src/crypto/tls/handshake_client.go b/src/crypto/tls/handshake_client.go
-index 85622f1..828d2cb 100644
---- a/src/crypto/tls/handshake_client.go
-+++ b/src/crypto/tls/handshake_client.go
-@@ -852,6 +852,10 @@ func (hs *clientHandshakeState) sendFinished(out []byte) error {
-	return nil
- }
-
-+// maxRSAKeySize is the maximum RSA key size in bits that we are willing
-+// to verify the signatures of during a TLS handshake.
-+const maxRSAKeySize = 8192
-+
- // verifyServerCertificate parses and verifies the provided chain, setting
- // c.verifiedChains and c.peerCertificates or sending the appropriate alert.
- func (c *Conn) verifyServerCertificate(certificates [][]byte) error {
-@@ -862,6 +866,10 @@ func (c *Conn) verifyServerCertificate(certificates [][]byte) error {
-			c.sendAlert(alertBadCertificate)
-			return errors.New("tls: failed to parse certificate from server: " + err.Error())
-		}
-+		if cert.PublicKeyAlgorithm == x509.RSA && cert.PublicKey.(*rsa.PublicKey).N.BitLen() > maxRSAKeySize {
-+			c.sendAlert(alertBadCertificate)
-+			return fmt.Errorf("tls: server sent certificate containing RSA key larger than %d bits", maxRSAKeySize)
-+		}
-		certs[i] = cert
-	}
-
-diff --git a/src/crypto/tls/handshake_client_test.go b/src/crypto/tls/handshake_client_test.go
-index 0228745..d581cb1 100644
---- a/src/crypto/tls/handshake_client_test.go
-+++ b/src/crypto/tls/handshake_client_test.go
-@@ -2595,3 +2595,81 @@ func TestClientHandshakeContextCancellation(t *testing.T) {
-		t.Error("Client connection was not closed when the context was canceled")
-	}
- }
-+
-+// discardConn wraps a net.Conn but discards all writes, but reports that they happened.
-+type discardConn struct {
-+	net.Conn
-+}
-+
-+func (dc *discardConn) Write(data []byte) (int, error) {
-+	return len(data), nil
-+}
-+
-+// largeRSAKeyCertPEM contains a 8193 bit RSA key
-+const largeRSAKeyCertPEM = `-----BEGIN CERTIFICATE-----
-+MIIInjCCBIWgAwIBAgIBAjANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDEwd0ZXN0
-+aW5nMB4XDTIzMDYwNzIxMjMzNloXDTIzMDYwNzIzMjMzNlowEjEQMA4GA1UEAxMH
-+dGVzdGluZzCCBCIwDQYJKoZIhvcNAQEBBQADggQPADCCBAoCggQBAWdHsf6Rh2Ca
-+n2SQwn4t4OQrOjbLLdGE1pM6TBKKrHUFy62uEL8atNjlcfXIsa4aEu3xNGiqxqur
-+ZectlkZbm0FkaaQ1Wr9oikDY3KfjuaXdPdO/XC/h8AKNxlDOylyXwUSK/CuYb+1j
-+gy8yF5QFvVfwW/xwTlHmhUeSkVSQPosfQ6yXNNsmMzkd+ZPWLrfq4R+wiNtwYGu0
-+WSBcI/M9o8/vrNLnIppoiBJJ13j9CR1ToEAzOFh9wwRWLY10oZhoh1ONN1KQURx4
-+qedzvvP2DSjZbUccdvl2rBGvZpzfOiFdm1FCnxB0c72Cqx+GTHXBFf8bsa7KHky9
-+sNO1GUanbq17WoDNgwbY6H51bfShqv0CErxatwWox3we4EcAmFHPVTCYL1oWVMGo
-+a3Eth91NZj+b/nGhF9lhHKGzXSv9brmLLkfvM1jA6XhNhA7BQ5Vz67lj2j3XfXdh
-+t/BU5pBXbL4Ut4mIhT1YnKXAjX2/LF5RHQTE8Vwkx5JAEKZyUEGOReD/B+7GOrLp
-+HduMT9vZAc5aR2k9I8qq1zBAzsL69lyQNAPaDYd1BIAjUety9gAYaSQffCgAgpRO
-+Gt+DYvxS+7AT/yEd5h74MU2AH7KrAkbXOtlwupiGwhMVTstncDJWXMJqbBhyHPF8
-+3UmZH0hbL4PYmzSj9LDWQQXI2tv6vrCpfts3Cqhqxz9vRpgY7t1Wu6l/r+KxYYz3
-+1pcGpPvRmPh0DJm7cPTiXqPnZcPt+ulSaSdlxmd19OnvG5awp0fXhxryZVwuiT8G
-+VDkhyARrxYrdjlINsZJZbQjO0t8ketXAELJOnbFXXzeCOosyOHkLwsqOO96AVJA8
-+45ZVL5m95ClGy0RSrjVIkXsxTAMVG6SPAqKwk6vmTdRGuSPS4rhgckPVDHmccmuq
-+dfnT2YkX+wB2/M3oCgU+s30fAHGkbGZ0pCdNbFYFZLiH0iiMbTDl/0L/z7IdK0nH
-+GLHVE7apPraKC6xl6rPWsD2iSfrmtIPQa0+rqbIVvKP5JdfJ8J4alI+OxFw/znQe
-+V0/Rez0j22Fe119LZFFSXhRv+ZSvcq20xDwh00mzcumPWpYuCVPozA18yIhC9tNn
-+ALHndz0tDseIdy9vC71jQWy9iwri3ueN0DekMMF8JGzI1Z6BAFzgyAx3DkHtwHg7
-+B7qD0jPG5hJ5+yt323fYgJsuEAYoZ8/jzZ01pkX8bt+UsVN0DGnSGsI2ktnIIk3J
-+l+8krjmUy6EaW79nITwoOqaeHOIp8m3UkjEcoKOYrzHRKqRy+A09rY+m/cAQaafW
-+4xp0Zv7qZPLwnu0jsqB4jD8Ll9yPB02ndsoV6U5PeHzTkVhPml19jKUAwFfs7TJg
-+kXy+/xFhYVUCAwEAATANBgkqhkiG9w0BAQsFAAOCBAIAAQnZY77pMNeypfpba2WK
-+aDasT7dk2JqP0eukJCVPTN24Zca+xJNPdzuBATm/8SdZK9lddIbjSnWRsKvTnO2r
-+/rYdlPf3jM5uuJtb8+Uwwe1s+gszelGS9G/lzzq+ehWicRIq2PFcs8o3iQMfENiv
-+qILJ+xjcrvms5ZPDNahWkfRx3KCg8Q+/at2n5p7XYjMPYiLKHnDC+RE2b1qT20IZ
-+FhuK/fTWLmKbfYFNNga6GC4qcaZJ7x0pbm4SDTYp0tkhzcHzwKhidfNB5J2vNz6l
-+Ur6wiYwamFTLqcOwWo7rdvI+sSn05WQBv0QZlzFX+OAu0l7WQ7yU+noOxBhjvHds
-+14+r9qcQZg2q9kG+evopYZqYXRUNNlZKo9MRBXhfrISulFAc5lRFQIXMXnglvAu+
-+Ipz2gomEAOcOPNNVldhKAU94GAMJd/KfN0ZP7gX3YvPzuYU6XDhag5RTohXLm18w
-+5AF+ES3DOQ6ixu3DTf0D+6qrDuK+prdX8ivcdTQVNOQ+MIZeGSc6NWWOTaMGJ3lg
-+aZIxJUGdo6E7GBGiC1YTjgFKFbHzek1LRTh/LX3vbSudxwaG0HQxwsU9T4DWiMqa
-+Fkf2KteLEUA6HrR+0XlAZrhwoqAmrJ+8lCFX3V0gE9lpENfVHlFXDGyx10DpTB28
-+DdjnY3F7EPWNzwf9P3oNT69CKW3Bk6VVr3ROOJtDxVu1ioWo3TaXltQ0VOnap2Pu
-+sa5wfrpfwBDuAS9JCDg4ttNp2nW3F7tgXC6xPqw5pvGwUppEw9XNrqV8TZrxduuv
-+rQ3NyZ7KSzIpmFlD3UwV/fGfz3UQmHS6Ng1evrUID9DjfYNfRqSGIGjDfxGtYD+j
-+Z1gLJZuhjJpNtwBkKRtlNtrCWCJK2hidK/foxwD7kwAPo2I9FjpltxCRywZUs07X
-+KwXTfBR9v6ij1LV6K58hFS+8ezZyZ05CeVBFkMQdclTOSfuPxlMkQOtjp8QWDj+F
-+j/MYziT5KBkHvcbrjdRtUJIAi4N7zCsPZtjik918AK1WBNRVqPbrgq/XSEXMfuvs
-+6JbfK0B76vdBDRtJFC1JsvnIrGbUztxXzyQwFLaR/AjVJqpVlysLWzPKWVX6/+SJ
-+u1NQOl2E8P6ycyBsuGnO89p0S4F8cMRcI2X1XQsZ7/q0NBrOMaEp5T3SrWo9GiQ3
-+o2SBdbs3Y6MBPBtTu977Z/0RO63J3M5i2tjUiDfrFy7+VRLKr7qQ7JibohyB8QaR
-+9tedgjn2f+of7PnP/PEl1cCphUZeHM7QKUMPT8dbqwmKtlYY43EHXcvNOT5IBk3X
-+9lwJoZk/B2i+ZMRNSP34ztAwtxmasPt6RAWGQpWCn9qmttAHAnMfDqe7F7jVR6rS
-+u58=
-+-----END CERTIFICATE-----`
-+
-+func TestHandshakeRSATooBig(t *testing.T) {
-+	testCert, _ := pem.Decode([]byte(largeRSAKeyCertPEM))
-+
-+	c := &Conn{conn: &discardConn{}, config: testConfig.Clone()}
-+
-+	expectedErr := "tls: server sent certificate containing RSA key larger than 8192 bits"
-+	err := c.verifyServerCertificate([][]byte{testCert.Bytes})
-+	if err == nil || err.Error() != expectedErr {
-+		t.Errorf("Conn.verifyServerCertificate unexpected error: want %q, got %q", expectedErr, err)
-+	}
-+
-+	expectedErr = "tls: client sent certificate containing RSA key larger than 8192 bits"
-+	err = c.processCertsFromClient(Certificate{Certificate: [][]byte{testCert.Bytes}})
-+	if err == nil || err.Error() != expectedErr {
-+		t.Errorf("Conn.processCertsFromClient unexpected error: want %q, got %q", expectedErr, err)
-+	}
-+}
-diff --git a/src/crypto/tls/handshake_server.go b/src/crypto/tls/handshake_server.go
-index 8d51e7e..a5d8f4a 100644
---- a/src/crypto/tls/handshake_server.go
-+++ b/src/crypto/tls/handshake_server.go
-@@ -812,6 +812,10 @@ func (c *Conn) processCertsFromClient(certificate Certificate) error {
-			c.sendAlert(alertBadCertificate)
-			return errors.New("tls: failed to parse client certificate: " + err.Error())
-		}
-+		if certs[i].PublicKeyAlgorithm == x509.RSA && certs[i].PublicKey.(*rsa.PublicKey).N.BitLen() > maxRSAKeySize {
-+			c.sendAlert(alertBadCertificate)
-+			return fmt.Errorf("tls: client sent certificate containing RSA key larger than %d bits", maxRSAKeySize)
-+		}
-	}
-
-	if len(certs) == 0 && requiresClientCert(c.config.ClientAuth) {
---
-2.40.0
diff --git a/meta/recipes-devtools/go/go-1.19/add_godebug.patch b/meta/recipes-devtools/go/go-1.19/add_godebug.patch
deleted file mode 100644
index 0c3d2d2855..0000000000
--- a/meta/recipes-devtools/go/go-1.19/add_godebug.patch
+++ /dev/null
@@ -1,84 +0,0 @@
-
-Upstream-Status: Backport [see text]
-
-https://github.com/golong/go.git as of commit 22c1d18a27...
-Copy src/internal/godebug from go 1.19 since it does not
-exist in 1.17.
-
-Signed-off-by: Joe Slater <joe.slater@windriver.com>
----
-
---- /dev/null
-+++ go/src/internal/godebug/godebug.go
-@@ -0,0 +1,34 @@
-+// Copyright 2021 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+// Package godebug parses the GODEBUG environment variable.
-+package godebug
-+
-+import "os"
-+
-+// Get returns the value for the provided GODEBUG key.
-+func Get(key string) string {
-+	return get(os.Getenv("GODEBUG"), key)
-+}
-+
-+// get returns the value part of key=value in s (a GODEBUG value).
-+func get(s, key string) string {
-+	for i := 0; i < len(s)-len(key)-1; i++ {
-+		if i > 0 && s[i-1] != ',' {
-+			continue
-+		}
-+		afterKey := s[i+len(key):]
-+		if afterKey[0] != '=' || s[i:i+len(key)] != key {
-+			continue
-+		}
-+		val := afterKey[1:]
-+		for i, b := range val {
-+			if b == ',' {
-+				return val[:i]
-+			}
-+		}
-+		return val
-+	}
-+	return ""
-+}
---- /dev/null
-+++ go/src/internal/godebug/godebug_test.go
-@@ -0,0 +1,34 @@
-+// Copyright 2021 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+package godebug
-+
-+import "testing"
-+
-+func TestGet(t *testing.T) {
-+	tests := []struct {
-+		godebug string
-+		key     string
-+		want    string
-+	}{
-+		{"", "", ""},
-+		{"", "foo", ""},
-+		{"foo=bar", "foo", "bar"},
-+		{"foo=bar,after=x", "foo", "bar"},
-+		{"before=x,foo=bar,after=x", "foo", "bar"},
-+		{"before=x,foo=bar", "foo", "bar"},
-+		{",,,foo=bar,,,", "foo", "bar"},
-+		{"foodecoy=wrong,foo=bar", "foo", "bar"},
-+		{"foo=", "foo", ""},
-+		{"foo", "foo", ""},
-+		{",foo", "foo", ""},
-+		{"foo=bar,baz", "loooooooong", ""},
-+	}
-+	for _, tt := range tests {
-+		got := get(tt.godebug, tt.key)
-+		if got != tt.want {
-+			t.Errorf("get(%q, %q) = %q; want %q", tt.godebug, tt.key, got, tt.want)
-+		}
-+	}
-+}
diff --git a/meta/recipes-devtools/go/go-1.19/cve-2022-41724.patch b/meta/recipes-devtools/go/go-1.19/cve-2022-41724.patch
deleted file mode 100644
index aacffbffcd..0000000000
--- a/meta/recipes-devtools/go/go-1.19/cve-2022-41724.patch
+++ /dev/null
@@ -1,2391 +0,0 @@
-From 00b256e9e3c0fa02a278ec9dfc3e191e02ceaf80 Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <roland@golang.org>
-Date: Wed, 14 Dec 2022 09:43:16 -0800
-Subject: [PATCH] [release-branch.go1.19] crypto/tls: replace all usages of
- BytesOrPanic
-
-Message marshalling makes use of BytesOrPanic a lot, under the
-assumption that it will never panic. This assumption was incorrect, and
-specifically crafted handshakes could trigger panics. Rather than just
-surgically replacing the usages of BytesOrPanic in paths that could
-panic, replace all usages of it with proper error returns in case there
-are other ways of triggering panics which we didn't find.
-
-In one specific case, the tree routed by expandLabel, we replace the
-usage of BytesOrPanic, but retain a panic. This function already
-explicitly panicked elsewhere, and returning an error from it becomes
-rather painful because it requires changing a large number of APIs.
-The marshalling is unlikely to ever panic, as the inputs are all either
-fixed length, or already limited to the sizes required. If it were to
-panic, it'd likely only be during development. A close inspection shows
-no paths for a user to cause a panic currently.
-
-This patches ends up being rather large, since it requires routing
-errors back through functions which previously had no error returns.
-Where possible I've tried to use helpers that reduce the verbosity
-of frequently repeated stanzas, and to make the diffs as minimal as
-possible.
-
-Thanks to Marten Seemann for reporting this issue.
-
-Updates #58001
-Fixes #58358
-Fixes CVE-2022-41724
-
-Change-Id: Ieb55867ef0a3e1e867b33f09421932510cb58851
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1679436
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-TryBot-Result: Security TryBots <security-trybots@go-security-trybots.iam.gserviceaccount.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-(cherry picked from commit 0f3a44ad7b41cc89efdfad25278953e17d9c1e04)
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1728204
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/468117
-Auto-Submit: Michael Pratt <mpratt@google.com>
-Run-TryBot: Michael Pratt <mpratt@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Than McIntosh <thanm@google.com>
----
-
-CVE: CVE-2022-41724
-
-Upstream-Status: Backport [see text]
-
-https://github.com/golong/go.git commit 00b256e9e3c0fa...
-boring_test.go does not exist
-modified for conn.go and handshake_messages.go
-
-Signed-off-by: Joe Slater <joe.slater@windriver.com>
-
----
- src/crypto/tls/boring_test.go             |   2 +-
- src/crypto/tls/common.go                  |   2 +-
- src/crypto/tls/conn.go                    |  46 +-
- src/crypto/tls/handshake_client.go        |  95 +--
- src/crypto/tls/handshake_client_test.go   |   4 +-
- src/crypto/tls/handshake_client_tls13.go  |  74 ++-
- src/crypto/tls/handshake_messages.go      | 716 +++++++++++-----------
- src/crypto/tls/handshake_messages_test.go |  19 +-
- src/crypto/tls/handshake_server.go        |  73 ++-
- src/crypto/tls/handshake_server_test.go   |  31 +-
- src/crypto/tls/handshake_server_tls13.go  |  71 ++-
- src/crypto/tls/key_schedule.go            |  19 +-
- src/crypto/tls/ticket.go                  |   8 +-
- 13 files changed, 657 insertions(+), 503 deletions(-)
-
---- go.orig/src/crypto/tls/common.go
-+++ go/src/crypto/tls/common.go
-@@ -1357,7 +1357,7 @@ func (c *Certificate) leaf() (*x509.Cert
- }
- 
- type handshakeMessage interface {
--	marshal() []byte
-+	marshal() ([]byte, error)
- 	unmarshal([]byte) bool
- }
- 
---- go.orig/src/crypto/tls/conn.go
-+++ go/src/crypto/tls/conn.go
-@@ -994,18 +994,46 @@ func (c *Conn) writeRecordLocked(typ rec
- 	return n, nil
- }
- 
--// writeRecord writes a TLS record with the given type and payload to the
--// connection and updates the record layer state.
--func (c *Conn) writeRecord(typ recordType, data []byte) (int, error) {
-+// writeHandshakeRecord writes a handshake message to the connection and updates
-+// the record layer state. If transcript is non-nil the marshalled message is
-+// written to it.
-+func (c *Conn) writeHandshakeRecord(msg handshakeMessage, transcript transcriptHash) (int, error) {
- 	c.out.Lock()
- 	defer c.out.Unlock()
- 
--	return c.writeRecordLocked(typ, data)
-+	data, err := msg.marshal()
-+	if err != nil {
-+		return 0, err
-+	}
-+	if transcript != nil {
-+		transcript.Write(data)
-+	}
-+
-+	return c.writeRecordLocked(recordTypeHandshake, data)
-+}
-+
-+// writeChangeCipherRecord writes a ChangeCipherSpec message to the connection and
-+// updates the record layer state.
-+func (c *Conn) writeChangeCipherRecord() error {
-+	c.out.Lock()
-+	defer c.out.Unlock()
-+	_, err := c.writeRecordLocked(recordTypeChangeCipherSpec, []byte{1})
-+	return err
- }
- 
- // readHandshake reads the next handshake message from
--// the record layer.
--func (c *Conn) readHandshake() (interface{}, error) {
-+// the record layer. If transcript is non-nil, the message
-+// is written to the passed transcriptHash.
-+
-+// backport 00b256e9e3c0fa02a278ec9dfc3e191e02ceaf80 
-+//
-+// Commit wants to set this to
-+//
-+// func (c *Conn) readHandshake(transcript transcriptHash) (any, error) {
-+//
-+// but that does not compile.  Retain the original interface{} argument.
-+//
-+func (c *Conn) readHandshake(transcript transcriptHash) (interface{}, error) {
- 	for c.hand.Len() < 4 {
- 		if err := c.readRecord(); err != nil {
- 			return nil, err
-@@ -1084,6 +1112,11 @@ func (c *Conn) readHandshake() (interfac
- 	if !m.unmarshal(data) {
- 		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
- 	}
-+
-+	if transcript != nil {
-+		transcript.Write(data)
-+	}
-+
- 	return m, nil
- }
- 
-@@ -1159,7 +1192,7 @@ func (c *Conn) handleRenegotiation() err
- 		return errors.New("tls: internal error: unexpected renegotiation")
- 	}
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -1205,7 +1238,7 @@ func (c *Conn) handlePostHandshakeMessag
- 		return c.handleRenegotiation()
- 	}
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -1241,7 +1274,11 @@ func (c *Conn) handleKeyUpdate(keyUpdate
- 		defer c.out.Unlock()
- 
- 		msg := &keyUpdateMsg{}
--		_, err := c.writeRecordLocked(recordTypeHandshake, msg.marshal())
-+		msgBytes, err := msg.marshal()
-+		if err != nil {
-+			return err
-+		}
-+		_, err = c.writeRecordLocked(recordTypeHandshake, msgBytes)
- 		if err != nil {
- 			// Surface the error at the next write.
- 			c.out.setErrorLocked(err)
---- go.orig/src/crypto/tls/handshake_client.go
-+++ go/src/crypto/tls/handshake_client.go
-@@ -157,7 +157,10 @@ func (c *Conn) clientHandshake(ctx conte
- 	}
- 	c.serverName = hello.serverName
- 
--	cacheKey, session, earlySecret, binderKey := c.loadSession(hello)
-+	cacheKey, session, earlySecret, binderKey, err := c.loadSession(hello)
-+	if err != nil {
-+		return err
-+	}
- 	if cacheKey != "" && session != nil {
- 		defer func() {
- 			// If we got a handshake failure when resuming a session, throw away
-@@ -172,11 +175,12 @@ func (c *Conn) clientHandshake(ctx conte
- 		}()
- 	}
- 
--	if _, err := c.writeRecord(recordTypeHandshake, hello.marshal()); err != nil {
-+	if _, err := c.writeHandshakeRecord(hello, nil); err != nil {
- 		return err
- 	}
- 
--	msg, err := c.readHandshake()
-+	// serverHelloMsg is not included in the transcript
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -241,9 +245,9 @@ func (c *Conn) clientHandshake(ctx conte
- }
- 
- func (c *Conn) loadSession(hello *clientHelloMsg) (cacheKey string,
--	session *ClientSessionState, earlySecret, binderKey []byte) {
-+	session *ClientSessionState, earlySecret, binderKey []byte, err error) {
- 	if c.config.SessionTicketsDisabled || c.config.ClientSessionCache == nil {
--		return "", nil, nil, nil
-+		return "", nil, nil, nil, nil
- 	}
- 
- 	hello.ticketSupported = true
-@@ -258,14 +262,14 @@ func (c *Conn) loadSession(hello *client
- 	// renegotiation is primarily used to allow a client to send a client
- 	// certificate, which would be skipped if session resumption occurred.
- 	if c.handshakes != 0 {
--		return "", nil, nil, nil
-+		return "", nil, nil, nil, nil
- 	}
- 
- 	// Try to resume a previously negotiated TLS session, if available.
- 	cacheKey = clientSessionCacheKey(c.conn.RemoteAddr(), c.config)
- 	session, ok := c.config.ClientSessionCache.Get(cacheKey)
- 	if !ok || session == nil {
--		return cacheKey, nil, nil, nil
-+		return cacheKey, nil, nil, nil, nil
- 	}
- 
- 	// Check that version used for the previous session is still valid.
-@@ -277,7 +281,7 @@ func (c *Conn) loadSession(hello *client
- 		}
- 	}
- 	if !versOk {
--		return cacheKey, nil, nil, nil
-+		return cacheKey, nil, nil, nil, nil
- 	}
- 
- 	// Check that the cached server certificate is not expired, and that it's
-@@ -286,16 +290,16 @@ func (c *Conn) loadSession(hello *client
- 	if !c.config.InsecureSkipVerify {
- 		if len(session.verifiedChains) == 0 {
- 			// The original connection had InsecureSkipVerify, while this doesn't.
--			return cacheKey, nil, nil, nil
-+			return cacheKey, nil, nil, nil, nil
- 		}
- 		serverCert := session.serverCertificates[0]
- 		if c.config.time().After(serverCert.NotAfter) {
- 			// Expired certificate, delete the entry.
- 			c.config.ClientSessionCache.Put(cacheKey, nil)
--			return cacheKey, nil, nil, nil
-+			return cacheKey, nil, nil, nil, nil
- 		}
- 		if err := serverCert.VerifyHostname(c.config.ServerName); err != nil {
--			return cacheKey, nil, nil, nil
-+			return cacheKey, nil, nil, nil, nil
- 		}
- 	}
- 
-@@ -303,7 +307,7 @@ func (c *Conn) loadSession(hello *client
- 		// In TLS 1.2 the cipher suite must match the resumed session. Ensure we
- 		// are still offering it.
- 		if mutualCipherSuite(hello.cipherSuites, session.cipherSuite) == nil {
--			return cacheKey, nil, nil, nil
-+			return cacheKey, nil, nil, nil, nil
- 		}
- 
- 		hello.sessionTicket = session.sessionTicket
-@@ -313,14 +317,14 @@ func (c *Conn) loadSession(hello *client
- 	// Check that the session ticket is not expired.
- 	if c.config.time().After(session.useBy) {
- 		c.config.ClientSessionCache.Put(cacheKey, nil)
--		return cacheKey, nil, nil, nil
-+		return cacheKey, nil, nil, nil, nil
- 	}
- 
- 	// In TLS 1.3 the KDF hash must match the resumed session. Ensure we
- 	// offer at least one cipher suite with that hash.
- 	cipherSuite := cipherSuiteTLS13ByID(session.cipherSuite)
- 	if cipherSuite == nil {
--		return cacheKey, nil, nil, nil
-+		return cacheKey, nil, nil, nil, nil
- 	}
- 	cipherSuiteOk := false
- 	for _, offeredID := range hello.cipherSuites {
-@@ -331,7 +335,7 @@ func (c *Conn) loadSession(hello *client
- 		}
- 	}
- 	if !cipherSuiteOk {
--		return cacheKey, nil, nil, nil
-+		return cacheKey, nil, nil, nil, nil
- 	}
- 
- 	// Set the pre_shared_key extension. See RFC 8446, Section 4.2.11.1.
-@@ -349,9 +353,15 @@ func (c *Conn) loadSession(hello *client
- 	earlySecret = cipherSuite.extract(psk, nil)
- 	binderKey = cipherSuite.deriveSecret(earlySecret, resumptionBinderLabel, nil)
- 	transcript := cipherSuite.hash.New()
--	transcript.Write(hello.marshalWithoutBinders())
-+	helloBytes, err := hello.marshalWithoutBinders()
-+	if err != nil {
-+		return "", nil, nil, nil, err
-+	}
-+	transcript.Write(helloBytes)
- 	pskBinders := [][]byte{cipherSuite.finishedHash(binderKey, transcript)}
--	hello.updateBinders(pskBinders)
-+	if err := hello.updateBinders(pskBinders); err != nil {
-+		return "", nil, nil, nil, err
-+	}
- 
- 	return
- }
-@@ -396,8 +406,12 @@ func (hs *clientHandshakeState) handshak
- 		hs.finishedHash.discardHandshakeBuffer()
- 	}
- 
--	hs.finishedHash.Write(hs.hello.marshal())
--	hs.finishedHash.Write(hs.serverHello.marshal())
-+	if err := transcriptMsg(hs.hello, &hs.finishedHash); err != nil {
-+		return err
-+	}
-+	if err := transcriptMsg(hs.serverHello, &hs.finishedHash); err != nil {
-+		return err
-+	}
- 
- 	c.buffering = true
- 	c.didResume = isResume
-@@ -468,7 +482,7 @@ func (hs *clientHandshakeState) pickCiph
- func (hs *clientHandshakeState) doFullHandshake() error {
- 	c := hs.c
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(&hs.finishedHash)
- 	if err != nil {
- 		return err
- 	}
-@@ -477,9 +491,8 @@ func (hs *clientHandshakeState) doFullHa
- 		c.sendAlert(alertUnexpectedMessage)
- 		return unexpectedMessageError(certMsg, msg)
- 	}
--	hs.finishedHash.Write(certMsg.marshal())
- 
--	msg, err = c.readHandshake()
-+	msg, err = c.readHandshake(&hs.finishedHash)
- 	if err != nil {
- 		return err
- 	}
-@@ -497,11 +510,10 @@ func (hs *clientHandshakeState) doFullHa
- 			c.sendAlert(alertUnexpectedMessage)
- 			return errors.New("tls: received unexpected CertificateStatus message")
- 		}
--		hs.finishedHash.Write(cs.marshal())
- 
- 		c.ocspResponse = cs.response
- 
--		msg, err = c.readHandshake()
-+		msg, err = c.readHandshake(&hs.finishedHash)
- 		if err != nil {
- 			return err
- 		}
-@@ -530,14 +542,13 @@ func (hs *clientHandshakeState) doFullHa
- 
- 	skx, ok := msg.(*serverKeyExchangeMsg)
- 	if ok {
--		hs.finishedHash.Write(skx.marshal())
- 		err = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx)
- 		if err != nil {
- 			c.sendAlert(alertUnexpectedMessage)
- 			return err
- 		}
- 
--		msg, err = c.readHandshake()
-+		msg, err = c.readHandshake(&hs.finishedHash)
- 		if err != nil {
- 			return err
- 		}
-@@ -548,7 +559,6 @@ func (hs *clientHandshakeState) doFullHa
- 	certReq, ok := msg.(*certificateRequestMsg)
- 	if ok {
- 		certRequested = true
--		hs.finishedHash.Write(certReq.marshal())
- 
- 		cri := certificateRequestInfoFromMsg(hs.ctx, c.vers, certReq)
- 		if chainToSend, err = c.getClientCertificate(cri); err != nil {
-@@ -556,7 +566,7 @@ func (hs *clientHandshakeState) doFullHa
- 			return err
- 		}
- 
--		msg, err = c.readHandshake()
-+		msg, err = c.readHandshake(&hs.finishedHash)
- 		if err != nil {
- 			return err
- 		}
-@@ -567,7 +577,6 @@ func (hs *clientHandshakeState) doFullHa
- 		c.sendAlert(alertUnexpectedMessage)
- 		return unexpectedMessageError(shd, msg)
- 	}
--	hs.finishedHash.Write(shd.marshal())
- 
- 	// If the server requested a certificate then we have to send a
- 	// Certificate message, even if it's empty because we don't have a
-@@ -575,8 +584,7 @@ func (hs *clientHandshakeState) doFullHa
- 	if certRequested {
- 		certMsg = new(certificateMsg)
- 		certMsg.certificates = chainToSend.Certificate
--		hs.finishedHash.Write(certMsg.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {
- 			return err
- 		}
- 	}
-@@ -587,8 +595,7 @@ func (hs *clientHandshakeState) doFullHa
- 		return err
- 	}
- 	if ckx != nil {
--		hs.finishedHash.Write(ckx.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, ckx.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(ckx, &hs.finishedHash); err != nil {
- 			return err
- 		}
- 	}
-@@ -635,8 +642,7 @@ func (hs *clientHandshakeState) doFullHa
- 			return err
- 		}
- 
--		hs.finishedHash.Write(certVerify.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, certVerify.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(certVerify, &hs.finishedHash); err != nil {
- 			return err
- 		}
- 	}
-@@ -771,7 +777,10 @@ func (hs *clientHandshakeState) readFini
- 		return err
- 	}
- 
--	msg, err := c.readHandshake()
-+	// finishedMsg is included in the transcript, but not until after we
-+	// check the client version, since the state before this message was
-+	// sent is used during verification.
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -787,7 +796,11 @@ func (hs *clientHandshakeState) readFini
- 		c.sendAlert(alertHandshakeFailure)
- 		return errors.New("tls: server's Finished message was incorrect")
- 	}
--	hs.finishedHash.Write(serverFinished.marshal())
-+
-+	if err := transcriptMsg(serverFinished, &hs.finishedHash); err != nil {
-+		return err
-+	}
-+
- 	copy(out, verify)
- 	return nil
- }
-@@ -798,7 +811,7 @@ func (hs *clientHandshakeState) readSess
- 	}
- 
- 	c := hs.c
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(&hs.finishedHash)
- 	if err != nil {
- 		return err
- 	}
-@@ -807,7 +820,6 @@ func (hs *clientHandshakeState) readSess
- 		c.sendAlert(alertUnexpectedMessage)
- 		return unexpectedMessageError(sessionTicketMsg, msg)
- 	}
--	hs.finishedHash.Write(sessionTicketMsg.marshal())
- 
- 	hs.session = &ClientSessionState{
- 		sessionTicket:      sessionTicketMsg.ticket,
-@@ -827,14 +839,13 @@ func (hs *clientHandshakeState) readSess
- func (hs *clientHandshakeState) sendFinished(out []byte) error {
- 	c := hs.c
- 
--	if _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil {
-+	if err := c.writeChangeCipherRecord(); err != nil {
- 		return err
- 	}
- 
- 	finished := new(finishedMsg)
- 	finished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)
--	hs.finishedHash.Write(finished.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 	copy(out, finished.verifyData)
---- go.orig/src/crypto/tls/handshake_client_test.go
-+++ go/src/crypto/tls/handshake_client_test.go
-@@ -1257,7 +1257,7 @@ func TestServerSelectingUnconfiguredAppl
- 		cipherSuite:  TLS_RSA_WITH_AES_128_GCM_SHA256,
- 		alpnProtocol: "how-about-this",
- 	}
--	serverHelloBytes := serverHello.marshal()
-+	serverHelloBytes := mustMarshal(t, serverHello)
- 
- 	s.Write([]byte{
- 		byte(recordTypeHandshake),
-@@ -1500,7 +1500,7 @@ func TestServerSelectingUnconfiguredCiph
- 		random:      make([]byte, 32),
- 		cipherSuite: TLS_RSA_WITH_AES_256_GCM_SHA384,
- 	}
--	serverHelloBytes := serverHello.marshal()
-+	serverHelloBytes := mustMarshal(t, serverHello)
- 
- 	s.Write([]byte{
- 		byte(recordTypeHandshake),
---- go.orig/src/crypto/tls/handshake_client_tls13.go
-+++ go/src/crypto/tls/handshake_client_tls13.go
-@@ -58,7 +58,10 @@ func (hs *clientHandshakeStateTLS13) han
- 	}
- 
- 	hs.transcript = hs.suite.hash.New()
--	hs.transcript.Write(hs.hello.marshal())
-+
-+	if err := transcriptMsg(hs.hello, hs.transcript); err != nil {
-+		return err
-+	}
- 
- 	if bytes.Equal(hs.serverHello.random, helloRetryRequestRandom) {
- 		if err := hs.sendDummyChangeCipherSpec(); err != nil {
-@@ -69,7 +72,9 @@ func (hs *clientHandshakeStateTLS13) han
- 		}
- 	}
- 
--	hs.transcript.Write(hs.serverHello.marshal())
-+	if err := transcriptMsg(hs.serverHello, hs.transcript); err != nil {
-+		return err
-+	}
- 
- 	c.buffering = true
- 	if err := hs.processServerHello(); err != nil {
-@@ -168,8 +173,7 @@ func (hs *clientHandshakeStateTLS13) sen
- 	}
- 	hs.sentDummyCCS = true
- 
--	_, err := hs.c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
--	return err
-+	return hs.c.writeChangeCipherRecord()
- }
- 
- // processHelloRetryRequest handles the HRR in hs.serverHello, modifies and
-@@ -184,7 +188,9 @@ func (hs *clientHandshakeStateTLS13) pro
- 	hs.transcript.Reset()
- 	hs.transcript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})
- 	hs.transcript.Write(chHash)
--	hs.transcript.Write(hs.serverHello.marshal())
-+	if err := transcriptMsg(hs.serverHello, hs.transcript); err != nil {
-+		return err
-+	}
- 
- 	// The only HelloRetryRequest extensions we support are key_share and
- 	// cookie, and clients must abort the handshake if the HRR would not result
-@@ -249,10 +255,18 @@ func (hs *clientHandshakeStateTLS13) pro
- 			transcript := hs.suite.hash.New()
- 			transcript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})
- 			transcript.Write(chHash)
--			transcript.Write(hs.serverHello.marshal())
--			transcript.Write(hs.hello.marshalWithoutBinders())
-+			if err := transcriptMsg(hs.serverHello, hs.transcript); err != nil {
-+				return err
-+			}
-+			helloBytes, err := hs.hello.marshalWithoutBinders()
-+			if err != nil {
-+				return err
-+			}
-+			transcript.Write(helloBytes)
- 			pskBinders := [][]byte{hs.suite.finishedHash(hs.binderKey, transcript)}
--			hs.hello.updateBinders(pskBinders)
-+			if err := hs.hello.updateBinders(pskBinders); err != nil {
-+				return err
-+			}
- 		} else {
- 			// Server selected a cipher suite incompatible with the PSK.
- 			hs.hello.pskIdentities = nil
-@@ -260,12 +274,12 @@ func (hs *clientHandshakeStateTLS13) pro
- 		}
- 	}
- 
--	hs.transcript.Write(hs.hello.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(hs.hello, hs.transcript); err != nil {
- 		return err
- 	}
- 
--	msg, err := c.readHandshake()
-+	// serverHelloMsg is not included in the transcript
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -354,6 +368,7 @@ func (hs *clientHandshakeStateTLS13) est
- 	if !hs.usingPSK {
- 		earlySecret = hs.suite.extract(nil, nil)
- 	}
-+
- 	handshakeSecret := hs.suite.extract(sharedKey,
- 		hs.suite.deriveSecret(earlySecret, "derived", nil))
- 
-@@ -384,7 +399,7 @@ func (hs *clientHandshakeStateTLS13) est
- func (hs *clientHandshakeStateTLS13) readServerParameters() error {
- 	c := hs.c
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(hs.transcript)
- 	if err != nil {
- 		return err
- 	}
-@@ -394,7 +409,6 @@ func (hs *clientHandshakeStateTLS13) rea
- 		c.sendAlert(alertUnexpectedMessage)
- 		return unexpectedMessageError(encryptedExtensions, msg)
- 	}
--	hs.transcript.Write(encryptedExtensions.marshal())
- 
- 	if err := checkALPN(hs.hello.alpnProtocols, encryptedExtensions.alpnProtocol); err != nil {
- 		c.sendAlert(alertUnsupportedExtension)
-@@ -423,18 +437,16 @@ func (hs *clientHandshakeStateTLS13) rea
- 		return nil
- 	}
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(hs.transcript)
- 	if err != nil {
- 		return err
- 	}
- 
- 	certReq, ok := msg.(*certificateRequestMsgTLS13)
- 	if ok {
--		hs.transcript.Write(certReq.marshal())
--
- 		hs.certReq = certReq
- 
--		msg, err = c.readHandshake()
-+		msg, err = c.readHandshake(hs.transcript)
- 		if err != nil {
- 			return err
- 		}
-@@ -449,7 +461,6 @@ func (hs *clientHandshakeStateTLS13) rea
- 		c.sendAlert(alertDecodeError)
- 		return errors.New("tls: received empty certificates message")
- 	}
--	hs.transcript.Write(certMsg.marshal())
- 
- 	c.scts = certMsg.certificate.SignedCertificateTimestamps
- 	c.ocspResponse = certMsg.certificate.OCSPStaple
-@@ -458,7 +469,10 @@ func (hs *clientHandshakeStateTLS13) rea
- 		return err
- 	}
- 
--	msg, err = c.readHandshake()
-+	// certificateVerifyMsg is included in the transcript, but not until
-+	// after we verify the handshake signature, since the state before
-+	// this message was sent is used.
-+	msg, err = c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -489,7 +503,9 @@ func (hs *clientHandshakeStateTLS13) rea
- 		return errors.New("tls: invalid signature by the server certificate: " + err.Error())
- 	}
- 
--	hs.transcript.Write(certVerify.marshal())
-+	if err := transcriptMsg(certVerify, hs.transcript); err != nil {
-+		return err
-+	}
- 
- 	return nil
- }
-@@ -497,7 +513,10 @@ func (hs *clientHandshakeStateTLS13) rea
- func (hs *clientHandshakeStateTLS13) readServerFinished() error {
- 	c := hs.c
- 
--	msg, err := c.readHandshake()
-+	// finishedMsg is included in the transcript, but not until after we
-+	// check the client version, since the state before this message was
-+	// sent is used during verification.
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -514,7 +533,9 @@ func (hs *clientHandshakeStateTLS13) rea
- 		return errors.New("tls: invalid server finished hash")
- 	}
- 
--	hs.transcript.Write(finished.marshal())
-+	if err := transcriptMsg(finished, hs.transcript); err != nil {
-+		return err
-+	}
- 
- 	// Derive secrets that take context through the server Finished.
- 
-@@ -563,8 +584,7 @@ func (hs *clientHandshakeStateTLS13) sen
- 	certMsg.scts = hs.certReq.scts && len(cert.SignedCertificateTimestamps) > 0
- 	certMsg.ocspStapling = hs.certReq.ocspStapling && len(cert.OCSPStaple) > 0
- 
--	hs.transcript.Write(certMsg.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(certMsg, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -601,8 +621,7 @@ func (hs *clientHandshakeStateTLS13) sen
- 	}
- 	certVerifyMsg.signature = sig
- 
--	hs.transcript.Write(certVerifyMsg.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, certVerifyMsg.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(certVerifyMsg, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -616,8 +635,7 @@ func (hs *clientHandshakeStateTLS13) sen
- 		verifyData: hs.suite.finishedHash(c.out.trafficSecret, hs.transcript),
- 	}
- 
--	hs.transcript.Write(finished.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(finished, hs.transcript); err != nil {
- 		return err
- 	}
- 
---- go.orig/src/crypto/tls/handshake_messages.go
-+++ go/src/crypto/tls/handshake_messages.go
-@@ -5,6 +5,7 @@
- package tls
- 
- import (
-+	"errors"
- 	"fmt"
- 	"strings"
- 
-@@ -94,9 +95,181 @@ type clientHelloMsg struct {
- 	pskBinders                       [][]byte
- }
- 
--func (m *clientHelloMsg) marshal() []byte {
-+func (m *clientHelloMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
-+	}
-+
-+	var exts cryptobyte.Builder
-+	if len(m.serverName) > 0 {
-+		// RFC 6066, Section 3
-+		exts.AddUint16(extensionServerName)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddUint8(0) // name_type = host_name
-+				exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+					exts.AddBytes([]byte(m.serverName))
-+				})
-+			})
-+		})
-+	}
-+	if m.ocspStapling {
-+		// RFC 4366, Section 3.6
-+		exts.AddUint16(extensionStatusRequest)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8(1)  // status_type = ocsp
-+			exts.AddUint16(0) // empty responder_id_list
-+			exts.AddUint16(0) // empty request_extensions
-+		})
-+	}
-+	if len(m.supportedCurves) > 0 {
-+		// RFC 4492, sections 5.1.1 and RFC 8446, Section 4.2.7
-+		exts.AddUint16(extensionSupportedCurves)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, curve := range m.supportedCurves {
-+					exts.AddUint16(uint16(curve))
-+				}
-+			})
-+		})
-+	}
-+	if len(m.supportedPoints) > 0 {
-+		// RFC 4492, Section 5.1.2
-+		exts.AddUint16(extensionSupportedPoints)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.supportedPoints)
-+			})
-+		})
-+	}
-+	if m.ticketSupported {
-+		// RFC 5077, Section 3.2
-+		exts.AddUint16(extensionSessionTicket)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddBytes(m.sessionTicket)
-+		})
-+	}
-+	if len(m.supportedSignatureAlgorithms) > 0 {
-+		// RFC 5246, Section 7.4.1.4.1
-+		exts.AddUint16(extensionSignatureAlgorithms)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, sigAlgo := range m.supportedSignatureAlgorithms {
-+					exts.AddUint16(uint16(sigAlgo))
-+				}
-+			})
-+		})
-+	}
-+	if len(m.supportedSignatureAlgorithmsCert) > 0 {
-+		// RFC 8446, Section 4.2.3
-+		exts.AddUint16(extensionSignatureAlgorithmsCert)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, sigAlgo := range m.supportedSignatureAlgorithmsCert {
-+					exts.AddUint16(uint16(sigAlgo))
-+				}
-+			})
-+		})
-+	}
-+	if m.secureRenegotiationSupported {
-+		// RFC 5746, Section 3.2
-+		exts.AddUint16(extensionRenegotiationInfo)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.secureRenegotiation)
-+			})
-+		})
-+	}
-+	if len(m.alpnProtocols) > 0 {
-+		// RFC 7301, Section 3.1
-+		exts.AddUint16(extensionALPN)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, proto := range m.alpnProtocols {
-+					exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+						exts.AddBytes([]byte(proto))
-+					})
-+				}
-+			})
-+		})
-+	}
-+	if m.scts {
-+		// RFC 6962, Section 3.3.1
-+		exts.AddUint16(extensionSCT)
-+		exts.AddUint16(0) // empty extension_data
-+	}
-+	if len(m.supportedVersions) > 0 {
-+		// RFC 8446, Section 4.2.1
-+		exts.AddUint16(extensionSupportedVersions)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, vers := range m.supportedVersions {
-+					exts.AddUint16(vers)
-+				}
-+			})
-+		})
-+	}
-+	if len(m.cookie) > 0 {
-+		// RFC 8446, Section 4.2.2
-+		exts.AddUint16(extensionCookie)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.cookie)
-+			})
-+		})
-+	}
-+	if len(m.keyShares) > 0 {
-+		// RFC 8446, Section 4.2.8
-+		exts.AddUint16(extensionKeyShare)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, ks := range m.keyShares {
-+					exts.AddUint16(uint16(ks.group))
-+					exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+						exts.AddBytes(ks.data)
-+					})
-+				}
-+			})
-+		})
-+	}
-+	if m.earlyData {
-+		// RFC 8446, Section 4.2.10
-+		exts.AddUint16(extensionEarlyData)
-+		exts.AddUint16(0) // empty extension_data
-+	}
-+	if len(m.pskModes) > 0 {
-+		// RFC 8446, Section 4.2.9
-+		exts.AddUint16(extensionPSKModes)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.pskModes)
-+			})
-+		})
-+	}
-+	if len(m.pskIdentities) > 0 { // pre_shared_key must be the last extension
-+		// RFC 8446, Section 4.2.11
-+		exts.AddUint16(extensionPreSharedKey)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, psk := range m.pskIdentities {
-+					exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+						exts.AddBytes(psk.label)
-+					})
-+					exts.AddUint32(psk.obfuscatedTicketAge)
-+				}
-+			})
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, binder := range m.pskBinders {
-+					exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+						exts.AddBytes(binder)
-+					})
-+				}
-+			})
-+		})
-+	}
-+	extBytes, err := exts.Bytes()
-+	if err != nil {
-+		return nil, err
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -116,219 +289,53 @@ func (m *clientHelloMsg) marshal() []byt
- 			b.AddBytes(m.compressionMethods)
- 		})
- 
--		// If extensions aren't present, omit them.
--		var extensionsPresent bool
--		bWithoutExtensions := *b
--
--		b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--			if len(m.serverName) > 0 {
--				// RFC 6066, Section 3
--				b.AddUint16(extensionServerName)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddUint8(0) // name_type = host_name
--						b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--							b.AddBytes([]byte(m.serverName))
--						})
--					})
--				})
--			}
--			if m.ocspStapling {
--				// RFC 4366, Section 3.6
--				b.AddUint16(extensionStatusRequest)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8(1)  // status_type = ocsp
--					b.AddUint16(0) // empty responder_id_list
--					b.AddUint16(0) // empty request_extensions
--				})
--			}
--			if len(m.supportedCurves) > 0 {
--				// RFC 4492, sections 5.1.1 and RFC 8446, Section 4.2.7
--				b.AddUint16(extensionSupportedCurves)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, curve := range m.supportedCurves {
--							b.AddUint16(uint16(curve))
--						}
--					})
--				})
--			}
--			if len(m.supportedPoints) > 0 {
--				// RFC 4492, Section 5.1.2
--				b.AddUint16(extensionSupportedPoints)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.supportedPoints)
--					})
--				})
--			}
--			if m.ticketSupported {
--				// RFC 5077, Section 3.2
--				b.AddUint16(extensionSessionTicket)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddBytes(m.sessionTicket)
--				})
--			}
--			if len(m.supportedSignatureAlgorithms) > 0 {
--				// RFC 5246, Section 7.4.1.4.1
--				b.AddUint16(extensionSignatureAlgorithms)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, sigAlgo := range m.supportedSignatureAlgorithms {
--							b.AddUint16(uint16(sigAlgo))
--						}
--					})
--				})
--			}
--			if len(m.supportedSignatureAlgorithmsCert) > 0 {
--				// RFC 8446, Section 4.2.3
--				b.AddUint16(extensionSignatureAlgorithmsCert)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, sigAlgo := range m.supportedSignatureAlgorithmsCert {
--							b.AddUint16(uint16(sigAlgo))
--						}
--					})
--				})
--			}
--			if m.secureRenegotiationSupported {
--				// RFC 5746, Section 3.2
--				b.AddUint16(extensionRenegotiationInfo)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.secureRenegotiation)
--					})
--				})
--			}
--			if len(m.alpnProtocols) > 0 {
--				// RFC 7301, Section 3.1
--				b.AddUint16(extensionALPN)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, proto := range m.alpnProtocols {
--							b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--								b.AddBytes([]byte(proto))
--							})
--						}
--					})
--				})
--			}
--			if m.scts {
--				// RFC 6962, Section 3.3.1
--				b.AddUint16(extensionSCT)
--				b.AddUint16(0) // empty extension_data
--			}
--			if len(m.supportedVersions) > 0 {
--				// RFC 8446, Section 4.2.1
--				b.AddUint16(extensionSupportedVersions)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, vers := range m.supportedVersions {
--							b.AddUint16(vers)
--						}
--					})
--				})
--			}
--			if len(m.cookie) > 0 {
--				// RFC 8446, Section 4.2.2
--				b.AddUint16(extensionCookie)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.cookie)
--					})
--				})
--			}
--			if len(m.keyShares) > 0 {
--				// RFC 8446, Section 4.2.8
--				b.AddUint16(extensionKeyShare)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, ks := range m.keyShares {
--							b.AddUint16(uint16(ks.group))
--							b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--								b.AddBytes(ks.data)
--							})
--						}
--					})
--				})
--			}
--			if m.earlyData {
--				// RFC 8446, Section 4.2.10
--				b.AddUint16(extensionEarlyData)
--				b.AddUint16(0) // empty extension_data
--			}
--			if len(m.pskModes) > 0 {
--				// RFC 8446, Section 4.2.9
--				b.AddUint16(extensionPSKModes)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.pskModes)
--					})
--				})
--			}
--			if len(m.pskIdentities) > 0 { // pre_shared_key must be the last extension
--				// RFC 8446, Section 4.2.11
--				b.AddUint16(extensionPreSharedKey)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, psk := range m.pskIdentities {
--							b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--								b.AddBytes(psk.label)
--							})
--							b.AddUint32(psk.obfuscatedTicketAge)
--						}
--					})
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, binder := range m.pskBinders {
--							b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--								b.AddBytes(binder)
--							})
--						}
--					})
--				})
--			}
--
--			extensionsPresent = len(b.BytesOrPanic()) > 2
--		})
--
--		if !extensionsPresent {
--			*b = bWithoutExtensions
--		}
--	})
-+		if len(extBytes) > 0 {
-+			b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
-+				b.AddBytes(extBytes)
-+			})
-+ 		}
-+ 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- // marshalWithoutBinders returns the ClientHello through the
- // PreSharedKeyExtension.identities field, according to RFC 8446, Section
- // 4.2.11.2. Note that m.pskBinders must be set to slices of the correct length.
--func (m *clientHelloMsg) marshalWithoutBinders() []byte {
-+func (m *clientHelloMsg) marshalWithoutBinders() ([]byte, error) {
- 	bindersLen := 2 // uint16 length prefix
- 	for _, binder := range m.pskBinders {
- 		bindersLen += 1 // uint8 length prefix
- 		bindersLen += len(binder)
- 	}
- 
--	fullMessage := m.marshal()
--	return fullMessage[:len(fullMessage)-bindersLen]
-+	fullMessage, err := m.marshal()
-+	if err != nil {
-+		return nil, err
-+	}
-+	return fullMessage[:len(fullMessage)-bindersLen], nil
- }
- 
- // updateBinders updates the m.pskBinders field, if necessary updating the
- // cached marshaled representation. The supplied binders must have the same
- // length as the current m.pskBinders.
--func (m *clientHelloMsg) updateBinders(pskBinders [][]byte) {
-+func (m *clientHelloMsg) updateBinders(pskBinders [][]byte) error {
- 	if len(pskBinders) != len(m.pskBinders) {
--		panic("tls: internal error: pskBinders length mismatch")
-+		return errors.New("tls: internal error: pskBinders length mismatch")
- 	}
- 	for i := range m.pskBinders {
- 		if len(pskBinders[i]) != len(m.pskBinders[i]) {
--			panic("tls: internal error: pskBinders length mismatch")
-+			return errors.New("tls: internal error: pskBinders length mismatch")
- 		}
- 	}
- 	m.pskBinders = pskBinders
- 	if m.raw != nil {
--		lenWithoutBinders := len(m.marshalWithoutBinders())
-+		helloBytes, err := m.marshalWithoutBinders()
-+		if err != nil {
-+			return err
-+		}
-+		lenWithoutBinders := len(helloBytes)
- 		// TODO(filippo): replace with NewFixedBuilder once CL 148882 is imported.
- 		b := cryptobyte.NewBuilder(m.raw[:lenWithoutBinders])
- 		b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
-@@ -339,9 +346,11 @@ func (m *clientHelloMsg) updateBinders(p
- 			}
- 		})
- 		if len(b.BytesOrPanic()) != len(m.raw) {
--			panic("tls: internal error: failed to update binders")
-+			return errors.New("tls: internal error: failed to update binders")
- 		}
- 	}
-+
-+	return nil
- }
- 
- func (m *clientHelloMsg) unmarshal(data []byte) bool {
-@@ -613,9 +622,98 @@ type serverHelloMsg struct {
- 	selectedGroup CurveID
- }
- 
--func (m *serverHelloMsg) marshal() []byte {
-+func (m *serverHelloMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
-+	}
-+
-+	var exts cryptobyte.Builder
-+	if m.ocspStapling {
-+		exts.AddUint16(extensionStatusRequest)
-+		exts.AddUint16(0) // empty extension_data
-+	}
-+	if m.ticketSupported {
-+		exts.AddUint16(extensionSessionTicket)
-+		exts.AddUint16(0) // empty extension_data
-+	}
-+	if m.secureRenegotiationSupported {
-+		exts.AddUint16(extensionRenegotiationInfo)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.secureRenegotiation)
-+			})
-+		})
-+	}
-+	if len(m.alpnProtocol) > 0 {
-+		exts.AddUint16(extensionALPN)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+					exts.AddBytes([]byte(m.alpnProtocol))
-+				})
-+			})
-+		})
-+	}
-+	if len(m.scts) > 0 {
-+		exts.AddUint16(extensionSCT)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				for _, sct := range m.scts {
-+					exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+						exts.AddBytes(sct)
-+					})
-+				}
-+			})
-+		})
-+	}
-+	if m.supportedVersion != 0 {
-+		exts.AddUint16(extensionSupportedVersions)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16(m.supportedVersion)
-+		})
-+	}
-+	if m.serverShare.group != 0 {
-+		exts.AddUint16(extensionKeyShare)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16(uint16(m.serverShare.group))
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.serverShare.data)
-+			})
-+		})
-+	}
-+	if m.selectedIdentityPresent {
-+		exts.AddUint16(extensionPreSharedKey)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16(m.selectedIdentity)
-+		})
-+	}
-+
-+	if len(m.cookie) > 0 {
-+		exts.AddUint16(extensionCookie)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.cookie)
-+			})
-+		})
-+	}
-+	if m.selectedGroup != 0 {
-+		exts.AddUint16(extensionKeyShare)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint16(uint16(m.selectedGroup))
-+		})
-+	}
-+	if len(m.supportedPoints) > 0 {
-+		exts.AddUint16(extensionSupportedPoints)
-+		exts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {
-+			exts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {
-+				exts.AddBytes(m.supportedPoints)
-+			})
-+		})
-+	}
-+
-+	extBytes, err := exts.Bytes()
-+	if err != nil {
-+		return nil, err
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -629,104 +727,15 @@ func (m *serverHelloMsg) marshal() []byt
- 		b.AddUint16(m.cipherSuite)
- 		b.AddUint8(m.compressionMethod)
- 
--		// If extensions aren't present, omit them.
--		var extensionsPresent bool
--		bWithoutExtensions := *b
--
--		b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--			if m.ocspStapling {
--				b.AddUint16(extensionStatusRequest)
--				b.AddUint16(0) // empty extension_data
--			}
--			if m.ticketSupported {
--				b.AddUint16(extensionSessionTicket)
--				b.AddUint16(0) // empty extension_data
--			}
--			if m.secureRenegotiationSupported {
--				b.AddUint16(extensionRenegotiationInfo)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.secureRenegotiation)
--					})
--				})
--			}
--			if len(m.alpnProtocol) > 0 {
--				b.AddUint16(extensionALPN)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--							b.AddBytes([]byte(m.alpnProtocol))
--						})
--					})
--				})
--			}
--			if len(m.scts) > 0 {
--				b.AddUint16(extensionSCT)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						for _, sct := range m.scts {
--							b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--								b.AddBytes(sct)
--							})
--						}
--					})
--				})
--			}
--			if m.supportedVersion != 0 {
--				b.AddUint16(extensionSupportedVersions)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16(m.supportedVersion)
--				})
--			}
--			if m.serverShare.group != 0 {
--				b.AddUint16(extensionKeyShare)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16(uint16(m.serverShare.group))
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.serverShare.data)
--					})
--				})
--			}
--			if m.selectedIdentityPresent {
--				b.AddUint16(extensionPreSharedKey)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16(m.selectedIdentity)
--				})
--			}
--
--			if len(m.cookie) > 0 {
--				b.AddUint16(extensionCookie)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.cookie)
--					})
--				})
--			}
--			if m.selectedGroup != 0 {
--				b.AddUint16(extensionKeyShare)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint16(uint16(m.selectedGroup))
--				})
--			}
--			if len(m.supportedPoints) > 0 {
--				b.AddUint16(extensionSupportedPoints)
--				b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
--					b.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
--						b.AddBytes(m.supportedPoints)
--					})
--				})
--			}
--
--			extensionsPresent = len(b.BytesOrPanic()) > 2
--		})
--
--		if !extensionsPresent {
--			*b = bWithoutExtensions
-+		if len(extBytes) > 0 {
-+			b.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {
-+				b.AddBytes(extBytes)
-+			})
- 		}
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *serverHelloMsg) unmarshal(data []byte) bool {
-@@ -844,9 +853,9 @@ type encryptedExtensionsMsg struct {
- 	alpnProtocol string
- }
- 
--func (m *encryptedExtensionsMsg) marshal() []byte {
-+func (m *encryptedExtensionsMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -866,8 +875,9 @@ func (m *encryptedExtensionsMsg) marshal
- 		})
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *encryptedExtensionsMsg) unmarshal(data []byte) bool {
-@@ -915,10 +925,10 @@ func (m *encryptedExtensionsMsg) unmarsh
- 
- type endOfEarlyDataMsg struct{}
- 
--func (m *endOfEarlyDataMsg) marshal() []byte {
-+func (m *endOfEarlyDataMsg) marshal() ([]byte, error) {
- 	x := make([]byte, 4)
- 	x[0] = typeEndOfEarlyData
--	return x
-+	return x, nil
- }
- 
- func (m *endOfEarlyDataMsg) unmarshal(data []byte) bool {
-@@ -930,9 +940,9 @@ type keyUpdateMsg struct {
- 	updateRequested bool
- }
- 
--func (m *keyUpdateMsg) marshal() []byte {
-+func (m *keyUpdateMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -945,8 +955,9 @@ func (m *keyUpdateMsg) marshal() []byte
- 		}
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *keyUpdateMsg) unmarshal(data []byte) bool {
-@@ -978,9 +989,9 @@ type newSessionTicketMsgTLS13 struct {
- 	maxEarlyData uint32
- }
- 
--func (m *newSessionTicketMsgTLS13) marshal() []byte {
-+func (m *newSessionTicketMsgTLS13) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -1005,8 +1016,9 @@ func (m *newSessionTicketMsgTLS13) marsh
- 		})
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *newSessionTicketMsgTLS13) unmarshal(data []byte) bool {
-@@ -1059,9 +1071,9 @@ type certificateRequestMsgTLS13 struct {
- 	certificateAuthorities           [][]byte
- }
- 
--func (m *certificateRequestMsgTLS13) marshal() []byte {
-+func (m *certificateRequestMsgTLS13) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -1120,8 +1132,9 @@ func (m *certificateRequestMsgTLS13) mar
- 		})
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *certificateRequestMsgTLS13) unmarshal(data []byte) bool {
-@@ -1205,9 +1218,9 @@ type certificateMsg struct {
- 	certificates [][]byte
- }
- 
--func (m *certificateMsg) marshal() (x []byte) {
-+func (m *certificateMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var i int
-@@ -1216,7 +1229,7 @@ func (m *certificateMsg) marshal() (x []
- 	}
- 
- 	length := 3 + 3*len(m.certificates) + i
--	x = make([]byte, 4+length)
-+	x := make([]byte, 4+length)
- 	x[0] = typeCertificate
- 	x[1] = uint8(length >> 16)
- 	x[2] = uint8(length >> 8)
-@@ -1237,7 +1250,7 @@ func (m *certificateMsg) marshal() (x []
- 	}
- 
- 	m.raw = x
--	return
-+	return m.raw, nil
- }
- 
- func (m *certificateMsg) unmarshal(data []byte) bool {
-@@ -1284,9 +1297,9 @@ type certificateMsgTLS13 struct {
- 	scts         bool
- }
- 
--func (m *certificateMsgTLS13) marshal() []byte {
-+func (m *certificateMsgTLS13) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -1304,8 +1317,9 @@ func (m *certificateMsgTLS13) marshal()
- 		marshalCertificate(b, certificate)
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func marshalCertificate(b *cryptobyte.Builder, certificate Certificate) {
-@@ -1428,9 +1442,9 @@ type serverKeyExchangeMsg struct {
- 	key []byte
- }
- 
--func (m *serverKeyExchangeMsg) marshal() []byte {
-+func (m *serverKeyExchangeMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 	length := len(m.key)
- 	x := make([]byte, length+4)
-@@ -1441,7 +1455,7 @@ func (m *serverKeyExchangeMsg) marshal()
- 	copy(x[4:], m.key)
- 
- 	m.raw = x
--	return x
-+	return x, nil
- }
- 
- func (m *serverKeyExchangeMsg) unmarshal(data []byte) bool {
-@@ -1458,9 +1472,9 @@ type certificateStatusMsg struct {
- 	response []byte
- }
- 
--func (m *certificateStatusMsg) marshal() []byte {
-+func (m *certificateStatusMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -1472,8 +1486,9 @@ func (m *certificateStatusMsg) marshal()
- 		})
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *certificateStatusMsg) unmarshal(data []byte) bool {
-@@ -1492,10 +1507,10 @@ func (m *certificateStatusMsg) unmarshal
- 
- type serverHelloDoneMsg struct{}
- 
--func (m *serverHelloDoneMsg) marshal() []byte {
-+func (m *serverHelloDoneMsg) marshal() ([]byte, error) {
- 	x := make([]byte, 4)
- 	x[0] = typeServerHelloDone
--	return x
-+	return x, nil
- }
- 
- func (m *serverHelloDoneMsg) unmarshal(data []byte) bool {
-@@ -1507,9 +1522,9 @@ type clientKeyExchangeMsg struct {
- 	ciphertext []byte
- }
- 
--func (m *clientKeyExchangeMsg) marshal() []byte {
-+func (m *clientKeyExchangeMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 	length := len(m.ciphertext)
- 	x := make([]byte, length+4)
-@@ -1520,7 +1535,7 @@ func (m *clientKeyExchangeMsg) marshal()
- 	copy(x[4:], m.ciphertext)
- 
- 	m.raw = x
--	return x
-+	return x, nil
- }
- 
- func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {
-@@ -1541,9 +1556,9 @@ type finishedMsg struct {
- 	verifyData []byte
- }
- 
--func (m *finishedMsg) marshal() []byte {
-+func (m *finishedMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -1552,8 +1567,9 @@ func (m *finishedMsg) marshal() []byte {
- 		b.AddBytes(m.verifyData)
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *finishedMsg) unmarshal(data []byte) bool {
-@@ -1575,9 +1591,9 @@ type certificateRequestMsg struct {
- 	certificateAuthorities       [][]byte
- }
- 
--func (m *certificateRequestMsg) marshal() (x []byte) {
-+func (m *certificateRequestMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	// See RFC 4346, Section 7.4.4.
-@@ -1592,7 +1608,7 @@ func (m *certificateRequestMsg) marshal(
- 		length += 2 + 2*len(m.supportedSignatureAlgorithms)
- 	}
- 
--	x = make([]byte, 4+length)
-+	x := make([]byte, 4+length)
- 	x[0] = typeCertificateRequest
- 	x[1] = uint8(length >> 16)
- 	x[2] = uint8(length >> 8)
-@@ -1627,7 +1643,7 @@ func (m *certificateRequestMsg) marshal(
- 	}
- 
- 	m.raw = x
--	return
-+	return m.raw, nil
- }
- 
- func (m *certificateRequestMsg) unmarshal(data []byte) bool {
-@@ -1713,9 +1729,9 @@ type certificateVerifyMsg struct {
- 	signature             []byte
- }
- 
--func (m *certificateVerifyMsg) marshal() (x []byte) {
-+func (m *certificateVerifyMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	var b cryptobyte.Builder
-@@ -1729,8 +1745,9 @@ func (m *certificateVerifyMsg) marshal()
- 		})
- 	})
- 
--	m.raw = b.BytesOrPanic()
--	return m.raw
-+	var err error
-+	m.raw, err = b.Bytes()
-+	return m.raw, err
- }
- 
- func (m *certificateVerifyMsg) unmarshal(data []byte) bool {
-@@ -1753,15 +1770,15 @@ type newSessionTicketMsg struct {
- 	ticket []byte
- }
- 
--func (m *newSessionTicketMsg) marshal() (x []byte) {
-+func (m *newSessionTicketMsg) marshal() ([]byte, error) {
- 	if m.raw != nil {
--		return m.raw
-+		return m.raw, nil
- 	}
- 
- 	// See RFC 5077, Section 3.3.
- 	ticketLen := len(m.ticket)
- 	length := 2 + 4 + ticketLen
--	x = make([]byte, 4+length)
-+	x := make([]byte, 4+length)
- 	x[0] = typeNewSessionTicket
- 	x[1] = uint8(length >> 16)
- 	x[2] = uint8(length >> 8)
-@@ -1772,7 +1789,7 @@ func (m *newSessionTicketMsg) marshal()
- 
- 	m.raw = x
- 
--	return
-+	return m.raw, nil
- }
- 
- func (m *newSessionTicketMsg) unmarshal(data []byte) bool {
-@@ -1800,10 +1817,25 @@ func (m *newSessionTicketMsg) unmarshal(
- type helloRequestMsg struct {
- }
- 
--func (*helloRequestMsg) marshal() []byte {
--	return []byte{typeHelloRequest, 0, 0, 0}
-+func (*helloRequestMsg) marshal() ([]byte, error) {
-+	return []byte{typeHelloRequest, 0, 0, 0}, nil
- }
- 
- func (*helloRequestMsg) unmarshal(data []byte) bool {
- 	return len(data) == 4
- }
-+
-+type transcriptHash interface {
-+	Write([]byte) (int, error)
-+}
-+
-+// transcriptMsg is a helper used to marshal and hash messages which typically
-+// are not written to the wire, and as such aren't hashed during Conn.writeRecord.
-+func transcriptMsg(msg handshakeMessage, h transcriptHash) error {
-+	data, err := msg.marshal()
-+	if err != nil {
-+		return err
-+	}
-+	h.Write(data)
-+	return nil
-+}
---- go.orig/src/crypto/tls/handshake_messages_test.go
-+++ go/src/crypto/tls/handshake_messages_test.go
-@@ -37,6 +37,15 @@ var tests = []interface{}{
- 	&certificateMsgTLS13{},
- }
- 
-+func mustMarshal(t *testing.T, msg handshakeMessage) []byte {
-+	t.Helper()
-+	b, err := msg.marshal()
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	return b
-+}
-+
- func TestMarshalUnmarshal(t *testing.T) {
- 	rand := rand.New(rand.NewSource(time.Now().UnixNano()))
- 
-@@ -55,7 +64,7 @@ func TestMarshalUnmarshal(t *testing.T)
- 			}
- 
- 			m1 := v.Interface().(handshakeMessage)
--			marshaled := m1.marshal()
-+			marshaled := mustMarshal(t, m1)
- 			m2 := iface.(handshakeMessage)
- 			if !m2.unmarshal(marshaled) {
- 				t.Errorf("#%d failed to unmarshal %#v %x", i, m1, marshaled)
-@@ -408,12 +417,12 @@ func TestRejectEmptySCTList(t *testing.T
- 
- 	var random [32]byte
- 	sct := []byte{0x42, 0x42, 0x42, 0x42}
--	serverHello := serverHelloMsg{
-+	serverHello := &serverHelloMsg{
- 		vers:   VersionTLS12,
- 		random: random[:],
- 		scts:   [][]byte{sct},
- 	}
--	serverHelloBytes := serverHello.marshal()
-+	serverHelloBytes := mustMarshal(t, serverHello)
- 
- 	var serverHelloCopy serverHelloMsg
- 	if !serverHelloCopy.unmarshal(serverHelloBytes) {
-@@ -451,12 +460,12 @@ func TestRejectEmptySCT(t *testing.T) {
- 	// not be zero length.
- 
- 	var random [32]byte
--	serverHello := serverHelloMsg{
-+	serverHello := &serverHelloMsg{
- 		vers:   VersionTLS12,
- 		random: random[:],
- 		scts:   [][]byte{nil},
- 	}
--	serverHelloBytes := serverHello.marshal()
-+	serverHelloBytes := mustMarshal(t, serverHello)
- 
- 	var serverHelloCopy serverHelloMsg
- 	if serverHelloCopy.unmarshal(serverHelloBytes) {
---- go.orig/src/crypto/tls/handshake_server.go
-+++ go/src/crypto/tls/handshake_server.go
-@@ -129,7 +129,9 @@ func (hs *serverHandshakeState) handshak
- 
- // readClientHello reads a ClientHello message and selects the protocol version.
- func (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error) {
--	msg, err := c.readHandshake()
-+	// clientHelloMsg is included in the transcript, but we haven't initialized
-+	// it yet. The respective handshake functions will record it themselves.
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return nil, err
- 	}
-@@ -456,9 +458,10 @@ func (hs *serverHandshakeState) doResume
- 	hs.hello.ticketSupported = hs.sessionState.usedOldKey
- 	hs.finishedHash = newFinishedHash(c.vers, hs.suite)
- 	hs.finishedHash.discardHandshakeBuffer()
--	hs.finishedHash.Write(hs.clientHello.marshal())
--	hs.finishedHash.Write(hs.hello.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
-+	if err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {
-+		return err
-+	}
-+	if _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 
-@@ -496,24 +499,23 @@ func (hs *serverHandshakeState) doFullHa
- 		// certificates won't be used.
- 		hs.finishedHash.discardHandshakeBuffer()
- 	}
--	hs.finishedHash.Write(hs.clientHello.marshal())
--	hs.finishedHash.Write(hs.hello.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
-+	if err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {
-+		return err
-+	}
-+	if _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 
- 	certMsg := new(certificateMsg)
- 	certMsg.certificates = hs.cert.Certificate
--	hs.finishedHash.Write(certMsg.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 
- 	if hs.hello.ocspStapling {
- 		certStatus := new(certificateStatusMsg)
- 		certStatus.response = hs.cert.OCSPStaple
--		hs.finishedHash.Write(certStatus.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, certStatus.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(certStatus, &hs.finishedHash); err != nil {
- 			return err
- 		}
- 	}
-@@ -525,8 +527,7 @@ func (hs *serverHandshakeState) doFullHa
- 		return err
- 	}
- 	if skx != nil {
--		hs.finishedHash.Write(skx.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, skx.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(skx, &hs.finishedHash); err != nil {
- 			return err
- 		}
- 	}
-@@ -552,15 +553,13 @@ func (hs *serverHandshakeState) doFullHa
- 		if c.config.ClientCAs != nil {
- 			certReq.certificateAuthorities = c.config.ClientCAs.Subjects()
- 		}
--		hs.finishedHash.Write(certReq.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, certReq.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(certReq, &hs.finishedHash); err != nil {
- 			return err
- 		}
- 	}
- 
- 	helloDone := new(serverHelloDoneMsg)
--	hs.finishedHash.Write(helloDone.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, helloDone.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(helloDone, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 
-@@ -570,7 +569,7 @@ func (hs *serverHandshakeState) doFullHa
- 
- 	var pub crypto.PublicKey // public key for client auth, if any
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(&hs.finishedHash)
- 	if err != nil {
- 		return err
- 	}
-@@ -583,7 +582,6 @@ func (hs *serverHandshakeState) doFullHa
- 			c.sendAlert(alertUnexpectedMessage)
- 			return unexpectedMessageError(certMsg, msg)
- 		}
--		hs.finishedHash.Write(certMsg.marshal())
- 
- 		if err := c.processCertsFromClient(Certificate{
- 			Certificate: certMsg.certificates,
-@@ -594,7 +592,7 @@ func (hs *serverHandshakeState) doFullHa
- 			pub = c.peerCertificates[0].PublicKey
- 		}
- 
--		msg, err = c.readHandshake()
-+		msg, err = c.readHandshake(&hs.finishedHash)
- 		if err != nil {
- 			return err
- 		}
-@@ -612,7 +610,6 @@ func (hs *serverHandshakeState) doFullHa
- 		c.sendAlert(alertUnexpectedMessage)
- 		return unexpectedMessageError(ckx, msg)
- 	}
--	hs.finishedHash.Write(ckx.marshal())
- 
- 	preMasterSecret, err := keyAgreement.processClientKeyExchange(c.config, hs.cert, ckx, c.vers)
- 	if err != nil {
-@@ -632,7 +629,10 @@ func (hs *serverHandshakeState) doFullHa
- 	// to the client's certificate. This allows us to verify that the client is in
- 	// possession of the private key of the certificate.
- 	if len(c.peerCertificates) > 0 {
--		msg, err = c.readHandshake()
-+		// certificateVerifyMsg is included in the transcript, but not until
-+		// after we verify the handshake signature, since the state before
-+		// this message was sent is used.
-+		msg, err = c.readHandshake(nil)
- 		if err != nil {
- 			return err
- 		}
-@@ -667,7 +667,9 @@ func (hs *serverHandshakeState) doFullHa
- 			return errors.New("tls: invalid signature by the client certificate: " + err.Error())
- 		}
- 
--		hs.finishedHash.Write(certVerify.marshal())
-+		if err := transcriptMsg(certVerify, &hs.finishedHash); err != nil {
-+			return err
-+		}
- 	}
- 
- 	hs.finishedHash.discardHandshakeBuffer()
-@@ -707,7 +709,10 @@ func (hs *serverHandshakeState) readFini
- 		return err
- 	}
- 
--	msg, err := c.readHandshake()
-+	// finishedMsg is included in the transcript, but not until after we
-+	// check the client version, since the state before this message was
-+	// sent is used during verification.
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -724,7 +729,10 @@ func (hs *serverHandshakeState) readFini
- 		return errors.New("tls: client's Finished message is incorrect")
- 	}
- 
--	hs.finishedHash.Write(clientFinished.marshal())
-+	if err := transcriptMsg(clientFinished, &hs.finishedHash); err != nil {
-+		return err
-+	}
-+
- 	copy(out, verify)
- 	return nil
- }
-@@ -758,14 +766,16 @@ func (hs *serverHandshakeState) sendSess
- 		masterSecret: hs.masterSecret,
- 		certificates: certsFromClient,
- 	}
--	var err error
--	m.ticket, err = c.encryptTicket(state.marshal())
-+	stateBytes, err := state.marshal()
-+	if err != nil {
-+		return err
-+	}
-+	m.ticket, err = c.encryptTicket(stateBytes)
- 	if err != nil {
- 		return err
- 	}
- 
--	hs.finishedHash.Write(m.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(m, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 
-@@ -775,14 +785,13 @@ func (hs *serverHandshakeState) sendSess
- func (hs *serverHandshakeState) sendFinished(out []byte) error {
- 	c := hs.c
- 
--	if _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil {
-+	if err := c.writeChangeCipherRecord(); err != nil {
- 		return err
- 	}
- 
- 	finished := new(finishedMsg)
- 	finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)
--	hs.finishedHash.Write(finished.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {
- 		return err
- 	}
- 
---- go.orig/src/crypto/tls/handshake_server_test.go
-+++ go/src/crypto/tls/handshake_server_test.go
-@@ -30,6 +30,13 @@ func testClientHello(t *testing.T, serve
- 	testClientHelloFailure(t, serverConfig, m, "")
- }
- 
-+// testFatal is a hack to prevent the compiler from complaining that there is a
-+// call to t.Fatal from a non-test goroutine
-+func testFatal(t *testing.T, err error) {
-+	t.Helper()
-+	t.Fatal(err)
-+}
-+
- func testClientHelloFailure(t *testing.T, serverConfig *Config, m handshakeMessage, expectedSubStr string) {
- 	c, s := localPipe(t)
- 	go func() {
-@@ -37,7 +44,9 @@ func testClientHelloFailure(t *testing.T
- 		if ch, ok := m.(*clientHelloMsg); ok {
- 			cli.vers = ch.vers
- 		}
--		cli.writeRecord(recordTypeHandshake, m.marshal())
-+		if _, err := cli.writeHandshakeRecord(m, nil); err != nil {
-+			testFatal(t, err)
-+		}
- 		c.Close()
- 	}()
- 	ctx := context.Background()
-@@ -194,7 +203,9 @@ func TestRenegotiationExtension(t *testi
- 	go func() {
- 		cli := Client(c, testConfig)
- 		cli.vers = clientHello.vers
--		cli.writeRecord(recordTypeHandshake, clientHello.marshal())
-+		if _, err := cli.writeHandshakeRecord(clientHello, nil); err != nil {
-+			testFatal(t, err)
-+		}
- 
- 		buf := make([]byte, 1024)
- 		n, err := c.Read(buf)
-@@ -253,8 +264,10 @@ func TestTLS12OnlyCipherSuites(t *testin
- 	go func() {
- 		cli := Client(c, testConfig)
- 		cli.vers = clientHello.vers
--		cli.writeRecord(recordTypeHandshake, clientHello.marshal())
--		reply, err := cli.readHandshake()
-+		if _, err := cli.writeHandshakeRecord(clientHello, nil); err != nil {
-+			testFatal(t, err)
-+		}
-+		reply, err := cli.readHandshake(nil)
- 		c.Close()
- 		if err != nil {
- 			replyChan <- err
-@@ -308,8 +321,10 @@ func TestTLSPointFormats(t *testing.T) {
- 			go func() {
- 				cli := Client(c, testConfig)
- 				cli.vers = clientHello.vers
--				cli.writeRecord(recordTypeHandshake, clientHello.marshal())
--				reply, err := cli.readHandshake()
-+				if _, err := cli.writeHandshakeRecord(clientHello, nil); err != nil {
-+					testFatal(t, err)
-+				}
-+				reply, err := cli.readHandshake(nil)
- 				c.Close()
- 				if err != nil {
- 					replyChan <- err
-@@ -1425,7 +1440,9 @@ func TestSNIGivenOnFailure(t *testing.T)
- 	go func() {
- 		cli := Client(c, testConfig)
- 		cli.vers = clientHello.vers
--		cli.writeRecord(recordTypeHandshake, clientHello.marshal())
-+		if _, err := cli.writeHandshakeRecord(clientHello, nil); err != nil {
-+			testFatal(t, err)
-+		}
- 		c.Close()
- 	}()
- 	conn := Server(s, serverConfig)
---- go.orig/src/crypto/tls/handshake_server_tls13.go
-+++ go/src/crypto/tls/handshake_server_tls13.go
-@@ -298,7 +298,12 @@ func (hs *serverHandshakeStateTLS13) che
- 			c.sendAlert(alertInternalError)
- 			return errors.New("tls: internal error: failed to clone hash")
- 		}
--		transcript.Write(hs.clientHello.marshalWithoutBinders())
-+		clientHelloBytes, err := hs.clientHello.marshalWithoutBinders()
-+		if err != nil {
-+			c.sendAlert(alertInternalError)
-+			return err
-+		}
-+		transcript.Write(clientHelloBytes)
- 		pskBinder := hs.suite.finishedHash(binderKey, transcript)
- 		if !hmac.Equal(hs.clientHello.pskBinders[i], pskBinder) {
- 			c.sendAlert(alertDecryptError)
-@@ -389,8 +394,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 	}
- 	hs.sentDummyCCS = true
- 
--	_, err := hs.c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
--	return err
-+	return hs.c.writeChangeCipherRecord()
- }
- 
- func (hs *serverHandshakeStateTLS13) doHelloRetryRequest(selectedGroup CurveID) error {
-@@ -398,7 +402,9 @@ func (hs *serverHandshakeStateTLS13) doH
- 
- 	// The first ClientHello gets double-hashed into the transcript upon a
- 	// HelloRetryRequest. See RFC 8446, Section 4.4.1.
--	hs.transcript.Write(hs.clientHello.marshal())
-+	if err := transcriptMsg(hs.clientHello, hs.transcript); err != nil {
-+		return err
-+	}
- 	chHash := hs.transcript.Sum(nil)
- 	hs.transcript.Reset()
- 	hs.transcript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})
-@@ -414,8 +420,7 @@ func (hs *serverHandshakeStateTLS13) doH
- 		selectedGroup:     selectedGroup,
- 	}
- 
--	hs.transcript.Write(helloRetryRequest.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, helloRetryRequest.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(helloRetryRequest, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -423,7 +428,8 @@ func (hs *serverHandshakeStateTLS13) doH
- 		return err
- 	}
- 
--	msg, err := c.readHandshake()
-+	// clientHelloMsg is not included in the transcript.
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
-@@ -514,9 +520,10 @@ func illegalClientHelloChange(ch, ch1 *c
- func (hs *serverHandshakeStateTLS13) sendServerParameters() error {
- 	c := hs.c
- 
--	hs.transcript.Write(hs.clientHello.marshal())
--	hs.transcript.Write(hs.hello.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
-+	if err := transcriptMsg(hs.clientHello, hs.transcript); err != nil {
-+		return err
-+	}
-+	if _, err := hs.c.writeHandshakeRecord(hs.hello, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -559,8 +566,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 	encryptedExtensions.alpnProtocol = selectedProto
- 	c.clientProtocol = selectedProto
- 
--	hs.transcript.Write(encryptedExtensions.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, encryptedExtensions.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(encryptedExtensions, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -589,8 +595,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 			certReq.certificateAuthorities = c.config.ClientCAs.Subjects()
- 		}
- 
--		hs.transcript.Write(certReq.marshal())
--		if _, err := c.writeRecord(recordTypeHandshake, certReq.marshal()); err != nil {
-+		if _, err := hs.c.writeHandshakeRecord(certReq, hs.transcript); err != nil {
- 			return err
- 		}
- 	}
-@@ -601,8 +606,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 	certMsg.scts = hs.clientHello.scts && len(hs.cert.SignedCertificateTimestamps) > 0
- 	certMsg.ocspStapling = hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0
- 
--	hs.transcript.Write(certMsg.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(certMsg, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -633,8 +637,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 	}
- 	certVerifyMsg.signature = sig
- 
--	hs.transcript.Write(certVerifyMsg.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, certVerifyMsg.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(certVerifyMsg, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -648,8 +651,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 		verifyData: hs.suite.finishedHash(c.out.trafficSecret, hs.transcript),
- 	}
- 
--	hs.transcript.Write(finished.marshal())
--	if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {
-+	if _, err := hs.c.writeHandshakeRecord(finished, hs.transcript); err != nil {
- 		return err
- 	}
- 
-@@ -710,7 +712,9 @@ func (hs *serverHandshakeStateTLS13) sen
- 	finishedMsg := &finishedMsg{
- 		verifyData: hs.clientFinished,
- 	}
--	hs.transcript.Write(finishedMsg.marshal())
-+	if err := transcriptMsg(finishedMsg, hs.transcript); err != nil {
-+		return err
-+	}
- 
- 	if !hs.shouldSendSessionTickets() {
- 		return nil
-@@ -735,8 +739,12 @@ func (hs *serverHandshakeStateTLS13) sen
- 			SignedCertificateTimestamps: c.scts,
- 		},
- 	}
--	var err error
--	m.label, err = c.encryptTicket(state.marshal())
-+	stateBytes, err := state.marshal()
-+	if err != nil {
-+		c.sendAlert(alertInternalError)
-+		return err
-+	}
-+	m.label, err = c.encryptTicket(stateBytes)
- 	if err != nil {
- 		return err
- 	}
-@@ -755,7 +763,7 @@ func (hs *serverHandshakeStateTLS13) sen
- 	// ticket_nonce, which must be unique per connection, is always left at
- 	// zero because we only ever send one ticket per connection.
- 
--	if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil {
-+	if _, err := c.writeHandshakeRecord(m, nil); err != nil {
- 		return err
- 	}
- 
-@@ -780,7 +788,7 @@ func (hs *serverHandshakeStateTLS13) rea
- 	// If we requested a client certificate, then the client must send a
- 	// certificate message. If it's empty, no CertificateVerify is sent.
- 
--	msg, err := c.readHandshake()
-+	msg, err := c.readHandshake(hs.transcript)
- 	if err != nil {
- 		return err
- 	}
-@@ -790,7 +798,6 @@ func (hs *serverHandshakeStateTLS13) rea
- 		c.sendAlert(alertUnexpectedMessage)
- 		return unexpectedMessageError(certMsg, msg)
- 	}
--	hs.transcript.Write(certMsg.marshal())
- 
- 	if err := c.processCertsFromClient(certMsg.certificate); err != nil {
- 		return err
-@@ -804,7 +811,10 @@ func (hs *serverHandshakeStateTLS13) rea
- 	}
- 
- 	if len(certMsg.certificate.Certificate) != 0 {
--		msg, err = c.readHandshake()
-+		// certificateVerifyMsg is included in the transcript, but not until
-+		// after we verify the handshake signature, since the state before
-+		// this message was sent is used.
-+		msg, err = c.readHandshake(nil)
- 		if err != nil {
- 			return err
- 		}
-@@ -835,7 +845,9 @@ func (hs *serverHandshakeStateTLS13) rea
- 			return errors.New("tls: invalid signature by the client certificate: " + err.Error())
- 		}
- 
--		hs.transcript.Write(certVerify.marshal())
-+		if err := transcriptMsg(certVerify, hs.transcript); err != nil {
-+			return err
-+		}
- 	}
- 
- 	// If we waited until the client certificates to send session tickets, we
-@@ -850,7 +862,8 @@ func (hs *serverHandshakeStateTLS13) rea
- func (hs *serverHandshakeStateTLS13) readClientFinished() error {
- 	c := hs.c
- 
--	msg, err := c.readHandshake()
-+	// finishedMsg is not included in the transcript.
-+	msg, err := c.readHandshake(nil)
- 	if err != nil {
- 		return err
- 	}
---- go.orig/src/crypto/tls/key_schedule.go
-+++ go/src/crypto/tls/key_schedule.go
-@@ -8,6 +8,7 @@ import (
- 	"crypto/elliptic"
- 	"crypto/hmac"
- 	"errors"
-+	"fmt"
- 	"hash"
- 	"io"
- 	"math/big"
-@@ -42,8 +43,24 @@ func (c *cipherSuiteTLS13) expandLabel(s
- 	hkdfLabel.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {
- 		b.AddBytes(context)
- 	})
-+	hkdfLabelBytes, err := hkdfLabel.Bytes()
-+	if err != nil {
-+		// Rather than calling BytesOrPanic, we explicitly handle this error, in
-+		// order to provide a reasonable error message. It should be basically
-+		// impossible for this to panic, and routing errors back through the
-+		// tree rooted in this function is quite painful. The labels are fixed
-+		// size, and the context is either a fixed-length computed hash, or
-+		// parsed from a field which has the same length limitation. As such, an
-+		// error here is likely to only be caused during development.
-+		//
-+		// NOTE: another reasonable approach here might be to return a
-+		// randomized slice if we encounter an error, which would break the
-+		// connection, but avoid panicking. This would perhaps be safer but
-+		// significantly more confusing to users.
-+		panic(fmt.Errorf("failed to construct HKDF label: %s", err))
-+	}
- 	out := make([]byte, length)
--	n, err := hkdf.Expand(c.hash.New, secret, hkdfLabel.BytesOrPanic()).Read(out)
-+	n, err := hkdf.Expand(c.hash.New, secret, hkdfLabelBytes).Read(out)
- 	if err != nil || n != length {
- 		panic("tls: HKDF-Expand-Label invocation failed unexpectedly")
- 	}
---- go.orig/src/crypto/tls/ticket.go
-+++ go/src/crypto/tls/ticket.go
-@@ -32,7 +32,7 @@ type sessionState struct {
- 	usedOldKey bool
- }
- 
--func (m *sessionState) marshal() []byte {
-+func (m *sessionState) marshal() ([]byte, error) {
- 	var b cryptobyte.Builder
- 	b.AddUint16(m.vers)
- 	b.AddUint16(m.cipherSuite)
-@@ -47,7 +47,7 @@ func (m *sessionState) marshal() []byte
- 			})
- 		}
- 	})
--	return b.BytesOrPanic()
-+	return b.Bytes()
- }
- 
- func (m *sessionState) unmarshal(data []byte) bool {
-@@ -86,7 +86,7 @@ type sessionStateTLS13 struct {
- 	certificate      Certificate // CertificateEntry certificate_list<0..2^24-1>;
- }
- 
--func (m *sessionStateTLS13) marshal() []byte {
-+func (m *sessionStateTLS13) marshal() ([]byte, error) {
- 	var b cryptobyte.Builder
- 	b.AddUint16(VersionTLS13)
- 	b.AddUint8(0) // revision
-@@ -96,7 +96,7 @@ func (m *sessionStateTLS13) marshal() []
- 		b.AddBytes(m.resumptionSecret)
- 	})
- 	marshalCertificate(&b, m.certificate)
--	return b.BytesOrPanic()
-+	return b.Bytes()
- }
- 
- func (m *sessionStateTLS13) unmarshal(data []byte) bool {
diff --git a/meta/recipes-devtools/go/go-1.19/cve-2022-41725.patch b/meta/recipes-devtools/go/go-1.19/cve-2022-41725.patch
deleted file mode 100644
index a71d07e3f1..0000000000
--- a/meta/recipes-devtools/go/go-1.19/cve-2022-41725.patch
+++ /dev/null
@@ -1,652 +0,0 @@
-From 5c55ac9bf1e5f779220294c843526536605f42ab Mon Sep 17 00:00:00 2001
-From: Damien Neil <dneil@google.com>
-Date: Wed, 25 Jan 2023 09:27:01 -0800
-Subject: [PATCH] [release-branch.go1.19] mime/multipart: limit memory/inode
- consumption of ReadForm
-
-Reader.ReadForm is documented as storing "up to maxMemory bytes + 10MB"
-in memory. Parsed forms can consume substantially more memory than
-this limit, since ReadForm does not account for map entry overhead
-and MIME headers.
-
-In addition, while the amount of disk memory consumed by ReadForm can
-be constrained by limiting the size of the parsed input, ReadForm will
-create one temporary file per form part stored on disk, potentially
-consuming a large number of inodes.
-
-Update ReadForm's memory accounting to include part names,
-MIME headers, and map entry overhead.
-
-Update ReadForm to store all on-disk file parts in a single
-temporary file.
-
-Files returned by FileHeader.Open are documented as having a concrete
-type of *os.File when a file is stored on disk. The change to use a
-single temporary file for all parts means that this is no longer the
-case when a form contains more than a single file part stored on disk.
-
-The previous behavior of storing each file part in a separate disk
-file may be reenabled with GODEBUG=multipartfiles=distinct.
-
-Update Reader.NextPart and Reader.NextRawPart to set a 10MiB cap
-on the size of MIME headers.
-
-Thanks to Jakob Ackermann (@das7pad) for reporting this issue.
-
-Updates #58006
-Fixes #58362
-Fixes CVE-2022-41725
-
-Change-Id: Ibd780a6c4c83ac8bcfd3cbe344f042e9940f2eab
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1714276
-Reviewed-by: Julie Qiu <julieqiu@google.com>
-TryBot-Result: Security TryBots <security-trybots@go-security-trybots.iam.gserviceaccount.com>
-Reviewed-by: Roland Shoemaker <bracewell@google.com>
-Run-TryBot: Damien Neil <dneil@google.com>
-(cherry picked from commit ed4664330edcd91b24914c9371c377c132dbce8c)
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1728949
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-on: https://go-review.googlesource.com/c/go/+/468116
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Than McIntosh <thanm@google.com>
-Run-TryBot: Michael Pratt <mpratt@google.com>
-Auto-Submit: Michael Pratt <mpratt@google.com>
----
-
-CVE: CVE-2022-41725
-
-Upstream-Status: Backport [see text]
-
-https://github.com/golong/go.git commit 5c55ac9bf1e5...
-modified for reader.go
-
-Signed-off-by: Joe Slater <joe.slater@windriver.com>
-
-___
- src/mime/multipart/formdata.go       | 132 ++++++++++++++++++++-----
- src/mime/multipart/formdata_test.go  | 140 ++++++++++++++++++++++++++-
- src/mime/multipart/multipart.go      |  25 +++--
- src/mime/multipart/readmimeheader.go |  14 +++
- src/net/http/request_test.go         |   2 +-
- src/net/textproto/reader.go          |  20 +++-
- 6 files changed, 295 insertions(+), 38 deletions(-)
- create mode 100644 src/mime/multipart/readmimeheader.go
-
---- go.orig/src/mime/multipart/formdata.go
-+++ go/src/mime/multipart/formdata.go
-@@ -7,6 +7,7 @@ package multipart
- import (
- 	"bytes"
- 	"errors"
-+	"internal/godebug"
- 	"io"
- 	"math"
- 	"net/textproto"
-@@ -33,23 +34,58 @@ func (r *Reader) ReadForm(maxMemory int6
- 
- func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
- 	form := &Form{make(map[string][]string), make(map[string][]*FileHeader)}
-+	var (
-+		file    *os.File
-+		fileOff int64
-+	)
-+	numDiskFiles := 0
-+	multipartFiles := godebug.Get("multipartfiles")
-+	combineFiles := multipartFiles != "distinct"
- 	defer func() {
-+		if file != nil {
-+			if cerr := file.Close(); err == nil {
-+				err = cerr
-+			}
-+		}
-+		if combineFiles && numDiskFiles > 1 {
-+			for _, fhs := range form.File {
-+				for _, fh := range fhs {
-+					fh.tmpshared = true
-+				}
-+			}
-+		}
- 		if err != nil {
- 			form.RemoveAll()
-+			if file != nil {
-+				os.Remove(file.Name())
-+			}
- 		}
- 	}()
- 
--	// Reserve an additional 10 MB for non-file parts.
--	maxValueBytes := maxMemory + int64(10<<20)
--	if maxValueBytes <= 0 {
-+	// maxFileMemoryBytes is the maximum bytes of file data we will store in memory.
-+	// Data past this limit is written to disk.
-+	// This limit strictly applies to content, not metadata (filenames, MIME headers, etc.),
-+	// since metadata is always stored in memory, not disk.
-+	//
-+	// maxMemoryBytes is the maximum bytes we will store in memory, including file content,
-+	// non-file part values, metdata, and map entry overhead.
-+	//
-+	// We reserve an additional 10 MB in maxMemoryBytes for non-file data.
-+	//
-+	// The relationship between these parameters, as well as the overly-large and
-+	// unconfigurable 10 MB added on to maxMemory, is unfortunate but difficult to change
-+	// within the constraints of the API as documented.
-+	maxFileMemoryBytes := maxMemory
-+	maxMemoryBytes := maxMemory + int64(10<<20)
-+	if maxMemoryBytes <= 0 {
- 		if maxMemory < 0 {
--			maxValueBytes = 0
-+			maxMemoryBytes = 0
- 		} else {
--			maxValueBytes = math.MaxInt64
-+			maxMemoryBytes = math.MaxInt64
- 		}
- 	}
- 	for {
--		p, err := r.NextPart()
-+		p, err := r.nextPart(false, maxMemoryBytes)
- 		if err == io.EOF {
- 			break
- 		}
-@@ -63,16 +99,27 @@ func (r *Reader) readForm(maxMemory int6
- 		}
- 		filename := p.FileName()
- 
-+		// Multiple values for the same key (one map entry, longer slice) are cheaper
-+		// than the same number of values for different keys (many map entries), but
-+		// using a consistent per-value cost for overhead is simpler.
-+		maxMemoryBytes -= int64(len(name))
-+		maxMemoryBytes -= 100 // map overhead
-+		if maxMemoryBytes < 0 {
-+			// We can't actually take this path, since nextPart would already have
-+			// rejected the MIME headers for being too large. Check anyway.
-+			return nil, ErrMessageTooLarge
-+		}
-+
- 		var b bytes.Buffer
- 
- 		if filename == "" {
- 			// value, store as string in memory
--			n, err := io.CopyN(&b, p, maxValueBytes+1)
-+			n, err := io.CopyN(&b, p, maxMemoryBytes+1)
- 			if err != nil && err != io.EOF {
- 				return nil, err
- 			}
--			maxValueBytes -= n
--			if maxValueBytes < 0 {
-+			maxMemoryBytes -= n
-+			if maxMemoryBytes < 0 {
- 				return nil, ErrMessageTooLarge
- 			}
- 			form.Value[name] = append(form.Value[name], b.String())
-@@ -80,35 +127,45 @@ func (r *Reader) readForm(maxMemory int6
- 		}
- 
- 		// file, store in memory or on disk
-+		maxMemoryBytes -= mimeHeaderSize(p.Header)
-+		if maxMemoryBytes < 0 {
-+			return nil, ErrMessageTooLarge
-+		}
- 		fh := &FileHeader{
- 			Filename: filename,
- 			Header:   p.Header,
- 		}
--		n, err := io.CopyN(&b, p, maxMemory+1)
-+		n, err := io.CopyN(&b, p, maxFileMemoryBytes+1)
- 		if err != nil && err != io.EOF {
- 			return nil, err
- 		}
--		if n > maxMemory {
--			// too big, write to disk and flush buffer
--			file, err := os.CreateTemp("", "multipart-")
--			if err != nil {
--				return nil, err
-+		if n > maxFileMemoryBytes {
-+			if file == nil {
-+				file, err = os.CreateTemp(r.tempDir, "multipart-")
-+				if err != nil {
-+					return nil, err
-+				}
- 			}
-+			numDiskFiles++
- 			size, err := io.Copy(file, io.MultiReader(&b, p))
--			if cerr := file.Close(); err == nil {
--				err = cerr
--			}
- 			if err != nil {
--				os.Remove(file.Name())
- 				return nil, err
- 			}
- 			fh.tmpfile = file.Name()
- 			fh.Size = size
-+			fh.tmpoff = fileOff
-+			fileOff += size
-+			if !combineFiles {
-+				if err := file.Close(); err != nil {
-+					return nil, err
-+				}
-+				file = nil
-+			}
- 		} else {
- 			fh.content = b.Bytes()
- 			fh.Size = int64(len(fh.content))
--			maxMemory -= n
--			maxValueBytes -= n
-+			maxFileMemoryBytes -= n
-+			maxMemoryBytes -= n
- 		}
- 		form.File[name] = append(form.File[name], fh)
- 	}
-@@ -116,6 +173,17 @@ func (r *Reader) readForm(maxMemory int6
- 	return form, nil
- }
- 
-+func mimeHeaderSize(h textproto.MIMEHeader) (size int64) {
-+	for k, vs := range h {
-+		size += int64(len(k))
-+		size += 100 // map entry overhead
-+		for _, v := range vs {
-+			size += int64(len(v))
-+		}
-+	}
-+	return size
-+}
-+
- // Form is a parsed multipart form.
- // Its File parts are stored either in memory or on disk,
- // and are accessible via the *FileHeader's Open method.
-@@ -133,7 +201,7 @@ func (f *Form) RemoveAll() error {
- 		for _, fh := range fhs {
- 			if fh.tmpfile != "" {
- 				e := os.Remove(fh.tmpfile)
--				if e != nil && err == nil {
-+				if e != nil && !errors.Is(e, os.ErrNotExist) && err == nil {
- 					err = e
- 				}
- 			}
-@@ -148,15 +216,25 @@ type FileHeader struct {
- 	Header   textproto.MIMEHeader
- 	Size     int64
- 
--	content []byte
--	tmpfile string
-+	content   []byte
-+	tmpfile   string
-+	tmpoff    int64
-+	tmpshared bool
- }
- 
- // Open opens and returns the FileHeader's associated File.
- func (fh *FileHeader) Open() (File, error) {
- 	if b := fh.content; b != nil {
- 		r := io.NewSectionReader(bytes.NewReader(b), 0, int64(len(b)))
--		return sectionReadCloser{r}, nil
-+		return sectionReadCloser{r, nil}, nil
-+	}
-+	if fh.tmpshared {
-+		f, err := os.Open(fh.tmpfile)
-+		if err != nil {
-+			return nil, err
-+		}
-+		r := io.NewSectionReader(f, fh.tmpoff, fh.Size)
-+		return sectionReadCloser{r, f}, nil
- 	}
- 	return os.Open(fh.tmpfile)
- }
-@@ -175,8 +253,12 @@ type File interface {
- 
- type sectionReadCloser struct {
- 	*io.SectionReader
-+	io.Closer
- }
- 
- func (rc sectionReadCloser) Close() error {
-+	if rc.Closer != nil {
-+		return rc.Closer.Close()
-+	}
- 	return nil
- }
---- go.orig/src/mime/multipart/formdata_test.go
-+++ go/src/mime/multipart/formdata_test.go
-@@ -6,8 +6,10 @@ package multipart
- 
- import (
- 	"bytes"
-+	"fmt"
- 	"io"
- 	"math"
-+	"net/textproto"
- 	"os"
- 	"strings"
- 	"testing"
-@@ -208,8 +210,8 @@ Content-Disposition: form-data; name="la
- 		maxMemory int64
- 		err       error
- 	}{
--		{"smaller", 50, nil},
--		{"exact-fit", 25, nil},
-+		{"smaller", 50 + int64(len("largetext")) + 100, nil},
-+		{"exact-fit", 25 + int64(len("largetext")) + 100, nil},
- 		{"too-large", 0, ErrMessageTooLarge},
- 	}
- 	for _, tc := range testCases {
-@@ -224,7 +226,7 @@ Content-Disposition: form-data; name="la
- 				defer f.RemoveAll()
- 			}
- 			if tc.err != err {
--				t.Fatalf("ReadForm error - got: %v; expected: %v", tc.err, err)
-+				t.Fatalf("ReadForm error - got: %v; expected: %v", err, tc.err)
- 			}
- 			if err == nil {
- 				if g := f.Value["largetext"][0]; g != largeTextValue {
-@@ -234,3 +236,135 @@ Content-Disposition: form-data; name="la
- 		})
- 	}
- }
-+
-+// TestReadForm_MetadataTooLarge verifies that we account for the size of field names,
-+// MIME headers, and map entry overhead while limiting the memory consumption of parsed forms.
-+func TestReadForm_MetadataTooLarge(t *testing.T) {
-+	for _, test := range []struct {
-+		name string
-+		f    func(*Writer)
-+	}{{
-+		name: "large name",
-+		f: func(fw *Writer) {
-+			name := strings.Repeat("a", 10<<20)
-+			w, _ := fw.CreateFormField(name)
-+			w.Write([]byte("value"))
-+		},
-+	}, {
-+		name: "large MIME header",
-+		f: func(fw *Writer) {
-+			h := make(textproto.MIMEHeader)
-+			h.Set("Content-Disposition", `form-data; name="a"`)
-+			h.Set("X-Foo", strings.Repeat("a", 10<<20))
-+			w, _ := fw.CreatePart(h)
-+			w.Write([]byte("value"))
-+		},
-+	}, {
-+		name: "many parts",
-+		f: func(fw *Writer) {
-+			for i := 0; i < 110000; i++ {
-+				w, _ := fw.CreateFormField("f")
-+				w.Write([]byte("v"))
-+			}
-+		},
-+	}} {
-+		t.Run(test.name, func(t *testing.T) {
-+			var buf bytes.Buffer
-+			fw := NewWriter(&buf)
-+			test.f(fw)
-+			if err := fw.Close(); err != nil {
-+				t.Fatal(err)
-+			}
-+			fr := NewReader(&buf, fw.Boundary())
-+			_, err := fr.ReadForm(0)
-+			if err != ErrMessageTooLarge {
-+				t.Errorf("fr.ReadForm() = %v, want ErrMessageTooLarge", err)
-+			}
-+		})
-+	}
-+}
-+
-+// TestReadForm_ManyFiles_Combined tests that a multipart form containing many files only
-+// results in a single on-disk file.
-+func TestReadForm_ManyFiles_Combined(t *testing.T) {
-+	const distinct = false
-+	testReadFormManyFiles(t, distinct)
-+}
-+
-+// TestReadForm_ManyFiles_Distinct tests that setting GODEBUG=multipartfiles=distinct
-+// results in every file in a multipart form being placed in a distinct on-disk file.
-+func TestReadForm_ManyFiles_Distinct(t *testing.T) {
-+	t.Setenv("GODEBUG", "multipartfiles=distinct")
-+	const distinct = true
-+	testReadFormManyFiles(t, distinct)
-+}
-+
-+func testReadFormManyFiles(t *testing.T, distinct bool) {
-+	var buf bytes.Buffer
-+	fw := NewWriter(&buf)
-+	const numFiles = 10
-+	for i := 0; i < numFiles; i++ {
-+		name := fmt.Sprint(i)
-+		w, err := fw.CreateFormFile(name, name)
-+		if err != nil {
-+			t.Fatal(err)
-+		}
-+		w.Write([]byte(name))
-+	}
-+	if err := fw.Close(); err != nil {
-+		t.Fatal(err)
-+	}
-+	fr := NewReader(&buf, fw.Boundary())
-+	fr.tempDir = t.TempDir()
-+	form, err := fr.ReadForm(0)
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	for i := 0; i < numFiles; i++ {
-+		name := fmt.Sprint(i)
-+		if got := len(form.File[name]); got != 1 {
-+			t.Fatalf("form.File[%q] has %v entries, want 1", name, got)
-+		}
-+		fh := form.File[name][0]
-+		file, err := fh.Open()
-+		if err != nil {
-+			t.Fatalf("form.File[%q].Open() = %v", name, err)
-+		}
-+		if distinct {
-+			if _, ok := file.(*os.File); !ok {
-+				t.Fatalf("form.File[%q].Open: %T, want *os.File", name, file)
-+			}
-+		}
-+		got, err := io.ReadAll(file)
-+		file.Close()
-+		if string(got) != name || err != nil {
-+			t.Fatalf("read form.File[%q]: %q, %v; want %q, nil", name, string(got), err, name)
-+		}
-+	}
-+	dir, err := os.Open(fr.tempDir)
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	defer dir.Close()
-+	names, err := dir.Readdirnames(0)
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	wantNames := 1
-+	if distinct {
-+		wantNames = numFiles
-+	}
-+	if len(names) != wantNames {
-+		t.Fatalf("temp dir contains %v files; want 1", len(names))
-+	}
-+	if err := form.RemoveAll(); err != nil {
-+		t.Fatalf("form.RemoveAll() = %v", err)
-+	}
-+	names, err = dir.Readdirnames(0)
-+	if err != nil {
-+		t.Fatal(err)
-+	}
-+	if len(names) != 0 {
-+		t.Fatalf("temp dir contains %v files; want 0", len(names))
-+	}
-+}
---- go.orig/src/mime/multipart/multipart.go
-+++ go/src/mime/multipart/multipart.go
-@@ -128,12 +128,12 @@ func (r *stickyErrorReader) Read(p []byt
- 	return n, r.err
- }
- 
--func newPart(mr *Reader, rawPart bool) (*Part, error) {
-+func newPart(mr *Reader, rawPart bool, maxMIMEHeaderSize int64) (*Part, error) {
- 	bp := &Part{
- 		Header: make(map[string][]string),
- 		mr:     mr,
- 	}
--	if err := bp.populateHeaders(); err != nil {
-+	if err := bp.populateHeaders(maxMIMEHeaderSize); err != nil {
- 		return nil, err
- 	}
- 	bp.r = partReader{bp}
-@@ -149,12 +149,16 @@ func newPart(mr *Reader, rawPart bool) (
- 	return bp, nil
- }
- 
--func (bp *Part) populateHeaders() error {
-+func (bp *Part) populateHeaders(maxMIMEHeaderSize int64) error {
- 	r := textproto.NewReader(bp.mr.bufReader)
--	header, err := r.ReadMIMEHeader()
-+	header, err := readMIMEHeader(r, maxMIMEHeaderSize)
- 	if err == nil {
- 		bp.Header = header
- 	}
-+	// TODO: Add a distinguishable error to net/textproto.
-+	if err != nil && err.Error() == "message too large" {
-+		err = ErrMessageTooLarge
-+	}
- 	return err
- }
- 
-@@ -294,6 +298,7 @@ func (p *Part) Close() error {
- // isn't supported.
- type Reader struct {
- 	bufReader *bufio.Reader
-+	tempDir   string // used in tests
- 
- 	currentPart *Part
- 	partsRead   int
-@@ -304,6 +309,10 @@ type Reader struct {
- 	dashBoundary     []byte // "--boundary"
- }
- 
-+// maxMIMEHeaderSize is the maximum size of a MIME header we will parse,
-+// including header keys, values, and map overhead.
-+const maxMIMEHeaderSize = 10 << 20
-+
- // NextPart returns the next part in the multipart or an error.
- // When there are no more parts, the error io.EOF is returned.
- //
-@@ -311,7 +320,7 @@ type Reader struct {
- // has a value of "quoted-printable", that header is instead
- // hidden and the body is transparently decoded during Read calls.
- func (r *Reader) NextPart() (*Part, error) {
--	return r.nextPart(false)
-+	return r.nextPart(false, maxMIMEHeaderSize)
- }
- 
- // NextRawPart returns the next part in the multipart or an error.
-@@ -320,10 +329,10 @@ func (r *Reader) NextPart() (*Part, erro
- // Unlike NextPart, it does not have special handling for
- // "Content-Transfer-Encoding: quoted-printable".
- func (r *Reader) NextRawPart() (*Part, error) {
--	return r.nextPart(true)
-+	return r.nextPart(true, maxMIMEHeaderSize)
- }
- 
--func (r *Reader) nextPart(rawPart bool) (*Part, error) {
-+func (r *Reader) nextPart(rawPart bool, maxMIMEHeaderSize int64) (*Part, error) {
- 	if r.currentPart != nil {
- 		r.currentPart.Close()
- 	}
-@@ -348,7 +357,7 @@ func (r *Reader) nextPart(rawPart bool)
- 
- 		if r.isBoundaryDelimiterLine(line) {
- 			r.partsRead++
--			bp, err := newPart(r, rawPart)
-+			bp, err := newPart(r, rawPart, maxMIMEHeaderSize)
- 			if err != nil {
- 				return nil, err
- 			}
---- /dev/null
-+++ go/src/mime/multipart/readmimeheader.go
-@@ -0,0 +1,14 @@
-+// Copyright 2023 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+package multipart
-+
-+import (
-+	"net/textproto"
-+	_ "unsafe" // for go:linkname
-+)
-+
-+// readMIMEHeader is defined in package net/textproto.
-+//
-+//go:linkname readMIMEHeader net/textproto.readMIMEHeader
-+func readMIMEHeader(r *textproto.Reader, lim int64) (textproto.MIMEHeader, error)
---- go.orig/src/net/http/request_test.go
-+++ go/src/net/http/request_test.go
-@@ -1110,7 +1110,7 @@ func testMissingFile(t *testing.T, req *
- 		t.Errorf("FormFile file = %v, want nil", f)
- 	}
- 	if fh != nil {
--		t.Errorf("FormFile file header = %q, want nil", fh)
-+		t.Errorf("FormFile file header = %v, want nil", fh)
- 	}
- 	if err != ErrMissingFile {
- 		t.Errorf("FormFile err = %q, want ErrMissingFile", err)
---- go.orig/src/net/textproto/reader.go
-+++ go/src/net/textproto/reader.go
-@@ -7,8 +7,10 @@ package textproto
- import (
- 	"bufio"
- 	"bytes"
-+	"errors"
- 	"fmt"
- 	"io"
-+	"math"
- 	"strconv"
- 	"strings"
- 	"sync"
-@@ -481,6 +483,12 @@ func (r *Reader) ReadDotLines() ([]strin
- //	}
- //
- func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {
-+	return readMIMEHeader(r, math.MaxInt64)
-+}
-+
-+// readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.
-+// It is called by the mime/multipart package.
-+func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
- 	// Avoid lots of small slice allocations later by allocating one
- 	// large one ahead of time which we'll cut up into smaller
- 	// slices. If this isn't big enough later, we allocate small ones.
-@@ -521,6 +529,16 @@ func (r *Reader) ReadMIMEHeader() (MIMEH
- 			continue
- 		}
- 
-+		// backport 5c55ac9bf1e5f779220294c843526536605f42ab
-+		//
-+		// value is computed as
-+		//
-+		// value := string(bytes.TrimLeft(v, " \t"))
-+		//
-+		// in the original patch from 1.19.  This relies on
-+		// 'v' which does not exist in 1.17.  We leave the
-+		// 1.17 method unchanged.
-+
- 		// Skip initial spaces in value.
- 		i++ // skip colon
- 		for i < len(kv) && (kv[i] == ' ' || kv[i] == '\t') {
-@@ -529,6 +547,16 @@ func (r *Reader) ReadMIMEHeader() (MIMEH
- 		value := string(kv[i:])
- 
- 		vv := m[key]
-+		if vv == nil {
-+			lim -= int64(len(key))
-+			lim -= 100 // map entry overhead
-+		}
-+		lim -= int64(len(value))
-+		if lim < 0 {
-+			// TODO: This should be a distinguishable error (ErrMessageTooLarge)
-+			// to allow mime/multipart to detect it.
-+			return m, errors.New("message too large")
-+		}
- 		if vv == nil && len(strs) > 0 {
- 			// More than likely this will be a single-element key.
- 			// Most headers aren't multi-valued.
diff --git a/meta/recipes-devtools/go/go-1.20.10.inc b/meta/recipes-devtools/go/go-1.20.10.inc
new file mode 100644
index 0000000000..39509ed986
--- /dev/null
+++ b/meta/recipes-devtools/go/go-1.20.10.inc
@@ -0,0 +1,18 @@
+require go-common.inc
+
+FILESEXTRAPATHS:prepend := "${FILE_DIRNAME}/go:"
+
+LIC_FILES_CHKSUM = "file://LICENSE;md5=5d4950ecb7b26d2c5e4e7b4e0dd74707"
+
+SRC_URI += "\
+    file://0001-cmd-go-make-content-based-hash-generation-less-pedan.patch \
+    file://0002-cmd-go-Allow-GOTOOLDIR-to-be-overridden-in-the-envir.patch \
+    file://0003-ld-add-soname-to-shareable-objects.patch \
+    file://0004-make.bash-override-CC-when-building-dist-and-go_boot.patch \
+    file://0005-cmd-dist-separate-host-and-target-builds.patch \
+    file://0006-cmd-go-make-GOROOT-precious-by-default.patch \
+    file://0007-exec.go-do-not-write-linker-flags-into-buildids.patch \
+    file://0008-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch \
+    file://0009-go-Filter-build-paths-on-staticly-linked-arches.patch \
+"
+SRC_URI[main.sha256sum] = "72d2f51805c47150066c103754c75fddb2c19d48c9219fa33d1e46696c841dbb"
diff --git a/meta/recipes-devtools/go/go-1.20/0010-net-Fix-issue-with-DNS-not-being-updated.patch b/meta/recipes-devtools/go/go-1.20/0010-net-Fix-issue-with-DNS-not-being-updated.patch
deleted file mode 100644
index 6ead518843..0000000000
--- a/meta/recipes-devtools/go/go-1.20/0010-net-Fix-issue-with-DNS-not-being-updated.patch
+++ /dev/null
@@ -1,51 +0,0 @@
-From 20176b390e28daa86b4552965cb7bd9181983c4d Mon Sep 17 00:00:00 2001
-From: Chaitanya Vadrevu <chaitanya.vadrevu@ni.com>
-Date: Mon, 6 Nov 2023 20:11:19 -0600
-Subject: [PATCH] net: Fix issue with DNS not being updated
-
-When dns requests are made, go's native DNS resolver only reads
-/etc/resolv.conf if the previous request is older than 5 seconds.
-
-On first network call, an initialization code runs that is
-supposed to initialize DNS data and set lastChecked time. There is a bug
-in this code that causes /etc/resolv.conf to not be read during
-initialization and the DNS data from program startup ends up being used
-until the next 5 seconds. This means that if /etc/resolv.conf changed
-between program startup and the first network call, old DNS data is
-still used until the next 5 seconds.
-
-This causes "docker pull" to fail the first time if docker daemon is
-started before networking is up.
-
-Upstream commit d52883f443e1d564b0300acdd382af1769bf0477 made lot of
-improvements to DNS resolver to fix some issues which also fixes this
-issue.
-This patch picks the relevant changes from it to fix this particular
-issue.
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/d52883f443e1d564b0300acdd382af1769bf0477]
-
-Signed-off-by: Chaitanya Vadrevu <chaitanya.vadrevu@ni.com>
----
- src/net/dnsclient_unix.go | 5 +----
- 1 file changed, 1 insertion(+), 4 deletions(-)
-
-diff --git a/src/net/dnsclient_unix.go b/src/net/dnsclient_unix.go
-index 6dfd4af..520ffe6 100644
---- a/src/net/dnsclient_unix.go
-+++ b/src/net/dnsclient_unix.go
-@@ -337,10 +337,7 @@ var resolvConf resolverConfig
- func (conf *resolverConfig) init() {
- 	// Set dnsConfig and lastChecked so we don't parse
- 	// resolv.conf twice the first time.
--	conf.dnsConfig = systemConf().resolv
--	if conf.dnsConfig == nil {
--		conf.dnsConfig = dnsReadConfig("/etc/resolv.conf")
--	}
-+	conf.dnsConfig = dnsReadConfig("/etc/resolv.conf")
- 	conf.lastChecked = time.Now()
- 
- 	// Prepare ch so that only one update of resolverConfig may
--- 
-2.34.1
-
diff --git a/meta/recipes-devtools/go/go-1.20/CVE-2023-39319.patch b/meta/recipes-devtools/go/go-1.20/CVE-2023-39319.patch
deleted file mode 100644
index 1554aa975c..0000000000
--- a/meta/recipes-devtools/go/go-1.20/CVE-2023-39319.patch
+++ /dev/null
@@ -1,254 +0,0 @@
-From 2070531d2f53df88e312edace6c8dfc9686ab2f5 Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Thu Aug 3 12:28:28 2023 -0700
-Subject: [PATCH] html/template: properly handle special tags within the script
- context
-
-The HTML specification has incredibly complex rules for how to handle
-"<!--", "<script", and "</script" when they appear within literals in
-the script context. Rather than attempting to apply these restrictions
-(which require a significantly more complex state machine) we apply
-the workaround suggested in section 4.12.1.3 of the HTML specification [1].
-
-More precisely, when "<!--", "<script", and "</script" appear within
-literals (strings and regular expressions, ignoring comments since we
-already elide their content) we replace the "<" with "\x3C". This avoids
-the unintuitive behavior that using these tags within literals can cause,
-by simply preventing the rendered content from triggering it. This may
-break some correct usages of these tags, but on balance is more likely
-to prevent XSS attacks where users are unknowingly either closing or not
-closing the script blocks where they think they are.
-
-Thanks to Takeshi Kaneko (GMO Cybersecurity by Ierae, Inc.) for
-reporting this issue.
-
-Fixes #62197
-Fixes #62397
-Fixes CVE-2023-39319
-
-[1] https://html.spec.whatwg.org/#restrictions-for-contents-of-script-elements
-
-Change-Id: Iab57b0532694827e3eddf57a7497ba1fab1746dc
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1976594
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/2014621
-Reviewed-on: https://go-review.googlesource.com/c/go/+/526099
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Run-TryBot: Cherry Mui <cherryyz@google.com>
-
-CVE: CVE-2023-39319
-
-Upstream-Status: Backport [https://github.com/golang/go/commit/2070531d2f53df88e312edace6c8dfc9686ab2f5]
-
-Signed-off-by: Soumya Sambu <soumya.sambu@windriver.com>
----
- src/go/build/deps_test.go        |  6 ++--
- src/html/template/context.go     | 14 ++++++++++
- src/html/template/escape.go      | 26 ++++++++++++++++++
- src/html/template/escape_test.go | 47 +++++++++++++++++++++++++++++++-
- src/html/template/transition.go  | 15 ++++++++++
- 5 files changed, 104 insertions(+), 4 deletions(-)
-
-diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
-index dc3bb8c..359a00a 100644
---- a/src/go/build/deps_test.go
-+++ b/src/go/build/deps_test.go
-@@ -255,15 +255,15 @@ var depsRules = `
-	< text/template
-	< internal/lazytemplate;
-
--	encoding/json, html, text/template
--	< html/template;
--
-	# regexp
-	FMT
-	< regexp/syntax
-	< regexp
-	< internal/lazyregexp;
-
-+	encoding/json, html, text/template, regexp
-+	< html/template;
-+
-	# suffix array
-	encoding/binary, regexp
-	< index/suffixarray;
-diff --git a/src/html/template/context.go b/src/html/template/context.go
-index 0b65313..f5f44a1 100644
---- a/src/html/template/context.go
-+++ b/src/html/template/context.go
-@@ -164,6 +164,20 @@ func isInTag(s state) bool {
-	return false
- }
-
-+// isInScriptLiteral returns true if s is one of the literal states within a
-+// <script> tag, and as such occurances of "<!--", "<script", and "</script"
-+// need to be treated specially.
-+func isInScriptLiteral(s state) bool {
-+	// Ignore the comment states (stateJSBlockCmt, stateJSLineCmt,
-+	// stateJSHTMLOpenCmt, stateJSHTMLCloseCmt) because their content is already
-+	// omitted from the output.
-+	switch s {
-+	case stateJSDqStr, stateJSSqStr, stateJSBqStr, stateJSRegexp:
-+		return true
-+	}
-+	return false
-+}
-+
- // delim is the delimiter that will end the current HTML attribute.
- type delim uint8
-
-diff --git a/src/html/template/escape.go b/src/html/template/escape.go
-index bdccc65..1747ec9 100644
---- a/src/html/template/escape.go
-+++ b/src/html/template/escape.go
-@@ -10,6 +10,7 @@ import (
-	"html"
-	"internal/godebug"
-	"io"
-+	"regexp"
-	"text/template"
-	"text/template/parse"
- )
-@@ -652,6 +653,26 @@ var delimEnds = [...]string{
-	delimSpaceOrTagEnd: " \t\n\f\r>",
- }
-
-+var (
-+	// Per WHATWG HTML specification, section 4.12.1.3, there are extremely
-+	// complicated rules for how to handle the set of opening tags <!--,
-+	// <script, and </script when they appear in JS literals (i.e. strings,
-+	// regexs, and comments). The specification suggests a simple solution,
-+	// rather than implementing the arcane ABNF, which involves simply escaping
-+	// the opening bracket with \x3C. We use the below regex for this, since it
-+	// makes doing the case-insensitive find-replace much simpler.
-+	specialScriptTagRE          = regexp.MustCompile("(?i)<(script|/script|!--)")
-+	specialScriptTagReplacement = []byte("\\x3C$1")
-+)
-+
-+func containsSpecialScriptTag(s []byte) bool {
-+	return specialScriptTagRE.Match(s)
-+}
-+
-+func escapeSpecialScriptTags(s []byte) []byte {
-+	return specialScriptTagRE.ReplaceAll(s, specialScriptTagReplacement)
-+}
-+
- var doctypeBytes = []byte("<!DOCTYPE")
-
- // escapeText escapes a text template node.
-@@ -707,6 +728,11 @@ func (e *escaper) escapeText(c context, n *parse.TextNode) context {
-			b.Write(s[written:cs])
-			written = i1
-		}
-+		if isInScriptLiteral(c.state) && containsSpecialScriptTag(s[i:i1]) {
-+			b.Write(s[written:i])
-+			b.Write(escapeSpecialScriptTags(s[i:i1]))
-+			written = i1
-+		}
-		if i == i1 && c.state == c1.state {
-			panic(fmt.Sprintf("infinite loop from %v to %v on %q..%q", c, c1, s[:i], s[i:]))
-		}
-diff --git a/src/html/template/escape_test.go b/src/html/template/escape_test.go
-index 4f48afe..7853daa 100644
---- a/src/html/template/escape_test.go
-+++ b/src/html/template/escape_test.go
-@@ -503,6 +503,21 @@ func TestEscape(t *testing.T) {
-			"<script>var a/*b*///c\nd</script>",
-			"<script>var a \nd</script>",
-		},
-+		{
-+			"Special tags in <script> string literals",
-+			`<script>var a = "asd < 123 <!-- 456 < fgh <script jkl < 789 </script"</script>`,
-+			`<script>var a = "asd < 123 \x3C!-- 456 < fgh \x3Cscript jkl < 789 \x3C/script"</script>`,
-+		},
-+		{
-+			"Special tags in <script> string literals (mixed case)",
-+			`<script>var a = "<!-- <ScripT </ScripT"</script>`,
-+			`<script>var a = "\x3C!-- \x3CScripT \x3C/ScripT"</script>`,
-+		},
-+		{
-+			"Special tags in <script> regex literals (mixed case)",
-+			`<script>var a = /<!-- <ScripT </ScripT/</script>`,
-+			`<script>var a = /\x3C!-- \x3CScripT \x3C/ScripT/</script>`,
-+		},
-		{
-			"CSS comments",
-			"<style>p// paragraph\n" +
-@@ -1491,8 +1506,38 @@ func TestEscapeText(t *testing.T) {
-			context{state: stateJS, element: elementScript},
-		},
-		{
-+			// <script and </script tags are escaped, so </script> should not
-+			// cause us to exit the JS state.
-			`<script>document.write("<script>alert(1)</script>");`,
--			context{state: stateText},
-+			context{state: stateJS, element: elementScript},
-+		},
-+		{
-+			`<script>document.write("<script>`,
-+			context{state: stateJSDqStr, element: elementScript},
-+		},
-+		{
-+			`<script>document.write("<script>alert(1)</script>`,
-+			context{state: stateJSDqStr, element: elementScript},
-+		},
-+		{
-+			`<script>document.write("<script>alert(1)<!--`,
-+			context{state: stateJSDqStr, element: elementScript},
-+		},
-+		{
-+			`<script>document.write("<script>alert(1)</Script>");`,
-+			context{state: stateJS, element: elementScript},
-+		},
-+		{
-+			`<script>document.write("<!--");`,
-+			context{state: stateJS, element: elementScript},
-+		},
-+		{
-+			`<script>let a = /</script`,
-+			context{state: stateJSRegexp, element: elementScript},
-+		},
-+		{
-+			`<script>let a = /</script/`,
-+			context{state: stateJS, element: elementScript, jsCtx: jsCtxDivOp},
-		},
-		{
-			`<script type="text/template">`,
-diff --git a/src/html/template/transition.go b/src/html/template/transition.go
-index 92eb351..e2660cc 100644
---- a/src/html/template/transition.go
-+++ b/src/html/template/transition.go
-@@ -212,6 +212,11 @@ var (
- // element states.
- func tSpecialTagEnd(c context, s []byte) (context, int) {
-	if c.element != elementNone {
-+		// script end tags ("</script") within script literals are ignored, so that
-+		// we can properly escape them.
-+		if c.element == elementScript && (isInScriptLiteral(c.state) || isComment(c.state)) {
-+			return c, len(s)
-+		}
-		if i := indexTagEnd(s, specialTagEndMarkers[c.element]); i != -1 {
-			return context{}, i
-		}
-@@ -331,6 +336,16 @@ func tJSDelimited(c context, s []byte) (context, int) {
-			inCharset = true
-		case ']':
-			inCharset = false
-+		case '/':
-+			// If "</script" appears in a regex literal, the '/' should not
-+			// close the regex literal, and it will later be escaped to
-+			// "\x3C/script" in escapeText.
-+			if i > 0 && i+7 <= len(s) && bytes.Compare(bytes.ToLower(s[i-1:i+7]), []byte("</script")) == 0 {
-+				i++
-+			} else if !inCharset {
-+				c.state, c.jsCtx = stateJS, jsCtxDivOp
-+				return c, i + 1
-+			}
-		default:
-			// end delimiter
-			if !inCharset {
---
-2.40.0
diff --git a/meta/recipes-devtools/go/go-1.21/CVE-2023-24531_1.patch b/meta/recipes-devtools/go/go-1.21/CVE-2023-24531_1.patch
deleted file mode 100644
index 5f6d7e16a8..0000000000
--- a/meta/recipes-devtools/go/go-1.21/CVE-2023-24531_1.patch
+++ /dev/null
@@ -1,252 +0,0 @@
-From 0f717b5f7d32bb660c01ec0366bd53c9b4c5ab5d Mon Sep 17 00:00:00 2001
-From: Michael Matloob <matloob@golang.org>
-Date: Mon, 24 Apr 2023 16:57:28 -0400
-Subject: [PATCH 1/2] cmd/go: sanitize go env outputs
-
-go env, without any arguments, outputs the environment variables in
-the form of a script that can be run on the host OS. On Unix, single
-quote the strings and place single quotes themselves outside the
-single quoted strings. On windows use the set "var=val" syntax with
-the quote starting before the variable.
-
-Fixes #58508
-
-Change-Id: Iecd379a4af7285ea9b2024f0202250c74fd9a2bd
-Reviewed-on: https://go-review.googlesource.com/c/go/+/488375
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Reviewed-by: Michael Matloob <matloob@golang.org>
-Reviewed-by: Damien Neil <dneil@google.com>
-Run-TryBot: Michael Matloob <matloob@golang.org>
-Reviewed-by: Bryan Mills <bcmills@google.com>
-Reviewed-by: Quim Muntal <quimmuntal@gmail.com>
-
-CVE: CVE-2023-24531
-Upstream-Status: Backport [f379e78951a405e7e99a60fb231eeedbf976c108]
-
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/cmd/go/internal/envcmd/env.go           | 60 ++++++++++++-
- src/cmd/go/internal/envcmd/env_test.go      | 94 +++++++++++++++++++++
- src/cmd/go/testdata/script/env_sanitize.txt |  5 ++
- 3 files changed, 157 insertions(+), 2 deletions(-)
- create mode 100644 src/cmd/go/internal/envcmd/env_test.go
- create mode 100644 src/cmd/go/testdata/script/env_sanitize.txt
-
-diff --git a/src/cmd/go/internal/envcmd/env.go b/src/cmd/go/internal/envcmd/env.go
-index 43b94e7..0ce8843 100644
---- a/src/cmd/go/internal/envcmd/env.go
-+++ b/src/cmd/go/internal/envcmd/env.go
-@@ -6,6 +6,7 @@
- package envcmd
- 
- import (
-+	"bytes"
- 	"context"
- 	"encoding/json"
- 	"fmt"
-@@ -17,6 +18,7 @@ import (
- 	"runtime"
- 	"sort"
- 	"strings"
-+	"unicode"
- 	"unicode/utf8"
- 
- 	"cmd/go/internal/base"
-@@ -379,9 +381,12 @@ func checkBuildConfig(add map[string]string, del map[string]bool) error {
- func PrintEnv(w io.Writer, env []cfg.EnvVar) {
- 	for _, e := range env {
- 		if e.Name != "TERM" {
-+			if runtime.GOOS != "plan9" && bytes.Contains([]byte(e.Value), []byte{0}) {
-+				base.Fatalf("go: internal error: encountered null byte in environment variable %s on non-plan9 platform", e.Name)
-+			}
- 			switch runtime.GOOS {
- 			default:
--				fmt.Fprintf(w, "%s=\"%s\"\n", e.Name, e.Value)
-+				fmt.Fprintf(w, "%s=%s\n", e.Name, shellQuote(e.Value))
- 			case "plan9":
- 				if strings.IndexByte(e.Value, '\x00') < 0 {
- 					fmt.Fprintf(w, "%s='%s'\n", e.Name, strings.ReplaceAll(e.Value, "'", "''"))
-@@ -392,17 +397,68 @@ func PrintEnv(w io.Writer, env []cfg.EnvVar) {
- 						if x > 0 {
- 							fmt.Fprintf(w, " ")
- 						}
-+						// TODO(#59979): Does this need to be quoted like above?
- 						fmt.Fprintf(w, "%s", s)
- 					}
- 					fmt.Fprintf(w, ")\n")
- 				}
- 			case "windows":
--				fmt.Fprintf(w, "set %s=%s\n", e.Name, e.Value)
-+				if hasNonGraphic(e.Value) {
-+					base.Errorf("go: stripping unprintable or unescapable characters from %%%q%%", e.Name)
-+				}
-+				fmt.Fprintf(w, "set %s=%s\n", e.Name, batchEscape(e.Value))
- 			}
- 		}
- 	}
- }
- 
-+func hasNonGraphic(s string) bool {
-+	for _, c := range []byte(s) {
-+		if c == '\r' || c == '\n' || (!unicode.IsGraphic(rune(c)) && !unicode.IsSpace(rune(c))) {
-+			return true
-+		}
-+	}
-+	return false
-+}
-+
-+func shellQuote(s string) string {
-+	var b bytes.Buffer
-+	b.WriteByte('\'')
-+	for _, x := range []byte(s) {
-+		if x == '\'' {
-+			// Close the single quoted string, add an escaped single quote,
-+			// and start another single quoted string.
-+			b.WriteString(`'\''`)
-+		} else {
-+			b.WriteByte(x)
-+		}
-+	}
-+	b.WriteByte('\'')
-+	return b.String()
-+}
-+
-+func batchEscape(s string) string {
-+	var b bytes.Buffer
-+	for _, x := range []byte(s) {
-+		if x == '\r' || x == '\n' || (!unicode.IsGraphic(rune(x)) && !unicode.IsSpace(rune(x))) {
-+			b.WriteRune(unicode.ReplacementChar)
-+			continue
-+		}
-+		switch x {
-+		case '%':
-+			b.WriteString("%%")
-+		case '<', '>', '|', '&', '^':
-+			// These are special characters that need to be escaped with ^. See
-+			// https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/set_1.
-+			b.WriteByte('^')
-+			b.WriteByte(x)
-+		default:
-+			b.WriteByte(x)
-+		}
-+	}
-+	return b.String()
-+}
-+
- func printEnvAsJSON(env []cfg.EnvVar) {
- 	m := make(map[string]string)
- 	for _, e := range env {
-diff --git a/src/cmd/go/internal/envcmd/env_test.go b/src/cmd/go/internal/envcmd/env_test.go
-new file mode 100644
-index 0000000..32d99fd
---- /dev/null
-+++ b/src/cmd/go/internal/envcmd/env_test.go
-@@ -0,0 +1,94 @@
-+// Copyright 2022 The Go Authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style
-+// license that can be found in the LICENSE file.
-+
-+//go:build unix || windows
-+
-+package envcmd
-+
-+import (
-+	"bytes"
-+	"cmd/go/internal/cfg"
-+	"fmt"
-+	"internal/testenv"
-+	"os"
-+	"os/exec"
-+	"path/filepath"
-+	"runtime"
-+	"testing"
-+	"unicode"
-+)
-+
-+func FuzzPrintEnvEscape(f *testing.F) {
-+	f.Add(`$(echo 'cc"'; echo 'OOPS="oops')`)
-+	f.Add("$(echo shell expansion 1>&2)")
-+	f.Add("''")
-+	f.Add(`C:\"Program Files"\`)
-+	f.Add(`\\"Quoted Host"\\share`)
-+	f.Add("\xfb")
-+	f.Add("0")
-+	f.Add("")
-+	f.Add("''''''''")
-+	f.Add("\r")
-+	f.Add("\n")
-+	f.Add("E,%")
-+	f.Fuzz(func(t *testing.T, s string) {
-+		t.Parallel()
-+
-+		for _, c := range []byte(s) {
-+			if c == 0 {
-+				t.Skipf("skipping %q: contains a null byte. Null bytes can't occur in the environment"+
-+					" outside of Plan 9, which has different code path than Windows and Unix that this test"+
-+					" isn't testing.", s)
-+			}
-+			if c > unicode.MaxASCII {
-+				t.Skipf("skipping %#q: contains a non-ASCII character %q", s, c)
-+			}
-+			if !unicode.IsGraphic(rune(c)) && !unicode.IsSpace(rune(c)) {
-+				t.Skipf("skipping %#q: contains non-graphic character %q", s, c)
-+			}
-+			if runtime.GOOS == "windows" && c == '\r' || c == '\n' {
-+				t.Skipf("skipping %#q on Windows: contains unescapable character %q", s, c)
-+			}
-+		}
-+
-+		var b bytes.Buffer
-+		if runtime.GOOS == "windows" {
-+			b.WriteString("@echo off\n")
-+		}
-+		PrintEnv(&b, []cfg.EnvVar{{Name: "var", Value: s}})
-+		var want string
-+		if runtime.GOOS == "windows" {
-+			fmt.Fprintf(&b, "echo \"%%var%%\"\n")
-+			want += "\"" + s + "\"\r\n"
-+		} else {
-+			fmt.Fprintf(&b, "printf '%%s\\n' \"$var\"\n")
-+			want += s + "\n"
-+		}
-+		scriptfilename := "script.sh"
-+		if runtime.GOOS == "windows" {
-+			scriptfilename = "script.bat"
-+		}
-+		scriptfile := filepath.Join(t.TempDir(), scriptfilename)
-+		if err := os.WriteFile(scriptfile, b.Bytes(), 0777); err != nil {
-+			t.Fatal(err)
-+		}
-+		t.Log(b.String())
-+		var cmd *exec.Cmd
-+		if runtime.GOOS == "windows" {
-+			cmd = testenv.Command(t, "cmd.exe", "/C", scriptfile)
-+		} else {
-+			cmd = testenv.Command(t, "sh", "-c", scriptfile)
-+		}
-+		out, err := cmd.Output()
-+		t.Log(string(out))
-+		if err != nil {
-+			t.Fatal(err)
-+		}
-+
-+		if string(out) != want {
-+			t.Fatalf("output of running PrintEnv script and echoing variable: got: %q, want: %q",
-+				string(out), want)
-+		}
-+	})
-+}
-diff --git a/src/cmd/go/testdata/script/env_sanitize.txt b/src/cmd/go/testdata/script/env_sanitize.txt
-new file mode 100644
-index 0000000..cc4d23a
---- /dev/null
-+++ b/src/cmd/go/testdata/script/env_sanitize.txt
-@@ -0,0 +1,5 @@
-+env GOFLAGS='$(echo ''cc"''; echo ''OOPS="oops'')'
-+go env
-+[GOOS:darwin] stdout 'GOFLAGS=''\$\(echo ''\\''''cc"''\\''''; echo ''\\''''OOPS="oops''\\''''\)'''
-+[GOOS:linux] stdout 'GOFLAGS=''\$\(echo ''\\''''cc"''\\''''; echo ''\\''''OOPS="oops''\\''''\)'''
-+[GOOS:windows] stdout 'set GOFLAGS=\$\(echo ''cc"''; echo ''OOPS="oops''\)'
--- 
-2.35.5
-
diff --git a/meta/recipes-devtools/go/go-1.21/CVE-2023-24531_2.patch b/meta/recipes-devtools/go/go-1.21/CVE-2023-24531_2.patch
deleted file mode 100644
index eecc04c2e3..0000000000
--- a/meta/recipes-devtools/go/go-1.21/CVE-2023-24531_2.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From b2624f973692ca093348395c2418d1c422f2a162 Mon Sep 17 00:00:00 2001
-From: miller <millerresearch@gmail.com>
-Date: Mon, 8 May 2023 16:56:21 +0100
-Subject: [PATCH 2/2] cmd/go: quote entries in list-valued variables for go env
- in plan9
-
-When 'go env' without an argument prints environment variables as
-a script which can be executed by the shell, variables with a
-list value in Plan 9 (such as GOPATH) need to be printed with each
-element enclosed in single quotes in case it contains characters
-significant to the Plan 9 shell (such as ' ' or '=').
-
-For #58508
-
-Change-Id: Ia30f51307cc6d07a7e3ada6bf9d60bf9951982ff
-Reviewed-on: https://go-review.googlesource.com/c/go/+/493535
-Run-TryBot: Cherry Mui <cherryyz@google.com>
-Reviewed-by: Cherry Mui <cherryyz@google.com>
-Reviewed-by: Russ Cox <rsc@golang.org>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-Auto-Submit: Dmitri Shuralyov <dmitshur@golang.org>
-
-CVE: CVE-2023-24531
-Upstream-Status: Backport [05cc9e55876874462a4726ca0101c970838c80e5]
-
-Signed-off-by: Sakib Sajal <sakib.sajal@windriver.com>
----
- src/cmd/go/internal/envcmd/env.go | 3 +--
- 1 file changed, 1 insertion(+), 2 deletions(-)
-
-diff --git a/src/cmd/go/internal/envcmd/env.go b/src/cmd/go/internal/envcmd/env.go
-index 0ce8843..b48d0bd 100644
---- a/src/cmd/go/internal/envcmd/env.go
-+++ b/src/cmd/go/internal/envcmd/env.go
-@@ -397,8 +397,7 @@ func PrintEnv(w io.Writer, env []cfg.EnvVar) {
- 						if x > 0 {
- 							fmt.Fprintf(w, " ")
- 						}
--						// TODO(#59979): Does this need to be quoted like above?
--						fmt.Fprintf(w, "%s", s)
-+						fmt.Fprintf(w, "'%s'", strings.ReplaceAll(s, "'", "''"))
- 					}
- 					fmt.Fprintf(w, ")\n")
- 				}
--- 
-2.35.5
-
diff --git a/meta/recipes-devtools/go/go-1.21/CVE-2023-39318.patch b/meta/recipes-devtools/go/go-1.21/CVE-2023-39318.patch
deleted file mode 100644
index 503a4a288a..0000000000
--- a/meta/recipes-devtools/go/go-1.21/CVE-2023-39318.patch
+++ /dev/null
@@ -1,262 +0,0 @@
-From 023b542edf38e2a1f87fcefb9f75ff2f99401b4c Mon Sep 17 00:00:00 2001
-From: Roland Shoemaker <bracewell@google.com>
-Date: Thu, 3 Aug 2023 12:24:13 -0700
-Subject: [PATCH] [release-branch.go1.20] html/template: support HTML-like
- comments in script contexts
-
-Per Appendix B.1.1 of the ECMAScript specification, support HTML-like
-comments in script contexts. Also per section 12.5, support hashbang
-comments. This brings our parsing in-line with how browsers treat these
-comment types.
-
-Thanks to Takeshi Kaneko (GMO Cybersecurity by Ierae, Inc.) for
-reporting this issue.
-
-Fixes #62196
-Fixes #62395
-Fixes CVE-2023-39318
-
-Change-Id: Id512702c5de3ae46cf648e268cb10e1eb392a181
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/1976593
-Run-TryBot: Roland Shoemaker <bracewell@google.com>
-Reviewed-by: Tatiana Bradley <tatianabradley@google.com>
-Reviewed-by: Damien Neil <dneil@google.com>
-Reviewed-by: Dmitri Shuralyov <dmitshur@google.com>
-Reviewed-on: https://team-review.git.corp.google.com/c/golang/go-private/+/2014620
-Reviewed-on: https://go-review.googlesource.com/c/go/+/526098
-Run-TryBot: Cherry Mui <cherryyz@google.com>
-TryBot-Result: Gopher Robot <gobot@golang.org>
-
-Upstream-Status: Backport from [https://github.com/golang/go/commit/023b542edf38e2a1f87fcefb9f75ff2f99401b4c]
-CVE: CVE-2023-39318
-Signed-off-by: Siddharth Doshi <sdoshi@mvista.com>
----
- src/html/template/context.go      |  6 ++-
- src/html/template/escape.go       |  5 ++-
- src/html/template/escape_test.go  | 10 +++++
- src/html/template/state_string.go | 26 +++++++------
- src/html/template/transition.go   | 80 +++++++++++++++++++++++++--------------
- 5 files changed, 84 insertions(+), 43 deletions(-)
-
-diff --git a/src/html/template/context.go b/src/html/template/context.go
-index f5f44a1..feb6517 100644
---- a/src/html/template/context.go
-+++ b/src/html/template/context.go
-@@ -124,6 +124,10 @@ const (
- 	stateJSBlockCmt
- 	// stateJSLineCmt occurs inside a JavaScript // line comment.
- 	stateJSLineCmt
-+	// stateJSHTMLOpenCmt occurs inside a JavaScript <!-- HTML-like comment.
-+	stateJSHTMLOpenCmt
-+	// stateJSHTMLCloseCmt occurs inside a JavaScript --> HTML-like comment.
-+	stateJSHTMLCloseCmt
- 	// stateCSS occurs inside a <style> element or style attribute.
- 	stateCSS
- 	// stateCSSDqStr occurs inside a CSS double quoted string.
-@@ -149,7 +153,7 @@ const (
- // authors & maintainers, not for end-users or machines.
- func isComment(s state) bool {
- 	switch s {
--	case stateHTMLCmt, stateJSBlockCmt, stateJSLineCmt, stateCSSBlockCmt, stateCSSLineCmt:
-+	case stateHTMLCmt, stateJSBlockCmt, stateJSLineCmt, stateJSHTMLOpenCmt, stateJSHTMLCloseCmt, stateCSSBlockCmt, stateCSSLineCmt:
- 		return true
- 	}
- 	return false
-diff --git a/src/html/template/escape.go b/src/html/template/escape.go
-index 1747ec9..b0085ce 100644
---- a/src/html/template/escape.go
-+++ b/src/html/template/escape.go
-@@ -721,9 +721,12 @@ func (e *escaper) escapeText(c context, n *parse.TextNode) context {
- 		if c.state != c1.state && isComment(c1.state) && c1.delim == delimNone {
- 			// Preserve the portion between written and the comment start.
- 			cs := i1 - 2
--			if c1.state == stateHTMLCmt {
-+			if c1.state == stateHTMLCmt || c1.state == stateJSHTMLOpenCmt {
- 				// "<!--" instead of "/*" or "//"
- 				cs -= 2
-+			} else if c1.state == stateJSHTMLCloseCmt {
-+				// "-->" instead of "/*" or "//"
-+				cs -= 1
- 			}
- 			b.Write(s[written:cs])
- 			written = i1
-diff --git a/src/html/template/escape_test.go b/src/html/template/escape_test.go
-index 7853daa..bff38c6 100644
---- a/src/html/template/escape_test.go
-+++ b/src/html/template/escape_test.go
-@@ -503,6 +503,16 @@ func TestEscape(t *testing.T) {
- 			"<script>var a/*b*///c\nd</script>",
- 			"<script>var a \nd</script>",
- 		},
-+		{
-+			"JS HTML-like comments",
-+			"<script>before <!-- beep\nbetween\nbefore-->boop\n</script>",
-+			"<script>before \nbetween\nbefore\n</script>",
-+		},
-+		{
-+			"JS hashbang comment",
-+			"<script>#! beep\n</script>",
-+			"<script>\n</script>",
-+		},
- 		{
- 			"Special tags in <script> string literals",
- 			`<script>var a = "asd < 123 <!-- 456 < fgh <script jkl < 789 </script"</script>`,
-diff --git a/src/html/template/state_string.go b/src/html/template/state_string.go
-index 05104be..b5cfe70 100644
---- a/src/html/template/state_string.go
-+++ b/src/html/template/state_string.go
-@@ -25,21 +25,23 @@ func _() {
- 	_ = x[stateJSRegexp-14]
- 	_ = x[stateJSBlockCmt-15]
- 	_ = x[stateJSLineCmt-16]
--	_ = x[stateCSS-17]
--	_ = x[stateCSSDqStr-18]
--	_ = x[stateCSSSqStr-19]
--	_ = x[stateCSSDqURL-20]
--	_ = x[stateCSSSqURL-21]
--	_ = x[stateCSSURL-22]
--	_ = x[stateCSSBlockCmt-23]
--	_ = x[stateCSSLineCmt-24]
--	_ = x[stateError-25]
--	_ = x[stateDead-26]
-+	_ = x[stateJSHTMLOpenCmt-17]
-+	_ = x[stateJSHTMLCloseCmt-18]
-+	_ = x[stateCSS-19]
-+	_ = x[stateCSSDqStr-20]
-+	_ = x[stateCSSSqStr-21]
-+	_ = x[stateCSSDqURL-22]
-+	_ = x[stateCSSSqURL-23]
-+	_ = x[stateCSSURL-24]
-+	_ = x[stateCSSBlockCmt-25]
-+	_ = x[stateCSSLineCmt-26]
-+	_ = x[stateError-27]
-+	_ = x[stateDead-28]
- }
- 
--const _state_name = "stateTextstateTagstateAttrNamestateAfterNamestateBeforeValuestateHTMLCmtstateRCDATAstateAttrstateURLstateSrcsetstateJSstateJSDqStrstateJSSqStrstateJSBqStrstateJSRegexpstateJSBlockCmtstateJSLineCmtstateCSSstateCSSDqStrstateCSSSqStrstateCSSDqURLstateCSSSqURLstateCSSURLstateCSSBlockCmtstateCSSLineCmtstateErrorstateDead"
-+const _state_name = "stateTextstateTagstateAttrNamestateAfterNamestateBeforeValuestateHTMLCmtstateRCDATAstateAttrstateURLstateSrcsetstateJSstateJSDqStrstateJSSqStrstateJSBqStrstateJSRegexpstateJSBlockCmtstateJSLineCmtstateJSHTMLOpenCmtstateJSHTMLCloseCmtstateCSSstateCSSDqStrstateCSSSqStrstateCSSDqURLstateCSSSqURLstateCSSURLstateCSSBlockCmtstateCSSLineCmtstateErrorstateDead"
- 
--var _state_index = [...]uint16{0, 9, 17, 30, 44, 60, 72, 83, 92, 100, 111, 118, 130, 142, 154, 167, 182, 196, 204, 217, 230, 243, 256, 267, 283, 298, 308, 317}
-+var _state_index = [...]uint16{0, 9, 17, 30, 44, 60, 72, 83, 92, 100, 111, 118, 130, 142, 154, 167, 182, 196, 214, 233, 241, 254, 267, 280, 293, 304, 320, 335, 345, 354}
- 
- func (i state) String() string {
- 	if i >= state(len(_state_index)-1) {
-diff --git a/src/html/template/transition.go b/src/html/template/transition.go
-index e2660cc..3d2a37c 100644
---- a/src/html/template/transition.go
-+++ b/src/html/template/transition.go
-@@ -14,32 +14,34 @@ import (
- // the updated context and the number of bytes consumed from the front of the
- // input.
- var transitionFunc = [...]func(context, []byte) (context, int){
--	stateText:        tText,
--	stateTag:         tTag,
--	stateAttrName:    tAttrName,
--	stateAfterName:   tAfterName,
--	stateBeforeValue: tBeforeValue,
--	stateHTMLCmt:     tHTMLCmt,
--	stateRCDATA:      tSpecialTagEnd,
--	stateAttr:        tAttr,
--	stateURL:         tURL,
--	stateSrcset:      tURL,
--	stateJS:          tJS,
--	stateJSDqStr:     tJSDelimited,
--	stateJSSqStr:     tJSDelimited,
--	stateJSBqStr:     tJSDelimited,
--	stateJSRegexp:    tJSDelimited,
--	stateJSBlockCmt:  tBlockCmt,
--	stateJSLineCmt:   tLineCmt,
--	stateCSS:         tCSS,
--	stateCSSDqStr:    tCSSStr,
--	stateCSSSqStr:    tCSSStr,
--	stateCSSDqURL:    tCSSStr,
--	stateCSSSqURL:    tCSSStr,
--	stateCSSURL:      tCSSStr,
--	stateCSSBlockCmt: tBlockCmt,
--	stateCSSLineCmt:  tLineCmt,
--	stateError:       tError,
-+	stateText:           tText,
-+	stateTag:            tTag,
-+	stateAttrName:       tAttrName,
-+	stateAfterName:      tAfterName,
-+	stateBeforeValue:    tBeforeValue,
-+	stateHTMLCmt:        tHTMLCmt,
-+	stateRCDATA:         tSpecialTagEnd,
-+	stateAttr:           tAttr,
-+	stateURL:            tURL,
-+	stateSrcset:         tURL,
-+	stateJS:             tJS,
-+	stateJSDqStr:        tJSDelimited,
-+	stateJSSqStr:        tJSDelimited,
-+	stateJSBqStr:        tJSDelimited,
-+	stateJSRegexp:       tJSDelimited,
-+	stateJSBlockCmt:     tBlockCmt,
-+	stateJSLineCmt:      tLineCmt,
-+	stateJSHTMLOpenCmt:  tLineCmt,
-+	stateJSHTMLCloseCmt: tLineCmt,
-+	stateCSS:            tCSS,
-+	stateCSSDqStr:       tCSSStr,
-+	stateCSSSqStr:       tCSSStr,
-+	stateCSSDqURL:       tCSSStr,
-+	stateCSSSqURL:       tCSSStr,
-+	stateCSSURL:         tCSSStr,
-+	stateCSSBlockCmt:    tBlockCmt,
-+	stateCSSLineCmt:     tLineCmt,
-+	stateError:          tError,
- }
- 
- var commentStart = []byte("<!--")
-@@ -268,7 +270,7 @@ func tURL(c context, s []byte) (context, int) {
- 
- // tJS is the context transition function for the JS state.
- func tJS(c context, s []byte) (context, int) {
--	i := bytes.IndexAny(s, "\"`'/")
-+	i := bytes.IndexAny(s, "\"`'/<-#")
- 	if i == -1 {
- 		// Entire input is non string, comment, regexp tokens.
- 		c.jsCtx = nextJSCtx(s, c.jsCtx)
-@@ -298,6 +300,26 @@ func tJS(c context, s []byte) (context, int) {
- 				err:   errorf(ErrSlashAmbig, nil, 0, "'/' could start a division or regexp: %.32q", s[i:]),
- 			}, len(s)
- 		}
-+	// ECMAScript supports HTML style comments for legacy reasons, see Appendix
-+	// B.1.1 "HTML-like Comments". The handling of these comments is somewhat
-+	// confusing. Multi-line comments are not supported, i.e. anything on lines
-+	// between the opening and closing tokens is not considered a comment, but
-+	// anything following the opening or closing token, on the same line, is
-+	// ignored. As such we simply treat any line prefixed with "<!--" or "-->"
-+	// as if it were actually prefixed with "//" and move on.
-+	case '<':
-+		if i+3 < len(s) && bytes.Equal(commentStart, s[i:i+4]) {
-+			c.state, i = stateJSHTMLOpenCmt, i+3
-+		}
-+	case '-':
-+		if i+2 < len(s) && bytes.Equal(commentEnd, s[i:i+3]) {
-+			c.state, i = stateJSHTMLCloseCmt, i+2
-+		}
-+	// ECMAScript also supports "hashbang" comment lines, see Section 12.5.
-+	case '#':
-+		if i+1 < len(s) && s[i+1] == '!' {
-+			c.state, i = stateJSLineCmt, i+1
-+		}
- 	default:
- 		panic("unreachable")
- 	}
-@@ -387,12 +409,12 @@ func tBlockCmt(c context, s []byte) (context, int) {
- 	return c, i + 2
- }
- 
--// tLineCmt is the context transition function for //comment states.
-+// tLineCmt is the context transition function for //comment states, and the JS HTML-like comment state.
- func tLineCmt(c context, s []byte) (context, int) {
- 	var lineTerminators string
- 	var endState state
- 	switch c.state {
--	case stateJSLineCmt:
-+	case stateJSLineCmt, stateJSHTMLOpenCmt, stateJSHTMLCloseCmt:
- 		lineTerminators, endState = "\n\r\u2028\u2029", stateJS
- 	case stateCSSLineCmt:
- 		lineTerminators, endState = "\n\f\r", stateCSS
--- 
-2.35.7
-
diff --git a/meta/recipes-devtools/go/go-binary-native_1.17.13.bb b/meta/recipes-devtools/go/go-binary-native_1.20.10.bb
similarity index 74%
rename from meta/recipes-devtools/go/go-binary-native_1.17.13.bb
rename to meta/recipes-devtools/go/go-binary-native_1.20.10.bb
index 4ee0148417..691670c31e 100644
--- a/meta/recipes-devtools/go/go-binary-native_1.17.13.bb
+++ b/meta/recipes-devtools/go/go-binary-native_1.20.10.bb
@@ -7,13 +7,17 @@ LIC_FILES_CHKSUM = "file://LICENSE;md5=5d4950ecb7b26d2c5e4e7b4e0dd74707"
 
 PROVIDES = "go-native"
 
+# Checksums available at https://go.dev/dl/
 SRC_URI = "https://dl.google.com/go/go${PV}.${BUILD_GOOS}-${BUILD_GOARCH}.tar.gz;name=go_${BUILD_GOTUPLE}"
-SRC_URI[go_linux_amd64.sha256sum] = "4cdd2bc664724dc7db94ad51b503512c5ae7220951cac568120f64f8e94399fc"
-SRC_URI[go_linux_arm64.sha256sum] = "914daad3f011cc2014dea799bb7490442677e4ad6de0b2ac3ded6cee7e3f493d"
+SRC_URI[go_linux_amd64.sha256sum] = "80d34f1fd74e382d86c2d6102e0e60d4318461a7c2f457ec1efc4042752d4248"
+SRC_URI[go_linux_arm64.sha256sum] = "fb3c7e15fc4413c5b81eb9f26dbd7cd4faedd5c720b30fa8e2ff77457f74cab6"
+SRC_URI[go_linux_ppc64le.sha256sum] = "ebac6e713810174f9ffd7f48c17c373fbf359d50d8e6233b1dfbbdebd524fd1c"
 
 UPSTREAM_CHECK_URI = "https://golang.org/dl/"
 UPSTREAM_CHECK_REGEX = "go(?P<pver>\d+(\.\d+)+)\.linux"
 
+CVE_PRODUCT = "go"
+
 S = "${WORKDIR}/go"
 
 inherit goarch native
diff --git a/meta/recipes-devtools/go/go-common.inc b/meta/recipes-devtools/go/go-common.inc
index 83f8db7b39..96e32eeb97 100644
--- a/meta/recipes-devtools/go/go-common.inc
+++ b/meta/recipes-devtools/go/go-common.inc
@@ -19,6 +19,9 @@ S = "${WORKDIR}/go"
 B = "${S}"
 UPSTREAM_CHECK_REGEX = "(?P<pver>\d+(\.\d+)+)\.src\.tar"
 
+# all recipe variants are created from the same product
+CVE_PRODUCT = "go"
+
 INHIBIT_PACKAGE_DEBUG_SPLIT = "1"
 SSTATE_SCAN_CMD = "true"
 
diff --git a/meta/recipes-devtools/go/go-cross-canadian.inc b/meta/recipes-devtools/go/go-cross-canadian.inc
index c1aa987427..45758f3361 100644
--- a/meta/recipes-devtools/go/go-cross-canadian.inc
+++ b/meta/recipes-devtools/go/go-cross-canadian.inc
@@ -1,7 +1,7 @@
 inherit cross-canadian
 
-DEPENDS = "go-native virtual/${HOST_PREFIX}go-crosssdk virtual/nativesdk-${HOST_PREFIX}go-runtime \
-           virtual/${HOST_PREFIX}gcc-crosssdk virtual/nativesdk-libc \
+DEPENDS = "go-native virtual/${HOST_PREFIX}go virtual/nativesdk-${HOST_PREFIX}go-runtime \
+           virtual/${HOST_PREFIX}gcc virtual/nativesdk-libc \
            virtual/nativesdk-${HOST_PREFIX}compilerlibs"
 PN = "go-cross-canadian-${TRANSLATED_TARGET_ARCH}"
 
@@ -21,10 +21,10 @@ export GO_LDFLAGS = '-linkmode external -extld ${HOST_PREFIX}gcc -extldflags "--
 do_configure[noexec] = "1"
 
 do_compile() {
-	export CC_FOR_${HOST_GOTUPLE}="${HOST_PREFIX}gcc --sysroot=${STAGING_DIR_HOST}${SDKPATHNATIVE} ${SECURITY_NOPIE_CFLAGS}"
-	export CXX_FOR_${HOST_GOTUPLE}="${HOST_PREFIX}gxx --sysroot=${STAGING_DIR_HOST}${SDKPATHNATIVE} ${SECURITY_NOPIE_CFLAGS}"
+	export CC_FOR_${HOST_GOTUPLE}="${HOST_PREFIX}gcc --sysroot=${STAGING_DIR_HOST} ${SECURITY_NOPIE_CFLAGS}"
+	export CXX_FOR_${HOST_GOTUPLE}="${HOST_PREFIX}gxx --sysroot=${STAGING_DIR_HOST} ${SECURITY_NOPIE_CFLAGS}"
 	cd src
-	./make.bash --host-only --no-banner
+	./make.bash --target-only --no-banner
 	cd ${B}
 }
 do_compile[cleandirs] += "${GOTMPDIR} ${B}/bin ${B}/pkg"
diff --git a/meta/recipes-devtools/go/go-cross-canadian_1.17.13.bb b/meta/recipes-devtools/go/go-cross-canadian_1.20.10.bb
similarity index 100%
rename from meta/recipes-devtools/go/go-cross-canadian_1.17.13.bb
rename to meta/recipes-devtools/go/go-cross-canadian_1.20.10.bb
diff --git a/meta/recipes-devtools/go/go-cross_1.17.13.bb b/meta/recipes-devtools/go/go-cross_1.20.10.bb
similarity index 100%
rename from meta/recipes-devtools/go/go-cross_1.17.13.bb
rename to meta/recipes-devtools/go/go-cross_1.20.10.bb
diff --git a/meta/recipes-devtools/go/go-crosssdk.inc b/meta/recipes-devtools/go/go-crosssdk.inc
index 766938670a..12939005c0 100644
--- a/meta/recipes-devtools/go/go-crosssdk.inc
+++ b/meta/recipes-devtools/go/go-crosssdk.inc
@@ -1,8 +1,8 @@
 inherit crosssdk
 
-DEPENDS = "go-native virtual/${TARGET_PREFIX}gcc-crosssdk virtual/nativesdk-${TARGET_PREFIX}compilerlibs virtual/${TARGET_PREFIX}binutils-crosssdk"
+DEPENDS = "go-native virtual/${TARGET_PREFIX}gcc virtual/nativesdk-${TARGET_PREFIX}compilerlibs virtual/${TARGET_PREFIX}binutils"
 PN = "go-crosssdk-${SDK_SYS}"
-PROVIDES = "virtual/${TARGET_PREFIX}go-crosssdk"
+PROVIDES = "virtual/${TARGET_PREFIX}go"
 
 export GOCACHE = "${B}/.cache"
 
diff --git a/meta/recipes-devtools/go/go-crosssdk_1.17.13.bb b/meta/recipes-devtools/go/go-crosssdk_1.20.10.bb
similarity index 100%
rename from meta/recipes-devtools/go/go-crosssdk_1.17.13.bb
rename to meta/recipes-devtools/go/go-crosssdk_1.20.10.bb
diff --git a/meta/recipes-devtools/go/go-native_1.17.13.bb b/meta/recipes-devtools/go/go-native_1.20.10.bb
similarity index 100%
rename from meta/recipes-devtools/go/go-native_1.17.13.bb
rename to meta/recipes-devtools/go/go-native_1.20.10.bb
diff --git a/meta/recipes-devtools/go/go-runtime.inc b/meta/recipes-devtools/go/go-runtime.inc
index e18339cddb..3f1e795dd9 100644
--- a/meta/recipes-devtools/go/go-runtime.inc
+++ b/meta/recipes-devtools/go/go-runtime.inc
@@ -1,5 +1,5 @@
 DEPENDS = "virtual/${TUNE_PKGARCH}-go go-native"
-DEPENDS:class-nativesdk = "virtual/${TARGET_PREFIX}go-crosssdk"
+DEPENDS:class-nativesdk = "virtual/${TARGET_PREFIX}go"
 PROVIDES = "virtual/${TARGET_PREFIX}go-runtime"
 
 DEBUG_PREFIX_MAP = "\
@@ -50,6 +50,8 @@ do_install() {
 	rm -rf ${D}${libdir}/go/pkg/tool
 	rm -rf ${D}${libdir}/go/pkg/obj
 	rm -rf ${D}${libdir}/go/pkg/bootstrap
+	# the cmd directory is built for the native arch so if BUILD == TARGET
+	rm -rf ${D}${libdir}/go/pkg/${BUILD_GOTUPLE}/cmd
 	find src -mindepth 1 -maxdepth 1 -type d | while read srcdir; do
 		cp --preserve=mode,timestamps -R $srcdir ${D}${libdir}/go/src/
 	done
diff --git a/meta/recipes-devtools/go/go-runtime_1.17.13.bb b/meta/recipes-devtools/go/go-runtime_1.20.10.bb
similarity index 100%
rename from meta/recipes-devtools/go/go-runtime_1.17.13.bb
rename to meta/recipes-devtools/go/go-runtime_1.20.10.bb
diff --git a/meta/recipes-devtools/go/go-target.inc b/meta/recipes-devtools/go/go-target.inc
index d085643036..a4b55ad3d8 100644
--- a/meta/recipes-devtools/go/go-target.inc
+++ b/meta/recipes-devtools/go/go-target.inc
@@ -1,5 +1,5 @@
 DEPENDS = "virtual/${TUNE_PKGARCH}-go go-native"
-DEPENDS:class-nativesdk = "virtual/${TARGET_PREFIX}go-crosssdk go-native"
+DEPENDS:class-nativesdk = "virtual/${TARGET_PREFIX}go go-native"
 
 DEBUG_PREFIX_MAP = "\
                      -fdebug-prefix-map=${STAGING_DIR_HOST}= \
@@ -14,9 +14,9 @@ export CGO_LDFLAGS = "${@ ' '.join(filter(lambda f: not f.startswith('-fdebug-pr
 
 export GOCACHE = "${B}/.cache"
 GO_LDFLAGS = ""
-GO_LDFLAGS:class-nativesdk = "-linkmode external"
+GO_LDFLAGS:class-nativesdk = " -linkmode external"
 export GO_LDFLAGS
-
+export GOBUILDFLAGS = "-gcflags=-trimpath=$GOPATH -asmflags=-trimpath=$GOPATH -trimpath"
 CC:append:class-nativesdk = " ${SECURITY_NOPIE_CFLAGS}"
 
 do_configure[noexec] = "1"
diff --git a/meta/recipes-devtools/go/go/0001-cmd-go-make-content-based-hash-generation-less-pedan.patch b/meta/recipes-devtools/go/go/0001-cmd-go-make-content-based-hash-generation-less-pedan.patch
new file mode 100644
index 0000000000..9a2551031a
--- /dev/null
+++ b/meta/recipes-devtools/go/go/0001-cmd-go-make-content-based-hash-generation-less-pedan.patch
@@ -0,0 +1,167 @@
+From 10766ca6f4007b96e3f6bf4fb496e5df74397eb9 Mon Sep 17 00:00:00 2001
+From: Khem Raj <raj.khem@gmail.com>
+Date: Mon, 28 Mar 2022 10:59:03 -0700
+Subject: [PATCH 1/9] cmd/go: make content-based hash generation less pedantic
+
+Go 1.10's build tool now uses content-based hashes to
+determine when something should be built or re-built.
+This same mechanism is used to maintain a built-artifact
+cache for speeding up builds.
+
+However, the hashes it generates include information that
+doesn't work well with OE, nor with using a shared runtime
+library.
+
+First, it embeds path names to source files, unless
+building within GOROOT.  This prevents the building
+of a package in GOPATH for later staging into GOROOT.
+
+This patch adds support for the environment variable
+GOPATH_OMIT_IN_ACTIONID.  If present, path name
+embedding is disabled.
+
+Upstream-Status: Inappropriate [OE specific]
+
+Signed-off-by: Alex Kube <alexander.j.kube@gmail.com>
+Signed-off-by: Matt Madison <matt@madison.systems>
+Signed-off-by: Khem Raj <raj.khem@gmail.com>
+---
+ src/cmd/go/internal/envcmd/env.go |  2 +-
+ src/cmd/go/internal/work/exec.go  | 44 ++++++++++++++++++++++++-------
+ 2 files changed, 36 insertions(+), 10 deletions(-)
+
+diff --git a/src/cmd/go/internal/envcmd/env.go b/src/cmd/go/internal/envcmd/env.go
+index 66ef5ce..fb7448a 100644
+--- a/src/cmd/go/internal/envcmd/env.go
++++ b/src/cmd/go/internal/envcmd/env.go
+@@ -183,7 +183,7 @@ func ExtraEnvVarsCostly() []cfg.EnvVar {
+ 		}
+ 	}()
+ 
+-	cppflags, cflags, cxxflags, fflags, ldflags, err := b.CFlags(&load.Package{})
++	cppflags, cflags, cxxflags, fflags, ldflags, err := b.CFlags(&load.Package{}, false)
+ 	if err != nil {
+ 		// Should not happen - b.CFlags was given an empty package.
+ 		fmt.Fprintf(os.Stderr, "go: invalid cflags: %v\n", err)
+diff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go
+index 67d1193..62e1774 100644
+--- a/src/cmd/go/internal/work/exec.go
++++ b/src/cmd/go/internal/work/exec.go
+@@ -223,6 +223,8 @@ func (b *Builder) Do(ctx context.Context, root *Action) {
+ 	writeActionGraph()
+ }
+ 
++var omitGopath = os.Getenv("GOPATH_OMIT_IN_ACTIONID") != ""
++
+ // buildActionID computes the action ID for a build action.
+ func (b *Builder) buildActionID(a *Action) cache.ActionID {
+ 	p := a.Package
+@@ -244,7 +246,7 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
+ 		if p.Module != nil {
+ 			fmt.Fprintf(h, "module %s@%s\n", p.Module.Path, p.Module.Version)
+ 		}
+-	} else if p.Goroot {
++	} else if p.Goroot || omitGopath {
+ 		// The Go compiler always hides the exact value of $GOROOT
+ 		// when building things in GOROOT.
+ 		//
+@@ -276,9 +278,9 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
+ 	}
+ 	if len(p.CgoFiles)+len(p.SwigFiles)+len(p.SwigCXXFiles) > 0 {
+ 		fmt.Fprintf(h, "cgo %q\n", b.toolID("cgo"))
+-		cppflags, cflags, cxxflags, fflags, ldflags, _ := b.CFlags(p)
++		cppflags, cflags, cxxflags, fflags, ldflags, _ := b.CFlags(p, true)
+ 
+-		ccExe := b.ccExe()
++		ccExe := filterCompilerFlags(b.ccExe(), true)
+ 		fmt.Fprintf(h, "CC=%q %q %q %q\n", ccExe, cppflags, cflags, ldflags)
+ 		// Include the C compiler tool ID so that if the C
+ 		// compiler changes we rebuild the package.
+@@ -286,14 +288,14 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
+ 			fmt.Fprintf(h, "CC ID=%q\n", ccID)
+ 		}
+ 		if len(p.CXXFiles)+len(p.SwigCXXFiles) > 0 {
+-			cxxExe := b.cxxExe()
++			cxxExe := filterCompilerFlags(b.cxxExe(), true)
+ 			fmt.Fprintf(h, "CXX=%q %q\n", cxxExe, cxxflags)
+ 			if cxxID, _, err := b.gccToolID(cxxExe[0], "c++"); err == nil {
+ 				fmt.Fprintf(h, "CXX ID=%q\n", cxxID)
+ 			}
+ 		}
+ 		if len(p.FFiles) > 0 {
+-			fcExe := b.fcExe()
++			fcExe := filterCompilerFlags(b.fcExe(), true)
+ 			fmt.Fprintf(h, "FC=%q %q\n", fcExe, fflags)
+ 			if fcID, _, err := b.gccToolID(fcExe[0], "f95"); err == nil {
+ 				fmt.Fprintf(h, "FC ID=%q\n", fcID)
+@@ -310,7 +312,7 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {
+ 		}
+ 	}
+ 	if p.Internal.BuildInfo != "" {
+-		fmt.Fprintf(h, "modinfo %q\n", p.Internal.BuildInfo)
++		//fmt.Fprintf(h, "modinfo %q\n", p.Internal.BuildInfo)
+ 	}
+ 
+ 	// Configuration specific to compiler toolchain.
+@@ -2989,8 +2991,25 @@ func envList(key, def string) []string {
+ 	return args
+ }
+ 
++var filterFlags = os.Getenv("CGO_PEDANTIC") == ""
++
++func filterCompilerFlags(flags []string, keepfirst bool) []string {
++	var newflags []string
++   var realkeepfirst bool = keepfirst
++	if !filterFlags {
++		return flags
++	}
++	for _, flag := range flags {
++		if strings.HasPrefix(flag, "-m") || realkeepfirst {
++			newflags = append(newflags, flag)
++           realkeepfirst = false
++		}
++	}
++	return newflags
++}
++
+ // CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.
+-func (b *Builder) CFlags(p *load.Package) (cppflags, cflags, cxxflags, fflags, ldflags []string, err error) {
++func (b *Builder) CFlags(p *load.Package, filtered bool) (cppflags, cflags, cxxflags, fflags, ldflags []string, err error) {
+ 	if cppflags, err = buildFlags("CPPFLAGS", "", p.CgoCPPFLAGS, checkCompilerFlags); err != nil {
+ 		return
+ 	}
+@@ -3006,6 +3025,13 @@ func (b *Builder) CFlags(p *load.Package) (cppflags, cflags, cxxflags, fflags, l
+ 	if ldflags, err = buildFlags("LDFLAGS", defaultCFlags, p.CgoLDFLAGS, checkLinkerFlags); err != nil {
+ 		return
+ 	}
++	if filtered {
++		cppflags = filterCompilerFlags(cppflags, false)
++		cflags = filterCompilerFlags(cflags, false)
++		cxxflags = filterCompilerFlags(cxxflags, false)
++		fflags = filterCompilerFlags(fflags, false)
++		ldflags = filterCompilerFlags(ldflags, false)
++	}
+ 
+ 	return
+ }
+@@ -3021,7 +3047,7 @@ var cgoRe = lazyregexp.New(`[/\\:]`)
+ 
+ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {
+ 	p := a.Package
+-	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS, err := b.CFlags(p)
++	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS, err := b.CFlags(p, false)
+ 	if err != nil {
+ 		return nil, nil, err
+ 	}
+@@ -3577,7 +3603,7 @@ func (b *Builder) swigIntSize(objdir string) (intsize string, err error) {
+ 
+ // Run SWIG on one SWIG input file.
+ func (b *Builder) swigOne(a *Action, p *load.Package, file, objdir string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {
+-	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _, err := b.CFlags(p)
++	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _, err := b.CFlags(p, false)
+ 	if err != nil {
+ 		return "", "", err
+ 	}
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go-1.18/0003-allow-GOTOOLDIR-to-be-overridden-in-the-environment.patch b/meta/recipes-devtools/go/go/0002-cmd-go-Allow-GOTOOLDIR-to-be-overridden-in-the-envir.patch
similarity index 57%
rename from meta/recipes-devtools/go/go-1.18/0003-allow-GOTOOLDIR-to-be-overridden-in-the-environment.patch
rename to meta/recipes-devtools/go/go/0002-cmd-go-Allow-GOTOOLDIR-to-be-overridden-in-the-envir.patch
index 2a86bdccf3..6abd424733 100644
--- a/meta/recipes-devtools/go/go-1.18/0003-allow-GOTOOLDIR-to-be-overridden-in-the-environment.patch
+++ b/meta/recipes-devtools/go/go/0002-cmd-go-Allow-GOTOOLDIR-to-be-overridden-in-the-envir.patch
@@ -1,7 +1,8 @@
-From 8512964c0bfdfc3c9c3805743ea7de551a1d476a Mon Sep 17 00:00:00 2001
+From 5cca2fa5997292a87302bdc7e7ed3231371e98bd Mon Sep 17 00:00:00 2001
 From: Alex Kube <alexander.j.kube@gmail.com>
 Date: Wed, 23 Oct 2019 21:15:37 +0430
-Subject: [PATCH] cmd/go: Allow GOTOOLDIR to be overridden in the environment
+Subject: [PATCH 2/9] cmd/go: Allow GOTOOLDIR to be overridden in the
+ environment
 
 to allow for split host/target build roots
 
@@ -12,17 +13,16 @@ Matt Madison <matt@madison.systems>.
 Upstream-Status: Inappropriate [OE specific]
 
 Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
-
 ---
  src/cmd/dist/build.go          | 4 +++-
  src/cmd/go/internal/cfg/cfg.go | 6 +++++-
  2 files changed, 8 insertions(+), 2 deletions(-)
 
 diff --git a/src/cmd/dist/build.go b/src/cmd/dist/build.go
-index bec1769..d82f612 100644
+index c36a12e..5d31718 100644
 --- a/src/cmd/dist/build.go
 +++ b/src/cmd/dist/build.go
-@@ -248,7 +248,9 @@ func xinit() {
+@@ -264,7 +264,9 @@ func xinit() {
  	}
  	xatexit(rmworkdir)
  
@@ -34,19 +34,22 @@ index bec1769..d82f612 100644
  
  // compilerEnv returns a map from "goos/goarch" to the
 diff --git a/src/cmd/go/internal/cfg/cfg.go b/src/cmd/go/internal/cfg/cfg.go
-index 57a3c1f..825d8c7 100644
+index 3257140..bb46253 100644
 --- a/src/cmd/go/internal/cfg/cfg.go
 +++ b/src/cmd/go/internal/cfg/cfg.go
-@@ -67,7 +67,11 @@ func defaultContext() build.Context {
- 		// variables. This matches the initialization of ToolDir in
- 		// go/build, except for using ctxt.GOROOT rather than
- 		// runtime.GOROOT.
--		build.ToolDir = filepath.Join(ctxt.GOROOT, "pkg/tool/"+runtime.GOOS+"_"+runtime.GOARCH)
-+		if s := os.Getenv("GOTOOLDIR"); s != "" {
-+			build.ToolDir = filepath.Clean(s)
-+		} else {
-+			build.ToolDir = filepath.Join(ctxt.GOROOT, "pkg/tool/"+runtime.GOOS+"_"+runtime.GOARCH)
-+		}
+@@ -229,7 +229,11 @@ func SetGOROOT(goroot string, isTestGo bool) {
+ 			// This matches the initialization of ToolDir in go/build, except for
+ 			// using ctxt.GOROOT and the installed GOOS and GOARCH rather than the
+ 			// GOROOT, GOOS, and GOARCH reported by the runtime package.
+-			build.ToolDir = filepath.Join(GOROOTpkg, "tool", installedGOOS+"_"+installedGOARCH)
++	   		if s := os.Getenv("GOTOOLDIR"); s != "" {
++				build.ToolDir = filepath.Clean(s)
++			} else {
++				build.ToolDir = filepath.Join(GOROOTpkg, "tool", installedGOOS+"_"+installedGOARCH)
++			}
+ 		}
  	}
- 
- 	ctxt.GOPATH = envOr("GOPATH", ctxt.GOPATH)
+ }
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go-1.18/0004-ld-add-soname-to-shareable-objects.patch b/meta/recipes-devtools/go/go/0003-ld-add-soname-to-shareable-objects.patch
similarity index 72%
rename from meta/recipes-devtools/go/go-1.18/0004-ld-add-soname-to-shareable-objects.patch
rename to meta/recipes-devtools/go/go/0003-ld-add-soname-to-shareable-objects.patch
index cd875f1164..ced0be1998 100644
--- a/meta/recipes-devtools/go/go-1.18/0004-ld-add-soname-to-shareable-objects.patch
+++ b/meta/recipes-devtools/go/go/0003-ld-add-soname-to-shareable-objects.patch
@@ -1,7 +1,7 @@
-From bf5cf5301ae5914498454c87293d1df2e1d8489f Mon Sep 17 00:00:00 2001
+From c7536a820f713013ab1d4acef74a4c8bd970bf8f Mon Sep 17 00:00:00 2001
 From: Alex Kube <alexander.j.kube@gmail.com>
 Date: Wed, 23 Oct 2019 21:16:32 +0430
-Subject: [PATCH 4/9] ld: add soname to shareable objects
+Subject: [PATCH 3/9] ld: add soname to shareable objects
 
 so that OE's shared library dependency handling
 can find them.
@@ -17,17 +17,19 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  src/cmd/link/internal/ld/lib.go | 3 +++
  1 file changed, 3 insertions(+)
 
+diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
+index 03b9f11..e91c92f 100644
 --- a/src/cmd/link/internal/ld/lib.go
 +++ b/src/cmd/link/internal/ld/lib.go
-@@ -1343,6 +1343,7 @@ func (ctxt *Link) hostlink() {
+@@ -1504,6 +1504,7 @@ func (ctxt *Link) hostlink() {
  				argv = append(argv, "-Wl,-z,relro")
  			}
  			argv = append(argv, "-shared")
 +			argv = append(argv, fmt.Sprintf("-Wl,-soname,%s", filepath.Base(*flagOutfile)))
  			if ctxt.HeadType == objabi.Hwindows {
- 				if *flagAslr {
- 					argv = addASLRargs(argv)
-@@ -1358,6 +1359,7 @@ func (ctxt *Link) hostlink() {
+ 				argv = addASLRargs(argv, *flagAslr)
+ 			} else {
+@@ -1519,6 +1520,7 @@ func (ctxt *Link) hostlink() {
  			argv = append(argv, "-Wl,-z,relro")
  		}
  		argv = append(argv, "-shared")
@@ -35,7 +37,7 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  	case BuildModePlugin:
  		if ctxt.HeadType == objabi.Hdarwin {
  			argv = append(argv, "-dynamiclib")
-@@ -1366,6 +1368,7 @@ func (ctxt *Link) hostlink() {
+@@ -1527,6 +1529,7 @@ func (ctxt *Link) hostlink() {
  				argv = append(argv, "-Wl,-z,relro")
  			}
  			argv = append(argv, "-shared")
@@ -43,3 +45,6 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  		}
  	}
  
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go-1.18/0005-make.bash-override-CC-when-building-dist-and-go_boot.patch b/meta/recipes-devtools/go/go/0004-make.bash-override-CC-when-building-dist-and-go_boot.patch
similarity index 62%
rename from meta/recipes-devtools/go/go-1.18/0005-make.bash-override-CC-when-building-dist-and-go_boot.patch
rename to meta/recipes-devtools/go/go/0004-make.bash-override-CC-when-building-dist-and-go_boot.patch
index 2845d21382..85e42f7660 100644
--- a/meta/recipes-devtools/go/go-1.18/0005-make.bash-override-CC-when-building-dist-and-go_boot.patch
+++ b/meta/recipes-devtools/go/go/0004-make.bash-override-CC-when-building-dist-and-go_boot.patch
@@ -1,7 +1,8 @@
-From 153e2dda6103fd9dd871be4bb495a8da5328301e Mon Sep 17 00:00:00 2001
+From 31ff609cc3d3bfcc2f2257fda1dbaafaec31eb0b Mon Sep 17 00:00:00 2001
 From: Alex Kube <alexander.j.kube@gmail.com>
 Date: Wed, 23 Oct 2019 21:17:16 +0430
-Subject: [PATCH] make.bash: override CC when building dist and go_bootstrap
+Subject: [PATCH 4/9] make.bash: override CC when building dist and
+ go_bootstrap
 
 for handling OE cross-canadian builds.
 
@@ -12,30 +13,32 @@ Matt Madison <matt@madison.systems>.
 Upstream-Status: Inappropriate [OE specific]
 
 Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
-
 ---
  src/make.bash | 4 ++--
  1 file changed, 2 insertions(+), 2 deletions(-)
 
 diff --git a/src/make.bash b/src/make.bash
-index 7986125..dd67029 100755
+index c07f39b..6ca7242 100755
 --- a/src/make.bash
 +++ b/src/make.bash
-@@ -181,7 +181,7 @@ if [ "$GOROOT_BOOTSTRAP" = "$GOROOT" ]; then
+@@ -194,7 +194,7 @@ if [ "$GOROOT_BOOTSTRAP" = "$GOROOT" ]; then
  	exit 1
  fi
  rm -f cmd/dist/dist
--GOROOT="$GOROOT_BOOTSTRAP" GOOS="" GOARCH="" GO111MODULE=off "$GOROOT_BOOTSTRAP/bin/go" build -o cmd/dist/dist ./cmd/dist
-+CC="${BUILD_CC:-${CC}}" GOROOT="$GOROOT_BOOTSTRAP" GOOS="" GOARCH="" GO111MODULE=off "$GOROOT_BOOTSTRAP/bin/go" build -o cmd/dist/dist ./cmd/dist
+-GOROOT="$GOROOT_BOOTSTRAP" GOOS="" GOARCH="" GO111MODULE=off GOEXPERIMENT="" GOENV=off GOFLAGS="" "$GOROOT_BOOTSTRAP/bin/go" build -o cmd/dist/dist ./cmd/dist
++CC="${BUILD_CC:-${CC}}" GOROOT="$GOROOT_BOOTSTRAP" GOOS="" GOARCH="" GO111MODULE=off GOEXPERIMENT="" GOENV=off GOFLAGS="" "$GOROOT_BOOTSTRAP/bin/go" build -o cmd/dist/dist ./cmd/dist
  
  # -e doesn't propagate out of eval, so check success by hand.
  eval $(./cmd/dist/dist env -p || echo FAIL=true)
-@@ -206,7 +206,7 @@ fi
+@@ -219,7 +219,7 @@ fi
  # Run dist bootstrap to complete make.bash.
  # Bootstrap installs a proper cmd/dist, built with the new toolchain.
- # Throw ours, built with Go 1.4, away after bootstrap.
+ # Throw ours, built with the bootstrap toolchain, away after bootstrap.
 -./cmd/dist/dist bootstrap -a $vflag $GO_DISTFLAGS "$@"
 +CC="${BUILD_CC:-${CC}}" ./cmd/dist/dist bootstrap -a $vflag $GO_DISTFLAGS "$@"
  rm -f ./cmd/dist/dist
  
  # DO NOT ADD ANY NEW CODE HERE.
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go-1.18/0006-cmd-dist-separate-host-and-target-builds.patch b/meta/recipes-devtools/go/go/0005-cmd-dist-separate-host-and-target-builds.patch
similarity index 87%
rename from meta/recipes-devtools/go/go-1.18/0006-cmd-dist-separate-host-and-target-builds.patch
rename to meta/recipes-devtools/go/go/0005-cmd-dist-separate-host-and-target-builds.patch
index 68e8efc1d2..29598449da 100644
--- a/meta/recipes-devtools/go/go-1.18/0006-cmd-dist-separate-host-and-target-builds.patch
+++ b/meta/recipes-devtools/go/go/0005-cmd-dist-separate-host-and-target-builds.patch
@@ -1,7 +1,7 @@
-From 7bc891e00be4263311d75aa2b2ee6a3b7b75355f Mon Sep 17 00:00:00 2001
+From 7a191e5191c8b813e929caedb3f3918bb08692a1 Mon Sep 17 00:00:00 2001
 From: Alex Kube <alexander.j.kube@gmail.com>
 Date: Wed, 23 Oct 2019 21:18:12 +0430
-Subject: [PATCH] cmd/dist: separate host and target builds
+Subject: [PATCH 5/9] cmd/dist: separate host and target builds
 
 Upstream-Status: Inappropriate [OE specific]
 
@@ -34,16 +34,15 @@ the meta/recipes-devtools/go tree by
 Matt Madison <matt@madison.systems>.
 
 Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
-
 ---
- src/cmd/dist/build.go | 156 ++++++++++++++++++++++++++++++------------
- 1 file changed, 113 insertions(+), 43 deletions(-)
+ src/cmd/dist/build.go | 152 +++++++++++++++++++++++++++++++-----------
+ 1 file changed, 113 insertions(+), 39 deletions(-)
 
 diff --git a/src/cmd/dist/build.go b/src/cmd/dist/build.go
-index d82f612..5c8459c 100644
+index 5d31718..1c7f308 100644
 --- a/src/cmd/dist/build.go
 +++ b/src/cmd/dist/build.go
-@@ -43,6 +43,7 @@ var (
+@@ -44,6 +44,7 @@ var (
  	goexperiment     string
  	workdir          string
  	tooldir          string
@@ -52,14 +51,14 @@ index d82f612..5c8459c 100644
  	oldgoarch        string
  	exe              string
 @@ -55,6 +56,7 @@ var (
- 
  	rebuildall   bool
  	defaultclang bool
+ 	noOpt        bool
 +	crossBuild   bool
  
  	vflag int // verbosity
  )
-@@ -251,6 +253,8 @@ func xinit() {
+@@ -267,6 +269,8 @@ func xinit() {
  	if tooldir = os.Getenv("GOTOOLDIR"); tooldir == "" {
  		tooldir = pathf("%s/pkg/tool/%s_%s", goroot, gohostos, gohostarch)
  	}
@@ -68,18 +67,18 @@ index d82f612..5c8459c 100644
  }
  
  // compilerEnv returns a map from "goos/goarch" to the
-@@ -496,8 +500,10 @@ func setup() {
- 	p := pathf("%s/pkg/%s_%s", goroot, gohostos, gohostarch)
+@@ -468,8 +472,10 @@ func setup() {
+ 	goosGoarch := pathf("%s/pkg/%s_%s", goroot, gohostos, gohostarch)
  	if rebuildall {
- 		xremoveall(p)
+ 		xremoveall(goosGoarch)
 +		xremoveall(build_tooldir)
  	}
- 	xmkdirall(p)
+ 	xmkdirall(goosGoarch)
 +	xmkdirall(build_tooldir)
- 
- 	if goos != gohostos || goarch != gohostarch {
- 		p := pathf("%s/pkg/%s_%s", goroot, goos, goarch)
-@@ -1267,17 +1273,35 @@ func cmdbootstrap() {
+ 	xatexit(func() {
+ 		if files := xreaddir(goosGoarch); len(files) == 0 {
+ 			xremove(goosGoarch)
+@@ -1276,17 +1282,35 @@ func cmdbootstrap() {
  
  	var noBanner, noClean bool
  	var debug bool
@@ -116,23 +115,25 @@ index d82f612..5c8459c 100644
  	// Set GOPATH to an internal directory. We shouldn't actually
  	// need to store files here, since the toolchain won't
  	// depend on modules outside of vendor directories, but if
-@@ -1345,8 +1369,13 @@ func cmdbootstrap() {
+@@ -1354,9 +1378,14 @@ func cmdbootstrap() {
  		xprintf("\n")
  	}
  
 -	gogcflags = os.Getenv("GO_GCFLAGS") // we were using $BOOT_GO_GCFLAGS until now
+-	setNoOpt()
 -	goldflags = os.Getenv("GO_LDFLAGS") // we were using $BOOT_GO_LDFLAGS until now
 +	// For split host/target cross/cross-canadian builds, we don't
 +	// want to be setting these flags until after we have compiled
 +	// the toolchain that runs on the build host.
 +	if !crossBuild {
 +		gogcflags = os.Getenv("GO_GCFLAGS") // we were using $BOOT_GO_GCFLAGS until now
++		setNoOpt()
 +		goldflags = os.Getenv("GO_LDFLAGS") // we were using $BOOT_GO_LDFLAGS until now
 +	}
  	goBootstrap := pathf("%s/go_bootstrap", tooldir)
- 	cmdGo := pathf("%s/go", gobin)
+ 	cmdGo := pathf("%s/go", gorootBin)
  	if debug {
-@@ -1375,7 +1404,11 @@ func cmdbootstrap() {
+@@ -1385,7 +1414,11 @@ func cmdbootstrap() {
  		xprintf("\n")
  	}
  	xprintf("Building Go toolchain2 using go_bootstrap and Go toolchain1.\n")
@@ -144,10 +145,10 @@ index d82f612..5c8459c 100644
 +	}
  	// Now that cmd/go is in charge of the build process, enable GOEXPERIMENT.
  	os.Setenv("GOEXPERIMENT", goexperiment)
- 	goInstall(goBootstrap, append([]string{"-i"}, toolchain...)...)
-@@ -1414,50 +1447,84 @@ func cmdbootstrap() {
+ 	goInstall(goBootstrap, toolchain...)
+@@ -1421,46 +1454,84 @@ func cmdbootstrap() {
+ 		copyfile(pathf("%s/compile3", tooldir), pathf("%s/compile", tooldir), writeExec)
  	}
- 	checkNotStale(goBootstrap, append(toolchain, "runtime/internal/sys")...)
  
 -	if goos == oldgoos && goarch == oldgoarch {
 -		// Common case - not setting up for cross-compilation.
@@ -197,8 +198,6 @@ index d82f612..5c8459c 100644
 -		timelog("build", "host toolchain")
 -		if vflag > 0 {
 -			xprintf("\n")
--		}
--		xprintf("Building packages and commands for host, %s/%s.\n", goos, goarch)
 +
 +		if goos == oldgoos && goarch == oldgoarch {
 +			// Common case - not setting up for cross-compilation.
@@ -230,7 +229,8 @@ index d82f612..5c8459c 100644
 +			os.Setenv("GOARCH", goarch)
 +			os.Setenv("CC", compilerEnvLookup(defaultcc, goos, goarch))
 +			xprintf("Building packages and commands for target, %s/%s.\n", goos, goarch)
-+		}
+ 		}
+-		xprintf("Building packages and commands for host, %s/%s.\n", goos, goarch)
  		goInstall(goBootstrap, "std", "cmd")
  		checkNotStale(goBootstrap, "std", "cmd")
  		checkNotStale(cmdGo, "std", "cmd")
@@ -252,22 +252,18 @@ index d82f612..5c8459c 100644
 -		xprintf("Building packages and commands for target, %s/%s.\n", goos, goarch)
 -	}
 -	targets := []string{"std", "cmd"}
--	if goos == "js" && goarch == "wasm" {
--		// Skip the cmd tools for js/wasm. They're not usable.
--		targets = targets[:1]
--	}
 -	goInstall(goBootstrap, targets...)
+-	checkNotStale(goBootstrap, append(toolchain, "runtime/internal/sys")...)
 -	checkNotStale(goBootstrap, targets...)
 -	checkNotStale(cmdGo, targets...)
 -	if debug {
 -		run("", ShowOutput|CheckExit, pathf("%s/compile", tooldir), "-V=full")
--		run("", ShowOutput|CheckExit, pathf("%s/buildid", tooldir), pathf("%s/pkg/%s_%s/runtime/internal/sys.a", goroot, goos, goarch))
 -		checkNotStale(goBootstrap, append(toolchain, "runtime/internal/sys")...)
 -		copyfile(pathf("%s/compile4", tooldir), pathf("%s/compile", tooldir), writeExec)
  	}
  
  	// Check that there are no new files in $GOROOT/bin other than
-@@ -1474,8 +1541,11 @@ func cmdbootstrap() {
+@@ -1477,8 +1548,11 @@ func cmdbootstrap() {
  		}
  	}
  
@@ -281,3 +277,6 @@ index d82f612..5c8459c 100644
  
  	if goos == "android" {
  		// Make sure the exec wrapper will sync a fresh $GOROOT to the device.
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go-1.18/0007-cmd-go-make-GOROOT-precious-by-default.patch b/meta/recipes-devtools/go/go/0006-cmd-go-make-GOROOT-precious-by-default.patch
similarity index 73%
rename from meta/recipes-devtools/go/go-1.18/0007-cmd-go-make-GOROOT-precious-by-default.patch
rename to meta/recipes-devtools/go/go/0006-cmd-go-make-GOROOT-precious-by-default.patch
index 4b4d0d4f3d..520e41da86 100644
--- a/meta/recipes-devtools/go/go-1.18/0007-cmd-go-make-GOROOT-precious-by-default.patch
+++ b/meta/recipes-devtools/go/go/0006-cmd-go-make-GOROOT-precious-by-default.patch
@@ -1,7 +1,7 @@
-From 9ba507e076c744f4d394418e4a849e68cd426a4a Mon Sep 17 00:00:00 2001
+From efab470498bb0a30ee2d00455a0c8c10459f6347 Mon Sep 17 00:00:00 2001
 From: Alex Kube <alexander.j.kube@gmail.com>
 Date: Wed, 23 Oct 2019 21:18:56 +0430
-Subject: [PATCH 7/9] cmd/go: make GOROOT precious by default
+Subject: [PATCH 6/9] cmd/go: make GOROOT precious by default
 
 Upstream-Status: Inappropriate [OE specific]
 
@@ -27,9 +27,11 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  src/cmd/go/internal/work/exec.go   | 25 +++++++++++++++++++++++++
  3 files changed, 34 insertions(+)
 
+diff --git a/src/cmd/go/internal/work/action.go b/src/cmd/go/internal/work/action.go
+index 8beb134..68a8cfe 100644
 --- a/src/cmd/go/internal/work/action.go
 +++ b/src/cmd/go/internal/work/action.go
-@@ -670,6 +670,9 @@ func (b *Builder) addTransitiveLinkDeps(
+@@ -718,6 +718,9 @@ func (b *Builder) addTransitiveLinkDeps(a, a1 *Action, shlib string) {
  			if p1 == nil || p1.Shlib == "" || haveShlib[filepath.Base(p1.Shlib)] {
  				continue
  			}
@@ -39,9 +41,11 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  			haveShlib[filepath.Base(p1.Shlib)] = true
  			// TODO(rsc): The use of ModeInstall here is suspect, but if we only do ModeBuild,
  			// we'll end up building an overall library or executable that depends at runtime
+diff --git a/src/cmd/go/internal/work/build.go b/src/cmd/go/internal/work/build.go
+index 2f2860a..8cc6166 100644
 --- a/src/cmd/go/internal/work/build.go
 +++ b/src/cmd/go/internal/work/build.go
-@@ -167,6 +167,8 @@ See also: go install, go get, go clean.
+@@ -217,6 +217,8 @@ See also: go install, go get, go clean.
  
  const concurrentGCBackendCompilationEnabledByDefault = true
  
@@ -50,10 +54,10 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  func init() {
  	// break init cycle
  	CmdBuild.Run = runBuild
-@@ -179,6 +181,10 @@ func init() {
- 
- 	AddBuildFlags(CmdBuild, DefaultBuildFlags)
- 	AddBuildFlags(CmdInstall, DefaultBuildFlags)
+@@ -230,6 +232,10 @@ func init() {
+ 		AddCoverFlags(CmdBuild, nil)
+ 		AddCoverFlags(CmdInstall, nil)
+ 	}
 +
 +	if x := os.Getenv("GOROOT_OVERRIDE"); x != "" {
 +		goRootPrecious = false
@@ -61,10 +65,12 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  }
  
  // Note that flags consulted by other parts of the code
+diff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go
+index 62e1774..cde867b 100644
 --- a/src/cmd/go/internal/work/exec.go
 +++ b/src/cmd/go/internal/work/exec.go
-@@ -468,6 +468,23 @@ func (b *Builder) build(a *Action) (err
- 		return errors.New("binary-only packages are no longer supported")
+@@ -546,6 +546,23 @@ func (b *Builder) build(ctx context.Context, a *Action) (err error) {
+ 		return errors.New("cannot compile Go " + p.Module.GoVersion + " code")
  	}
  
 +	if goRootPrecious && (a.Package.Standard || a.Package.Goroot) {
@@ -87,7 +93,7 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  	if err := b.Mkdir(a.Objdir); err != nil {
  		return err
  	}
-@@ -1520,6 +1537,14 @@ func BuildInstallFunc(b *Builder, a *Act
+@@ -1643,6 +1660,14 @@ func (b *Builder) linkShared(ctx context.Context, a *Action) (err error) {
  		return err
  	}
  
@@ -102,3 +108,6 @@ Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
  	if err := b.Mkdir(a.Objdir); err != nil {
  		return err
  	}
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go-1.18/0001-exec.go-do-not-write-linker-flags-into-buildids.patch b/meta/recipes-devtools/go/go/0007-exec.go-do-not-write-linker-flags-into-buildids.patch
similarity index 79%
rename from meta/recipes-devtools/go/go-1.18/0001-exec.go-do-not-write-linker-flags-into-buildids.patch
rename to meta/recipes-devtools/go/go/0007-exec.go-do-not-write-linker-flags-into-buildids.patch
index 20b6636f65..7d9869b536 100644
--- a/meta/recipes-devtools/go/go-1.18/0001-exec.go-do-not-write-linker-flags-into-buildids.patch
+++ b/meta/recipes-devtools/go/go/0007-exec.go-do-not-write-linker-flags-into-buildids.patch
@@ -1,7 +1,7 @@
-From bdd69b55387f80c8df18d0af5008bf5e1a66be6a Mon Sep 17 00:00:00 2001
+From 0ba747e6a4b251a0d9eed0cfd8f8c491bb508040 Mon Sep 17 00:00:00 2001
 From: Alexander Kanavin <alex.kanavin@gmail.com>
 Date: Mon, 23 Nov 2020 19:22:04 +0000
-Subject: [PATCH] exec.go: do not write linker flags into buildids
+Subject: [PATCH 7/9] exec.go: do not write linker flags into buildids
 
 The flags can contain build-specific paths, breaking reproducibility.
 
@@ -15,10 +15,10 @@ Signed-off-by: Alexander Kanavin <alex.kanavin@gmail.com>
  1 file changed, 2 insertions(+), 2 deletions(-)
 
 diff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go
-index 696db23..727d40b 100644
+index cde867b..5cb1812 100644
 --- a/src/cmd/go/internal/work/exec.go
 +++ b/src/cmd/go/internal/work/exec.go
-@@ -1136,7 +1136,7 @@ func (b *Builder) linkActionID(a *Action) cache.ActionID {
+@@ -1331,7 +1331,7 @@ func (b *Builder) linkActionID(a *Action) cache.ActionID {
  	}
  
  	// Toolchain-dependent configuration, shared with b.linkSharedActionID.
@@ -27,7 +27,7 @@ index 696db23..727d40b 100644
  
  	// Input files.
  	for _, a1 := range a.Deps {
-@@ -1418,7 +1418,7 @@ func (b *Builder) linkSharedActionID(a *Action) cache.ActionID {
+@@ -1626,7 +1626,7 @@ func (b *Builder) linkSharedActionID(a *Action) cache.ActionID {
  	fmt.Fprintf(h, "goos %s goarch %s\n", cfg.Goos, cfg.Goarch)
  
  	// Toolchain-dependent configuration, shared with b.linkActionID.
@@ -37,5 +37,5 @@ index 696db23..727d40b 100644
  	// Input files.
  	for _, a1 := range a.Deps {
 -- 
-2.17.1
+2.30.2
 
diff --git a/meta/recipes-devtools/go/go-1.18/0001-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch b/meta/recipes-devtools/go/go/0008-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch
similarity index 82%
rename from meta/recipes-devtools/go/go-1.18/0001-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch
rename to meta/recipes-devtools/go/go/0008-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch
index 257454a67d..fe830ce35c 100644
--- a/meta/recipes-devtools/go/go-1.18/0001-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch
+++ b/meta/recipes-devtools/go/go/0008-src-cmd-dist-buildgo.go-do-not-hardcode-host-compile.patch
@@ -1,8 +1,8 @@
-From 2055a46b396e272616c0b2273903e02c3b49a2ff Mon Sep 17 00:00:00 2001
+From 1cbb416538a9c7c3fbedcb23f4d90d5c48becca8 Mon Sep 17 00:00:00 2001
 From: Alexander Kanavin <alex.kanavin@gmail.com>
 Date: Tue, 10 Nov 2020 16:33:27 +0000
-Subject: [PATCH] src/cmd/dist/buildgo.go: do not hardcode host compilers into
- target binaries
+Subject: [PATCH 8/9] src/cmd/dist/buildgo.go: do not hardcode host compilers
+ into target binaries
 
 These come from $CC/$CXX on the build host and are not useful on targets;
 additionally as they contain host specific paths, this helps reproducibility.
@@ -14,10 +14,10 @@ Signed-off-by: Alexander Kanavin <alex.kanavin@gmail.com>
  1 file changed, 4 insertions(+), 4 deletions(-)
 
 diff --git a/src/cmd/dist/buildgo.go b/src/cmd/dist/buildgo.go
-index caafc13..4eb1c96 100644
+index 29b0167..63a49f0 100644
 --- a/src/cmd/dist/buildgo.go
 +++ b/src/cmd/dist/buildgo.go
-@@ -34,8 +34,8 @@ func mkzdefaultcc(dir, file string) {
+@@ -33,8 +33,8 @@ func mkzdefaultcc(dir, file string) {
  		fmt.Fprintf(&buf, "package cfg\n")
  		fmt.Fprintln(&buf)
  		fmt.Fprintf(&buf, "const DefaultPkgConfig = `%s`\n", defaultpkgconfig)
@@ -28,7 +28,7 @@ index caafc13..4eb1c96 100644
  		writefile(buf.String(), file, writeSkipSame)
  		return
  	}
-@@ -46,8 +46,8 @@ func mkzdefaultcc(dir, file string) {
+@@ -45,8 +45,8 @@ func mkzdefaultcc(dir, file string) {
  	fmt.Fprintf(&buf, "package main\n")
  	fmt.Fprintln(&buf)
  	fmt.Fprintf(&buf, "const defaultPkgConfig = `%s`\n", defaultpkgconfig)
@@ -39,3 +39,6 @@ index caafc13..4eb1c96 100644
  	writefile(buf.String(), file, writeSkipSame)
  }
  
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go/0009-go-Filter-build-paths-on-staticly-linked-arches.patch b/meta/recipes-devtools/go/go/0009-go-Filter-build-paths-on-staticly-linked-arches.patch
new file mode 100644
index 0000000000..49da5f6297
--- /dev/null
+++ b/meta/recipes-devtools/go/go/0009-go-Filter-build-paths-on-staticly-linked-arches.patch
@@ -0,0 +1,60 @@
+From 18011f72125bbea273d07ee5d792ac0ce6059572 Mon Sep 17 00:00:00 2001
+From: Richard Purdie <richard.purdie@linuxfoundation.org>
+Date: Sat, 2 Jul 2022 23:08:13 +0100
+Subject: [PATCH 9/9] go: Filter build paths on staticly linked arches
+
+Filter out build time paths from ldflags and other flags variables when they're
+embedded in the go binary so that builds are reproducible regardless of build
+location. This codepath is hit for statically linked go binaries such as those
+on mips/ppc.
+
+Upstream-Status: Submitted [https://github.com/golang/go/pull/56410]
+
+Signed-off-by: Richard Purdie <richard.purdie@linuxfoundation.org>
+---
+ src/cmd/go/internal/load/pkg.go | 15 +++++++++++++--
+ 1 file changed, 13 insertions(+), 2 deletions(-)
+
+diff --git a/src/cmd/go/internal/load/pkg.go b/src/cmd/go/internal/load/pkg.go
+index f427e29..6d6dc4e 100644
+--- a/src/cmd/go/internal/load/pkg.go
++++ b/src/cmd/go/internal/load/pkg.go
+@@ -2270,6 +2270,17 @@ func (p *Package) collectDeps() {
+ // to their VCS information (vcsStatusError).
+ var vcsStatusCache par.Cache
+ 
++func filterCompilerFlags(flags string) string {
++	var newflags []string
++	for _, flag := range strings.Fields(flags) {
++		if strings.HasPrefix(flag, "--sysroot") || strings.HasPrefix(flag, "-fmacro-prefix-map") || strings.HasPrefix(flag, "-fdebug-prefix-map") {
++			continue
++		}
++		newflags = append(newflags, flag)
++	}
++	return strings.Join(newflags, " ")
++}
++
+ // setBuildInfo gathers build information, formats it as a string to be
+ // embedded in the binary, then sets p.Internal.BuildInfo to that string.
+ // setBuildInfo should only be called on a main package with no errors.
+@@ -2376,7 +2387,7 @@ func (p *Package) setBuildInfo(autoVCS bool) {
+ 	if gcflags := BuildGcflags.String(); gcflags != "" && cfg.BuildContext.Compiler == "gc" {
+ 		appendSetting("-gcflags", gcflags)
+ 	}
+-	if ldflags := BuildLdflags.String(); ldflags != "" {
++	if ldflags := filterCompilerFlags(BuildLdflags.String()); ldflags != "" {
+ 		// https://go.dev/issue/52372: only include ldflags if -trimpath is not set,
+ 		// since it can include system paths through various linker flags (notably
+ 		// -extar, -extld, and -extldflags).
+@@ -2422,7 +2433,7 @@ func (p *Package) setBuildInfo(autoVCS bool) {
+ 	// subset of flags that are known not to be paths?
+ 	if cfg.BuildContext.CgoEnabled && !cfg.BuildTrimpath {
+ 		for _, name := range []string{"CGO_CFLAGS", "CGO_CPPFLAGS", "CGO_CXXFLAGS", "CGO_LDFLAGS"} {
+-			appendSetting(name, cfg.Getenv(name))
++			appendSetting(name, filterCompilerFlags(cfg.Getenv(name)))
+ 		}
+ 	}
+ 	appendSetting("GOARCH", cfg.BuildContext.GOARCH)
+-- 
+2.30.2
+
diff --git a/meta/recipes-devtools/go/go_1.17.13.bb b/meta/recipes-devtools/go/go_1.20.10.bb
similarity index 92%
rename from meta/recipes-devtools/go/go_1.17.13.bb
rename to meta/recipes-devtools/go/go_1.20.10.bb
index bb57c1c48a..46f5fbc6be 100644
--- a/meta/recipes-devtools/go/go_1.17.13.bb
+++ b/meta/recipes-devtools/go/go_1.20.10.bb
@@ -3,7 +3,8 @@ require go-target.inc
 
 inherit linuxloader
 
-export GOBUILDMODE=""
+CGO_LDFLAGS:append = " -no-pie"
+
 export GO_LDSO = "${@get_linuxloader(d)}"
 export CC_FOR_TARGET = "gcc"
 export CXX_FOR_TARGET = "g++"
